<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="../../style.css">
  <link rel="stylesheet" href="../../css/demo.css">
   <script src="../../scripts/demoScripts.js"></script>
  <title>Merge Sort Demo</title>
  <style>
    .array-container { display: flex; gap: 12px; margin-bottom: 10px; }
    .left { background-color: #ffcc00; }
    .right { background-color: #1f77b4; }
    .compare { background: #f99; }
    .merged { background: #9f9; }
	.element { margin: 6px; }
    .active-subarray { background-color: #FF9C00; border-radius: 4px; padding: 4px; }
    #aux-label, #main-label, #other-label { font-weight: bold; margin-bottom: 8px; }
    #aux-container { margin-bottom: 20px; }
    #main-label { margin-top: 20px; }
    #subarrays { margin-bottom: 20px; }
    #description { margin-top: 10px; font-style: italic; }
    #buttons { margin: 10px 0; }
    #play { margin-left: 20px; }
    #buttons button, #buttons select, #buttons label { margin-right: 8px; }
	.element-wrapper {
	  display: flex;
	  flex-direction: column;
	  align-items: center;
	  gap: 2px;               /* space between value and index */
	}
	.element-index {
	  font-size: 1em;
	 
	}
	

	.hidden{
		background-color:transparent;
		border-color:transparent;
		color:transparent
		
	}
	

  </style>
</head>
<body>
  <h1>Merge Sort Demo</h1>
  <div id="controls">
    <label>Size:<input type="number" id="size" min="5" max="20" value="16" /></label>
    <button id="generate">Random Array</button>
    <input type="text" id="customArray" placeholder="12,6,10,5,3,8,1,20,13" size="30" />
    <button id="useCustom">Use Custom Array</button>
  </div>
  <div id="buttons">
    <button id="prev" disabled>Previous</button>
    <button id="next" disabled>Next</button>
    <button id="play">Play</button>
    <button id="pause" disabled>Pause</button>
    <label for="speed">Speed:</label>
    <select id="speed">
      <option value="1">1x</option>
      <option value="2">2x</option>
      <option value="4">4x</option>
    </select>
  </div>
  <div id="legend" class="legend">
    <strong>Legend:</strong>
    <span><span class="legend-box compare"></span> Compare</span>
    <span><span class="legend-box merged"></span> Placed</span>
    <span><span class="legend-box left"></span> Left subarray</span>
    <span><span class="legend-box right"></span> Right subarray</span>
    <span><span class="legend-box active-subarray"></span> Active subarray</span>
  </div>
  <div id="main-label">Sorting Array:</div>
  <div id="visualization" class="array-container"></div>
  <div id="aux-label">Auxiliary Array:</div>
  <div id="aux-container" class="array-container"></div>
  <div id="other-label">Conceptual Arrays (these don't really exist):</div>
  <div id="subarrays"></div>
  <div id="description">Press "Next" to begin.</div>

  <script>
    window.onGenerate = function(isCustom) {
      if (isCustom) {
        return document.getElementById('customArray').value
          .split(',').map(x => parseInt(x.trim(), 10));
      }
      const n = parseInt(document.getElementById('size').value, 10);
      return Array.from({ length: n }, () => Math.floor(Math.random() * 90) + 10);
    };
    window.genSteps = function(arr) {
      let a = arr.slice(), records = [];
      const record = (type, meta={}) => records.push({ a: a.slice(), type, ...meta });
      function mergeSort(l,r) {
        if(l>=r) return;
        const m = Math.floor((l+r)/2);
        record('split',{l,m,r}); 
		record('recurseLeft',{l,m,r}); 
		mergeSort(l,m);
        record('recurseRight',{l,m,r}); 
		mergeSort(m+1,r);
      
		merge(l,m,r);
        record('mergeEnd',{l,m,r}); 
		
      }
	  function merge(l, m, r) {
		  // 1) grab the two runs out of A and copy them to “aux”
		  const L = a.slice(l, m + 1);
		  const R = a.slice(m + 1, r + 1);
		   record('copyToAux', { l, m, r });
		 

		  // 2) indicate we’re merging back INTO the main array
		  record('mergeStep', { l, m, r });

		  // 3) merge from L/R back into A
		  let i = 0, j = 0, k = l;
		  while (i < L.length && j < R.length) {
			const idxL = l + i;
			const idxR = m + 1 + j;
			record('compare', { idxL, idxR, valueL: L[i], valueR: R[j], l, m, r });
			const v = L[i] <= R[j] ? L[i++] : R[j++];
			a[k] = v;
			record('placed', { k, newValue: v, l, m, r });
			k++;
		  }
		  // finish any leftovers
		  while (i < L.length) {
			const v = L[i++];
			a[k] = v;
			record('placed', { k, newValue: v, l, m, r });
			k++;
		  }
		  while (j < R.length) {
			const v = R[j++];
			a[k] = v;
			record('placed', { k, newValue: v, l, m, r });
			k++;
		  }

		  // 4) done merging this segment
		 // record('copyToAux', { l, r });
		}

      record('init'); mergeSort(0,arr.length-1); record('done'); return records;
    };
    window.setupAux = function(original,n){
      const aux=document.getElementById('aux-container'); aux.innerHTML='';
      original.forEach(v=>{const el=document.createElement('div');
	  el.className='element';
	  el.textContent=v;aux.appendChild(el);
	  el.classList.add('hidden');
	  });
    
  const oldBox = aux.querySelector('.aux-segment-box');
  if (oldBox) {
    // unwrap the cells back into aux
    const parent = oldBox.parentNode;
    while (oldBox.firstChild) {
      parent.insertBefore(oldBox.firstChild, oldBox);
    }
    parent.removeChild(oldBox);
  }
}
    window.renderStep = function(steps,idx,original){
      const main=document.getElementById('visualization'),
	  aux=document.getElementById('aux-container'),
	  sub=document.getElementById('subarrays'),
	  desc=document.getElementById('description');
      main.innerHTML=''; 
	  sub.innerHTML=''; 
	  window.setupAux(original,original.length);
	  
	  
	  Array.from(aux.children).forEach(el =>el.classList.remove('merged'));
      steps.slice(0,idx+1).forEach(st=>{
	  if(st.type==='copyToAux')
	  {for(let k=st.l;k<=st.r;k++)
	  {
	  aux.children[k].textContent=st.a[k];
	  }}});
      Array.from(aux.children).forEach(el=>el.classList.remove('compare'));


		  if(!steps.length) return; const st=steps[idx];
		  // 1) Build up a set of “still highlighted” indices
	const placedSet = new Set();
	for (let j = 0; j <= idx; j++) {
	  const s = steps[j];
	  if (s.type === 'copyToAux') {
		placedSet.clear();          // clear highlights on each copy
	  }
	  if (s.type === 'placed') {
		placedSet.add(s.k);         // remember any placed index
	  }
	}

	// 2) Now redraw the main array, highlighting only those indices
	st.a.forEach((v, i) => {
	  const wrapper = document.createElement('div');
	  wrapper.className = 'element-wrapper';

	  const c = document.createElement('div');
	  c.className = 'element';
	  c.textContent = v;
	  if (placedSet.has(i)) {
		c.classList.add('merged');
	  }
	  wrapper.appendChild(c);

	  const idxLabel = document.createElement('div');
	  idxLabel.className = 'element-index';
	  idxLabel.textContent = i;
	  wrapper.appendChild(idxLabel);

	  main.appendChild(wrapper);
	});


      const active=[];
      steps.slice(0,idx+1).forEach(s=>{if(s.type==='split')active.push(s);
	  if(s.type==='mergeEnd')
	  active.pop();});
      active.forEach(sp=>{
        const {l,m,r}=sp;
        const row=document.createElement('div');
		row.className='array-container';
        for(let p=0;p<l;p++){
		const ph=document.createElement('div');
		ph.className='element';
		ph.style.visibility='hidden';
		row.appendChild(ph);}        
        const leftWrap=document.createElement('div');leftWrap.className='array-container';
		
        // highlight only the current subarray and the aux array during the merge step
				if (st.type === 'mergeStep'||st.type === 'compare'||st.type === 'copyToAux'||st.type === 'placed') {
		  for (let k = st.l; k <= st.r; k++) {
			aux.children[k].classList.remove('hidden');
		  }
		}

        if(st.l===l && st.m===m && ['recurseLeft','mergeStep','compare','placed','mergeEnd'].includes(st.type)) leftWrap.classList.add('active-subarray');
        for(let i=l;i<=m;i++){const ce=document.createElement('div');ce.className='element left';ce.textContent=st.a[i];leftWrap.appendChild(ce);}row.appendChild(leftWrap);
        const rightWrap=document.createElement('div');rightWrap.className='array-container';
        if(st.l===l && st.m===m && ['recurseRight','mergeStep','compare','placed','mergeEnd'].includes(st.type)) rightWrap.classList.add('active-subarray');
        for(let i=m+1;i<=r;i++){const ce=document.createElement('div');ce.className='element right';ce.textContent=st.a[i];rightWrap.appendChild(ce);}row.appendChild(rightWrap);
        sub.appendChild(row);
      });
      switch (st.type) {
  case 'init':
    desc.textContent = 'Initial array.';
    break;

  case 'split':
    desc.textContent = `Split [${st.l},${st.m}] & [${st.m + 1},${st.r}]`;
    break;

  case 'recurseLeft':
	  if(st.m-st.l>0) {
		desc.textContent = `Sorting left [${st.l},${st.m}]`;
	  } else {
		  desc.textContent = `Base case. Already sorted`;
	  }
    break;

  case 'recurseRight':
	  if(st.r-(st.m+1)>0) {
		desc.textContent = `Sorting right [${st.m + 1},${st.r}]`;
	  } else {
		desc.textContent = `Base case. Already sorted.`;
	  }
    break;

  case 'mergeStep':
    desc.textContent = `Merging [${st.l},${st.m}] and [${st.m + 1},${st.r}]`;
    break;

  case 'compare': {
    // highlight exactly the two slots we recorded
	aux.children[st.idxL].classList.add('compare');
	aux.children[st.idxR].classList.add('compare');


    desc.textContent = `Compare ${st.valueL} & ${st.valueR}`;
    break;
  }

  case 'placed':
  
    desc.textContent = `Placed ${st.newValue} at index ${st.k}`;
    break;

  case 'mergeEnd':
    desc.textContent = `Merged segment [${st.l},${st.m}] and [${st.m + 1},${st.r}]`;
    break;

  case 'copyToAux': 
  // write the values
  for (let k = st.l; k <= st.r; k++) {
    aux.children[k].textContent = st.a[k];
  }
  // flash this range green
  for (let k = st.l; k <= st.r; k++) {
    aux.children[k].classList.add('merged');
  }

    desc.textContent = `Copied [${st.l},${st.r}] to auxiliary`;
    break;

  case 'done':
    desc.textContent = 'Array fully sorted!';
    break;

  default:
    // no-op
    break;
}

    };
  </script>
 
</body>
</html>