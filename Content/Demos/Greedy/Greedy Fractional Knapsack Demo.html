<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fractional Knapsack Demo</title>
  <script src="../../scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/demo.css">
  <style>
    /* === Shared styling with Heapsort Demo for consistency === */
    body { font-family: sans-serif; margin: 20px; }
    #buttons { margin: 10px 0; }
    #buttons button, #buttons select { margin-right: 8px; }
    .legend { margin-top: 10px; }
    .legend-box { display: inline-block; width: 16px; height: 16px; margin-right: 4px; vertical-align: middle; border: 1px solid #666; }
    .legend-label { margin-right: 16px; vertical-align: middle; font-size: 14px; }
    #commentary { margin-top: 10px; font-style: italic; height: 40px; }
    .array-container { display: flex; margin-top: 10px; align-items: flex-end; }
    .element-wrapper { display: flex; flex-direction: column; align-items: center; margin-right: 8px; }
    .element { width: 40px; height: 40px; line-height: 40px; text-align: center; border: 1px solid #333; font-size: 0.75em;}
   .index-label {font-size: 0.8em;margin-top: 4px;color: #333;width: 40px;display: block;text-align: center;}
    .final { background-color: lightblue; }
    .array-container { margin-bottom: 44px}

     /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Fractional‚ÄêKnapsack Array Colors ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .v-element { background-color: #cce3ff; }   /* values (v) */
    .w-element { background-color: #f4cccc; }   /* weights (w) */
    .p-element { background-color: #b6d8a9; }   /* ratios (p) */
    .s-element { background-color: #f6a94c; }   /* solution (s) */

    .legend-box.v { background-color: #cce3ff; }
    .legend-box.w { background-color: #f4cccc; }
    .legend-box.p { background-color: #b6d8a9; }
    .legend-box.s { background-color: #f6a94c; }

    .element-wrapper { position: relative; display: inline-block; }
  .pointer {
    position: absolute;
    bottom: -2.5em;
    left: 50%;
    transform: translateX(-50%);
    font-weight: bold;
   color: #000;
   line-height: 1;
   text-align: center;
   /* font-size: 1.4em; */
  }

  /* arrow retains the larger size */
  .pointer-arrow {
    font-size: 1.4em;
    line-height: 1;
  }
  /* label ‚Äúi‚Äù smaller */
  .pointer-label {
    font-size: 0.7em;
    line-height: 1;
  }

  /* root variable for animation duration */
:root { --sort-anim-duration: 500ms; }

@keyframes sort-move {
  0%   { transform: translateY(0)    scale(1);   }
  50%  { transform: translateY(-20px) scale(1.1); }
  100% { transform: translateY(0)    scale(1);   }
}

/* apply the keyframe whenever .moved is toggled */
.element-wrapper.moved {
  animation: sort-move var(--sort-anim-duration) ease-in-out;
}

.element {
  width: 40px;
  height: 40px;
  line-height: 40px;
  text-align: center;
  border: 1px solid #333;
  font-size: 0.75em;
}

.element.highlight {
  border: 3px solid #000;
}

.legend-box.s { background-color: #f6a94c; }

.i-element { background-color: #edd54f; } /* light yellow */
.legend-box.i { background-color: #edd54f; }

  </style>
</head>
<body class = "no-tooltips">
  <h2>Fractional Knapsack Demo</h2>
  <!-- 1) NEW: Single‚Äêline v/w inputs above all other buttons -->
  <div id="arrayInputs" style="margin-bottom:10px; white-space: nowrap;">
    <label for="vArrayInput">v (Values):</label>
    <input type="text"
       id="vArrayInput"
       placeholder="e.g. 60,100,120"
       style="width:180px; margin: 0 8px;">

    <label for="wArrayInput">Weights (w):</label>
    <input type="text"
       id="wArrayInput"
       placeholder="e.g. 10,20,30"
       style="width:180px; margin: 0 8px;">

    <button id="createItemsBtn">Create items</button>
  </div>

  <div id="buttons">
    <!-- ‚óÄÔ∏è Move Item-size & Capacity here, before the main controls ‚ñ∂Ô∏è -->
    <label for="itemSizeInput">Item size:</label>
    <input type="number"
           id="itemSizeInput"
           min="1"
           max="20"
           placeholder="n"
           style="width: 50px;">
    <button id="randomItemBtn">Random items</button>

    <label for="capacityInput" style="margin-left:16px;">W (Capacity):</label>
    <input type="number"
           id="capacityInput"
           min="0"
           placeholder="W"
           style="width: 50px;">
    <button id="setWeightBtn">Set weight</button>
    <button id="prevBtn" onclick="prevStep()" disabled>Previous</button>
    <button id="nextBtn" onclick="nextStep()" disabled>Next</button>
    <button id="playBtn">Play</button>
    <label for="speed">Speed:</label>
    <select id="speed">
      <option value="1">1√ó</option>
      <option value="2">2√ó</option>
      <option value="4">4√ó</option>
    </select>

<!-- Force legend to appear on a new line -->
<div style="clear: both; height: 10px;"></div>
<div class="legend">
  <span class="legend-box v"></span><span class="legend-label">v (Values)</span>
  <span class="legend-box w"></span><span class="legend-label">w (Weights)</span>
  <span class="legend-box p"></span><span class="legend-label">p (Ratios)</span>
  <span class="legend-box i"></span><span class="legend-label">i (Indices)</span>
  <span class="legend-box s"></span><span class="legend-label">s (Solutions)</span>
</div>
  <div id="commentary"></div>

  <div class="array-container" id="v-array"></div>
  <!-- <div><strong>s (Solutions):</strong></div>
  <div class="array-container" id="s-array"></div> -->
  <div style="margin-top:10px"><strong>W (Capacity) :</strong> <span id="capacity"></span></div>
  <!-- solutionContainer starts hidden -->
  <div id="solutionContainer" style="margin-top:10px; display:none;">
  <strong>Solution :</strong> <span id="solution">0.000</span>
  </div>

  <script>
    // Initial data
    const v = [23, 87, 14, 65, 42, 99, 31, 56, 77, 12];
    const w = [24, 51, 19, 83, 37, 46, 10, 92, 28, 60];
    let W = 50;                          // capacity
    document.getElementById('capacity').textContent = W;

    // Arrays to track (we‚Äôll create them inside buildSteps)
    let p =[];
    let s = [];

    // Steps and control variables
    let steps = [];
    let current = 0;
    let playing = false;
    let intervalId = null;
    let solutionShown = false;

    // --- NEW CONTROLS SETUP ---
  const itemSizeInput    = document.getElementById('itemSizeInput');
   const randomItemBtn    = document.getElementById('randomItemBtn');
   const wCountInput      = document.getElementById('wCountInput');
   const vCountInput      = document.getElementById('vCountInput');
   const createItemsBtn   = document.getElementById('createItemsBtn');
   const capacityInput    = document.getElementById('capacityInput');
   const setWeightBtn     = document.getElementById('setWeightBtn');


   function recordStep(description) {
      steps.push({
        v: v.slice(),
        w: w.slice(),
        p: p.slice(),
        s: s.slice(),
        W: W,
        description
      });
    }

function resetDemo() {
  steps = [];
  current = 0;
  p = [];
  s = [];
  solutionShown = false;  // üü¢ RESET FLAG HERE
  document.getElementById('solutionContainer').style.display = 'none';
  buildSteps();
  renderStep();
}


   // 1) randomize both v & w to same length:
   randomItemBtn.addEventListener('click', () => {
     const n = parseInt(itemSizeInput.value, 10);
     if (n > 20) {
      alert('Maximum number of items is 20');
      return;
    }
     if (!n || n < 1) { alert('Enter a valid item size'); return; }
     v.length = w.length = n;
     for (let i = 0; i < n; i++) {
       v[i] = Math.floor(Math.random()*100)+1;
       w[i] = Math.floor(Math.random()*100)+1;
     }
     resetDemo();
   });

   // 2) parse comma-separated v & w arrays, enforce equal length
  const vArrayInput = document.getElementById('vArrayInput');
  const wArrayInput = document.getElementById('wArrayInput');
  createItemsBtn.addEventListener('click', () => {
    const vText = vArrayInput.value.trim();
    const wText = wArrayInput.value.trim();
    if (!vText || !wText) {
      alert('Please enter both v and w arrays.');
      return;
    }
    const vArr = vText.split(',').map(x => parseFloat(x.trim()));
    const wArr = wText.split(',').map(x => parseFloat(x.trim()));
    if (vArr.length > 20) {
      alert('Maximum number of items is 20');
      return;
    }
    if (vArr.some(isNaN) || wArr.some(isNaN)) {
      alert('All entries must be valid numbers.');
      return;
    }
    if (vArr.length !== wArr.length) {
      alert('v and w must have the same number of elements.');
      return;
    }
    // commit to your demo arrays:
    v.length = w.length = vArr.length;
    for (let i = 0; i < vArr.length; i++) {
      v[i] = vArr[i];
      w[i] = wArr[i];
    }
    resetDemo();
  });

   // 3) set capacity W:
   setWeightBtn.addEventListener('click', () => {
     const newW = parseInt(capacityInput.value, 10);
     if (isNaN(newW) || newW < 0) { alert('Enter a valid W'); return; }
     W = newW;
     document.getElementById('capacity').textContent = W;
     resetDemo();
   });

    // Utility to record a step
    function recordStep(description, pointers = {}) {
      steps.push({
        v: v.slice(),
        w: w.slice(),
        p: p.slice(),
        s: s.slice(),
        W: W,
        description,
        pointers
      });
    }

    // Build steps following provided algorithm logic
    function buildSteps() {
      recordStep('');
      //recordStep('');
      // 1) Create ratio array p
      p = Array.from({ length: v.length }, (_, i) => ({ value: 0, index: i }));
      recordStep('Creating p (ratio) and i (indices) array.', { pIdx: 0 });

for (let i = 0; i < v.length; i++) {
  const ratio = v[i] / w[i];
  const displayRatio = Number(ratio.toFixed(3));
  p[i] = { value: ratio, index: i };
  recordStep(
    `p[${i}] = v[${i}]/w[${i}] = ${displayRatio}`,
    { pIdx: i }
  );
}
recordStep('Finished computing ratios');



       // ‚îÄ‚îÄ Sort values, weights & ratios together ‚îÄ‚îÄ
       recordStep('Sorting p in descending order, with corresponding i values reordered accordingly using an O(n log‚ÄØn) algorithm.');
       p.sort((a, b) => b.value - a.value);
       // 4) animate the now-sorted bars
      recordStep('sorted', { animate: true });

      // 2) Create solution array s
      s = new Array(v.length).fill(0);
      recordStep('Created solution array s');

      // Greedy fill
      recordStep('Finding Solution: while W > 0');
      let idx = 0;
      let totalSolution = 0;
        while (W > 0 && idx < v.length) {
        // pre-compute everything
        const { value, index } = p[idx];
        const weightTaken = Math.min(W, w[index]);
        const prevW = W;
        const valueTaken = weightTaken * value;
        s[index] = valueTaken;
        const prevSol = totalSolution;
        totalSolution += valueTaken;
        W -= weightTaken;


        // 3b) single combined recordStep with pointer on s[idx]
        recordStep(
        `weightTaken = min(w[${index}], W) = (${w[index]}, ${prevW}) = ${weightTaken}; ` +
        `s[${index}] = ${weightTaken} √ó ${value.toFixed(3)} = ${valueTaken.toFixed(3)};\n` +
        `solution = ${prevSol.toFixed(3)} + ${valueTaken.toFixed(3)} = ${totalSolution.toFixed(3)};  ` +
        `W = ${prevW} - ${weightTaken} = ${W};\n`,
        { sIdx: index }
      );
        idx++;
      }

      // Final answer
      recordStep(
      `Demo is finished.`
    );
    }

    // Rendering functions
    function renderArray(arrayId, data, highlights = {}, pointerIndex = null) {
      const container = document.getElementById(arrayId);
      container.innerHTML = '';
      data.forEach((val, i) => {
        const wrapper = document.createElement('div');
        wrapper.classList.add('element-wrapper');
              // ‚îÄ‚îÄ add pointer if this is the current index ‚îÄ‚îÄ
                if (pointerIndex === i) {
          const ptr = document.createElement('div');
          ptr.classList.add('pointer');
          // separate arrow and label for independent sizing
          ptr.innerHTML =
            '<span class="pointer-arrow">‚Üë</span><br>' +
            '<span class="pointer-label">i</span>';
          wrapper.appendChild(ptr);
        }
        const elem = document.createElement('div');
        elem.classList.add('element');
        // if (arr.pointerKey && pointers[arr.pointerKey] === i) {
        //   elem.classList.add('highlight');
        // }
           // give each array its color
        if      (arrayId === 'v-array') elem.classList.add('v-element');
        else if (arrayId === 'w-array') elem.classList.add('w-element');
        else if (arrayId === 'p-array') elem.classList.add('p-element');
        else if (arrayId === 's-array') elem.classList.add('s-element');
        
 if (arrayId === 'p-array') {
  wrapper.innerHTML = `
    <div class="pointer">
      <span class="pointer-arrow">‚Üì</span><br>
    </div>
    <div class="element p-element">
      ${val.value.toFixed(2).replace(/\.?0+$/, '')}
    </div>
  `;
  if (highlights[i]) wrapper.querySelector('.element').classList.add(highlights[i]);
  container.appendChild(wrapper);
  return;
}

 if (arrayId === 's-array') {
          elem.textContent = val.toFixed(2).replace(/\.?0+$/, '');
        } else {
          elem.textContent = val;
        }

        if (highlights[i]) elem.classList.add(highlights[i]);
        const label = document.createElement('div');
        label.classList.add('index-label');
        label.textContent = i;
        wrapper.appendChild(elem);
        wrapper.appendChild(label);
        container.appendChild(wrapper);
      });
    }


function renderCombinedTable(v, w, p, s, pointers, description) {
  const container = document.getElementById('v-array');
  container.innerHTML = '';
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.alignItems = 'flex-start'; // ‚Üê üî• THIS is the fix


  // Render top index row (no boxes)
  const indexRow = document.createElement('div');
  indexRow.classList.add('array-container');
  indexRow.style.marginBottom = '4px';

  const emptyLabel = document.createElement('div');
  emptyLabel.style.width = '120px';
  emptyLabel.style.marginRight = '8px';
  indexRow.appendChild(emptyLabel);

  const maxLen = Math.max(v.length, w.length, p.length, s.length);
  for (let i = 0; i < maxLen; i++) {
    const index = document.createElement('div');
    index.textContent = i;
    index.style.width = '40px';
    index.style.textAlign = 'center';
    index.style.fontSize = '0.8em';
    index.style.color = '#333';
    index.style.marginRight = '8px';
    indexRow.appendChild(index);
  }
  container.appendChild(indexRow);


  const arrays = [
    { id: 'v', label: 'v (Values):', data: v, className: 'v-element', pointerKey: 'vIdx' },
    { id: 'w', label: 'w (Weights):', data: w, className: 'w-element', pointerKey: 'wIdx' }
  ];

  // Only show p & i arrays if we are beyond step 0
  if (current > 0) {
    arrays.push(
      { id: 'p', label: 'p (Ratios):', data: p, className: 'p-element', pointerKey: 'pIdx' },
      { id: 'i', label: 'i (Indices):', data: p.map(r => r?.index ?? '?'), className: 'i-element', pointerKey: null }
    );
  }

// ‚úÖ Only include `s` after the step explicitly creates it
if (current > steps.findIndex(step => step.description.includes('Created solution array s'))) {
  arrays.push({
    id: 's',
    label: 's (Solutions):',
    data: s,
    className: 's-element',
    pointerKey: 'sIdx'
  });
}

    arrays.forEach(arr => {
    const rowContainer = document.createElement('div');
    rowContainer.classList.add('array-container');
    rowContainer.style.marginBottom = '8px';

    const label = document.createElement('div');
    label.textContent = arr.label;
    label.style.width = '120px';
    label.style.fontWeight = 'bold';
    label.style.marginRight = '8px';
    rowContainer.appendChild(label);

    arr.data.forEach((val, i) => {
      const wrapper = document.createElement('div');
      wrapper.classList.add('element-wrapper');

    const elem = document.createElement('div');
    elem.classList.add('element');  // üõ†Ô∏è FIX: restore missing element style
    if (arr.pointerKey && pointers[arr.pointerKey] === i) {
    elem.classList.add('highlight');
  }
    if (arr.className) elem.classList.add(arr.className);  // keep per-array color

 if (arr.id === 'p') {
  const displayVal = typeof val.value === 'number' ? val.value.toFixed(2).replace(/\.?0+$/, '') : '?';
  elem.textContent = displayVal;
}

else if (arr.id === 's') {
    elem.textContent = parseFloat(val).toFixed(2).replace(/\.?0+$/, '');
  } else {
    elem.textContent = val;
  }


    wrapper.appendChild(elem);


    // Add index label underneath for s row only
    // if (arr.id === 's') {
    //   const label = document.createElement('div');
    //   label.classList.add('index-label');
    //   label.textContent = i;
    //   wrapper.appendChild(label);
    // }

      rowContainer.appendChild(wrapper);
    });

    container.appendChild(rowContainer);
  });
}

    function renderStep() {
  const step = steps[current];
  renderCombinedTable(step.v, step.w, step.p, step.s, step.pointers, step.description);

  //renderArray('s-array', step.s, step.s.map(v=>v>0?'final':null), step.pointers.sIdx);
  document.getElementById('capacity').textContent = step.W;

  // once we hit the ‚ÄúFinding Solution‚Äù step, show & update the solution display
  const solContainer = document.getElementById('solutionContainer');
  if (!solutionShown && (step.description.includes('Finding Solution') || step.description.includes('solution ='))) {
  document.getElementById('solutionContainer').style.display = '';
  solutionShown = true;
}


  // always update the running total from s[]
  const totalSol = step.s.reduce((sum, x) => sum + x, 0);
  document.getElementById('solution').textContent = totalSol.toFixed(3);

  // replace newlines with <br> so they show up on separate lines
  document.getElementById('commentary').innerHTML =
  step.description.replace(/\n/g, '<br>');
  document.getElementById('prevBtn').disabled = !current;
  document.getElementById('nextBtn').disabled = current === steps.length - 1;

  // ‚Üê‚Äî NEW: if this step has animate:true, pop all three arrays
  if (step.pointers.animate) {
  const arrayLabels = {
    p: 'p (Ratios):',
    i: 'i (Indices):'
  };

  Object.keys(arrayLabels).forEach(id => {
    const labelText = arrayLabels[id];

    const row = Array.from(document.querySelectorAll('#v-array .array-container'))
      .find(row => row.firstChild?.textContent?.trim() === labelText);

    if (!row) return;

    row.querySelectorAll('.element-wrapper').forEach(wr => {
      wr.classList.remove('moved');
      void wr.offsetWidth;
      wr.classList.add('moved');
      wr.addEventListener(
        'animationend',
        () => wr.classList.remove('moved'),
        { once: true }
      );
    });
  });
}

}

    function nextStep() {
      if (current < steps.length - 1) current++;
      renderStep();
      if (current === steps.length - 1) stopPlay();
    }

    function prevStep() {
      if (current > 0) current--;
      renderStep();
    }


    function updateAnimDuration() {
  const speed = parseInt(document.getElementById('speed').value, 10) || 1;
  // base 500ms at 1√ó, scales down as you crank the speed up
  document.documentElement.style.setProperty(
    '--sort-anim-duration',
    `${500 / speed}ms`
  );
}

// call once and on every speed change:
document.getElementById('speed').addEventListener('change', updateAnimDuration);
updateAnimDuration();


   function play() {
  if (playing) return;
  playing = true;
  document.getElementById('playBtn').textContent = 'Pause';    // ‚Üê add this
  const speed = parseInt(document.getElementById('speed').value, 10);
  intervalId = setInterval(() => {
    if (current < steps.length - 1) {
      current++;
      renderStep();
    } else {
      stopPlay();
    }
  }, 1000 / speed);
}

function stopPlay() {
  playing = false;
  clearInterval(intervalId);
  document.getElementById('playBtn').textContent = 'Play';     // ‚Üê add this
}

    document.getElementById('playBtn').addEventListener('click', () => {
      if (playing) stopPlay(); else play();
    });

    // Initialize demo
    buildSteps();
    renderStep();
  </script>
</body>
</html>
