<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DFS Demo</title>
  <script src="/Algorithms/scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/demo.css">
  <style>
    :root {
      --node-stroke: #444;
      --edge-stroke: black;
      --edge-highlight-stack: red;
      --edge-highlight-current: orange;
      --edge-highlight-current-under: gold; /* Highlight color for current edge (underlay) */
      --tree-edge: blue;
      --non-tree-edge: lightblue;
      --font-sans: sans-serif;
    }
    .graphNode circle {
      stroke: var(--node-stroke);
      stroke-width: 1px;
    }
    .graphNode.blue circle   { fill: lightblue; }
    .graphNode.orange circle { fill: orange; }
    .graphNode.green circle  { fill: lightgreen; }
    .graphNode.current circle { stroke-width: 2.5px; }
    .graphNode text {
      text-anchor: middle;
      dominant-baseline: middle;
      fill: #202020;
    }
    .graphNode .label { font-size: 20px; }
    .graphNode .times { font-size: 14px; }
    #svg line { stroke: var(--edge-stroke); stroke-width: 3px; }
    #linkLayer line.active-stack-edge { stroke: var(--edge-highlight-stack); stroke-width: 4px; }
    #linkLayer line.active-current-edge-under { stroke: var(--edge-highlight-current-under); stroke-width: 10px; opacity: 0.7; }
    #linkLayer line.active-current-edge { stroke: var(--edge-highlight-current); stroke-width: 4px; }
    #linkLayer line.tree-edge { stroke: var(--tree-edge); stroke-width: 4px; }
    #linkLayer line.non-tree-edge { stroke: var(--non-tree-edge); stroke-width: 3px; }
    /*#linkLayer line.default-edge {
      display: none; 
   }*/
    #state-table { width: 100%; border-collapse: collapse; font-family: var(--font-sans); }
    #state-table th, #state-table td { border: 1px solid #ddd; padding: 0.5em; text-align: center; }
    #state-table th { background: #f0f0f0; }
    .highlighted-row { outline: 2px solid #000; }
    .color-cell.blue   { background: lightblue;  }
    .color-cell.orange { background: orange;     }
    .color-cell.green  { background: lightgreen; }
    #structures {
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* Align children to the left */
      gap: 8px;
      margin: 10px 0;
      font-family: var(--font-sans);
    }

    #stack-container {
      display: flex;
      align-items: flex-start; /* Align items to the top */
      column-gap: 8px;
      height: auto; /* Adjust height to fit content */
      justify-content: flex-start; /* Left-align the stack */
      width: 100%; /* Ensure it spans the full width */
    }

    #stack {
      display: inline-flex;
      align-items: center;
      overflow-x: auto;
      white-space: nowrap;
      max-width: 750px;
    }
    .queueNode { margin: 0 4px; flex: 0 0 auto; background: none; border: none; }
    .queue-arrow { margin: 0 4px; flex: 0 0 auto; }
    .panel { display:flex; flex-direction:column; align-items:center; }
    .graph-panel { flex:1 1 auto; }
    .table-panel { flex:0 0 250px; margin-left:10px; }
    #svg { width:100%; height:auto; max-height:65vh; background-color:#fff !important; }
    #demo-wrapper { min-height:800px; display:flex; flex-direction:column; }
    .table-panel .legend { display:flex; flex-direction:column; align-items:flex-start; gap:0.5em; font-family:var(--font-sans); margin-top:1em; }
    .table-panel .legend-item { display:flex; align-items:center; gap:0.5em; }
    .legend-box { width:1em; height:1em; display:inline-block; }
    .legend-line { width:2em; height:0.4em; display:inline-block; vertical-align:middle; border-radius: 4px; }
    .legend-line.active-stack { background: var(--edge-highlight-stack); }
    .legend-line.active-current-under { background: var(--edge-highlight-current-under); border: 2px solid var(--edge-highlight-current-under); }
    .legend-line.active-current { background: var(--edge-highlight-current); }
    .legend-line.tree { background: var(--tree-edge); }
    .legend-line.nontree { background: var(--non-tree-edge); }
  </style>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
</head>
<body class="no-tooltips">
<div id="demo-wrapper">
  <h2>Depth-First Search Demo</h2>
  <div id="controls">
    <label>Graph Size: <input id="graphSize" type="number" min="1" max="15" value="8" style="width:4em"></label>
    <button id="generateBtn">Generate Graph</button>
    <br>
    <button id="prevBtn" disabled>Previous</button>
    <button id="nextBtn" disabled>Next</button>
    <button id="playBtn">Play</button>
    <label for="speedSelect">Speed:</label>
    <select id="speedSelect">
      <option value="1">1×</option>
      <option value="2">2×</option>
      <option value="4">4×</option>
    </select>
  </div>
  <div id="main-container" style="display:flex; align-items:flex-start; gap:20px;">
    <div class="panel graph-panel">
      <h3>Graph</h3>
      <p class="drag-note">Drag vertices to reposition them.</p>
      <svg id="svg" viewBox="0 0 800 800" preserveAspectRatio="xMidYMid meet">
        <g id="linkLayer"></g>
        <g id="nodeLayer"></g>
      </svg>
    </div>
    <div class="panel table-panel">
      <h3>Vertex Table</h3>
      <table id="state-table">
        <thead>
          <tr>
            <th>v</th>
            <th>discover</th>
            <th>final</th>
            <th>parent</th>
            <th>color</th>
          </tr>
        </thead>
        <tbody id="state-table-body"></tbody>
      </table>
      <div class="legend">
        <strong>Legend</strong>
        <div class="legend-item"><span class="legend-box blue"></span><span class="legend-label">Unvisited</span></div>
        <div class="legend-item"><span class="legend-box orange"></span><span class="legend-label">Visiting</span></div>
        <div class="legend-item"><span class="legend-box green"></span><span class="legend-label">Finished</span></div>
        <div class="legend-item">
          <span class="legend-line active-stack"></span>
          <span class="legend-label">Active Edge in Call Stack (<span style="color:red">Red</span>)</span>
        </div>
        <div class="legend-item">
          <span class="legend-line active-current-under"></span>
          <span class="legend-label">Current Edge Being Explored (<span style="color:gold">Yellow, thick</span>)</span>
        </div>
        <div class="legend-item">
          <span class="legend-line tree"></span>
          <span class="legend-label">Tree Edge (<span style="color:blue">Blue</span>)</span>
        </div>
        <div class="legend-item">
          <span class="legend-line nontree"></span>
          <span class="legend-label">Non-tree Edge (<span style="color:lightblue">Light Blue</span>)</span>
        </div>
      </div>
    </div>
  </div>
  <div id="structures">
    <div id="stack-container"><strong>Stack:</strong> <span id="stack"></span></div>
    <div id="commentary"></div>
  </div>
</div>
<script>
const width=800,height=800,radius=40,margin=10;
const circleR=width/2-radius-margin;
const centerX=width/2,centerY=height/2;
let adjList,steps,stepIndex=0,nodePositions=[];
function buildDfsSteps(adj){
  const events=[];const n=adj.length;
  const color=Array(n).fill('blue');
  const disc=Array(n).fill(null);
  const fin=Array(n).fill(null);
  const parent=Array(n).fill(null);
  const stack=[];const activeEdges=[];const treeEdges=[];const backEdges=[];let time=0;
  function snapshot(desc){events.push({desc,color:color.slice(),disc:disc.slice(),fin:fin.slice(),parent:parent.slice(),stack:stack.slice(),activeEdges:activeEdges.slice(),treeEdges:treeEdges.slice(),backEdges:backEdges.slice(),current:stack[stack.length-1]??null});}
  function dfsVisit(u,incoming){
    color[u]='orange';disc[u]=++time;stack.push(u);if(incoming)activeEdges.push(incoming);
    snapshot(incoming?`Tree edge ${incoming.from}-${incoming.to} and discover ${u}`:`Discover ${u}`);
    for(const v of adj[u]){
      if(v===parent[u]) continue;const edge={from:u,to:v};
      if(color[v]==='blue'){
        parent[v]=u;
        dfsVisit(v,edge);
        const idx=activeEdges.findIndex(e=>e.from===edge.from&&e.to===edge.to);
        if(idx>=0)activeEdges.splice(idx,1);
        treeEdges.push(edge);
        snapshot(`Backtrack from ${v} to ${u}`);
      }else{
        const key=`${Math.min(u,v)}-${Math.max(u,v)}`;
        if(!backEdges.some(e=>`${Math.min(e.from,e.to)}-${Math.max(e.from,e.to)}`===key)) backEdges.push(edge);
        snapshot(`Non-tree edge ${u}-${v}`);
      }
    }
    stack.pop();color[u]='green';fin[u]=++time;snapshot(`Finish ${u}`);
  }
  snapshot('Initialize DFS');
  for(let i=0;i<n;i++){if(color[i]==='blue')dfsVisit(i,null);}
  snapshot('DFS complete');
  return events;
}
function generateGraph(n){const adj=Array.from({length:n},()=>[]);for(let i=0;i<n-1;i++){adj[i].push(i+1);adj[i+1].push(i);}for(let i=0;i<n;i++){for(let j=i+2;j<n;j++){if(Math.random()<0.3){adj[i].push(j);adj[j].push(i);}}}return adj;}
function layoutGraph(adj){return adj.map((_,i)=>{const t=2*Math.PI*i/adj.length-Math.PI/2;return{x:centerX+circleR*Math.cos(t),y:centerY+circleR*Math.sin(t)};});}
function renderStep(){const ev=steps[stepIndex];document.getElementById('commentary').textContent=ev.desc;renderGraph(ev);renderStack(ev);renderTable(ev);updateButtons();}
function renderGraph(ev) {
  const svgNS = 'http://www.w3.org/2000/svg';
  const linkLayer = document.getElementById('linkLayer');
  const nodeLayer = document.getElementById('nodeLayer');
  linkLayer.innerHTML = '';
  nodeLayer.innerHTML = '';

  // Draw base edges
  adjList.forEach((nbrs, i) => {
    nbrs.forEach(j => {
      if (i < j) {
        const p1 = nodePositions[i], p2 = nodePositions[j];
        const L = document.createElementNS(svgNS, 'line');
        L.setAttribute('id', `edge-${i}-${j}`);
        L.setAttribute('x1', p1.x);
        L.setAttribute('y1', p1.y);
        L.setAttribute('x2', p2.x);
        L.setAttribute('y2', p2.y);
        L.classList.add('default-edge');
        linkLayer.appendChild(L);
      }
    });
  });

  // Highlight the current edge being explored (yellow, thick, underlay)
  if (ev.activeEdges.length > 0 && ev.current !== null) {
    // Find the edge where from == ev.current
    const currentEdge = ev.activeEdges.find(e => e.from === ev.current);
    if (currentEdge) {
      const p1 = nodePositions[currentEdge.from], p2 = nodePositions[currentEdge.to];
      const L = document.createElementNS(svgNS, 'line');
      L.setAttribute('x1', p1.x);
      L.setAttribute('y1', p1.y);
      L.setAttribute('x2', p2.x);
      L.setAttribute('y2', p2.y);
      L.classList.add('active-current-edge-under');
      linkLayer.appendChild(L);
    }
  }

  // Tree edges (blue)
  ev.treeEdges.forEach(({ from, to }) => {
    const p1 = nodePositions[from], p2 = nodePositions[to];
    const L = document.createElementNS(svgNS, 'line');
    L.setAttribute('x1', p1.x);
    L.setAttribute('y1', p1.y);
    L.setAttribute('x2', p2.x);
    L.setAttribute('y2', p2.y);
    L.classList.add('tree-edge');
    linkLayer.appendChild(L);
  });

  // Non-tree edges (light blue)
  ev.backEdges.forEach(({ from, to }) => {
    const p1 = nodePositions[from], p2 = nodePositions[to];
    const L = document.createElementNS(svgNS, 'line');
    L.setAttribute('x1', p1.x);
    L.setAttribute('y1', p1.y);
    L.setAttribute('x2', p2.x);
    L.setAttribute('y2', p2.y);
    L.classList.add('non-tree-edge');
    linkLayer.appendChild(L);
  });

  // Active edges (stack/red and current/orange)
  ev.activeEdges.forEach(({ from, to }) => {
    const p1 = nodePositions[from], p2 = nodePositions[to];
    const L = document.createElementNS(svgNS, 'line');
    L.setAttribute('x1', p1.x);
    L.setAttribute('y1', p1.y);
    L.setAttribute('x2', p2.x);
    L.setAttribute('y2', p2.y);
    if (from === ev.current) {
      L.classList.add('active-current-edge');
    } else {
      L.classList.add('active-stack-edge');
    }
    linkLayer.appendChild(L);
  });

  ev.color.forEach((col, i) => {
    const pos = nodePositions[i];
    const g = document.createElementNS(svgNS, 'g');
    g.dataset.id = i;
    g.classList.add('graphNode', col);
    if (ev.current === i) g.classList.add('current');
    const circ = document.createElementNS(svgNS, 'circle');
    circ.setAttribute('cx', pos.x);
    circ.setAttribute('cy', pos.y);
    circ.setAttribute('r', radius);
    g.appendChild(circ);
    const label = document.createElementNS(svgNS, 'text');
    label.classList.add('label');
    label.setAttribute('x', pos.x);
    label.setAttribute('y', pos.y - 10);
    label.textContent = i;
    g.appendChild(label);
    const times = document.createElementNS(svgNS, 'text');
    times.classList.add('times');
    times.setAttribute('x', pos.x);
    times.setAttribute('y', pos.y + 14);
    const d = ev.disc[i] ?? '';
    const f = ev.fin[i] ?? '';
    times.textContent = d || f ? `${d}/${f}` : '';
    g.appendChild(times);
    nodeLayer.appendChild(g);
    addDragHandlers(g, i);
  });
}
function renderStack(ev){const stackEl=document.getElementById('stack');stackEl.innerHTML='';ev.stack.forEach((node,i)=>{stackEl.insertAdjacentHTML('beforeend',`<svg class="queueNode" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><circle cx="20" cy="20" r="18" fill="lightblue" stroke="#444" stroke-width="2"/><text x="20" y="24" text-anchor="middle" dominant-baseline="middle" font-size="16">${node}</text></svg>`);if(i<ev.stack.length-1){stackEl.insertAdjacentHTML('beforeend','<span class="queue-arrow">→</span>');}});} 
function renderTable(ev){const tbody=document.getElementById('state-table-body');tbody.innerHTML='';ev.color.forEach((col,i)=>{const tr=document.createElement('tr');if(ev.updatedVertex===i)tr.classList.add('highlighted-row');tr.innerHTML=`<td>${i}</td><td>${ev.disc[i]??''}</td><td>${ev.fin[i]??''}</td><td>${ev.parent[i]===null?'NIL':ev.parent[i]}</td><td class="color-cell ${col}">${col}</td>`;tbody.appendChild(tr);});}
function updateNode(i){const g=document.querySelector(`g.graphNode[data-id='${i}']`);if(!g) return;const pos=nodePositions[i];g.querySelector('circle').setAttribute('cx',pos.x);g.querySelector('circle').setAttribute('cy',pos.y);g.querySelector('text.label').setAttribute('x',pos.x);g.querySelector('text.label').setAttribute('y',pos.y-10);g.querySelector('text.times').setAttribute('x',pos.x);g.querySelector('text.times').setAttribute('y',pos.y+14);}
function updateEdges(i){adjList[i].forEach(j=>{const id=`edge-${Math.min(i,j)}-${Math.max(i,j)}`;const p1=nodePositions[Math.min(i,j)],p2=nodePositions[Math.max(i,j)];const base=document.getElementById(id);if(base){base.setAttribute('x1',p1.x);base.setAttribute('y1',p1.y);base.setAttribute('x2',p2.x);base.setAttribute('y2',p2.y);}['tree','back','active'].forEach(type=>{document.querySelectorAll(`#linkLayer line[data-${type}='${id}']`).forEach(line=>{line.setAttribute('x1',nodePositions[i].x);line.setAttribute('y1',nodePositions[i].y);line.setAttribute('x2',nodePositions[j].x);line.setAttribute('y2',nodePositions[j].y);});});});}

function addDragHandlers(g,i){const svgEl=document.getElementById('svg');g.addEventListener('mousedown',e=>{e.preventDefault();const pt=svgEl.createSVGPoint();const ctmInv=svgEl.getScreenCTM().inverse();pt.x=e.clientX;pt.y=e.clientY;const start=pt.matrixTransform(ctmInv);const offsetX=start.x-nodePositions[i].x;const offsetY=start.y-nodePositions[i].y;function onMove(e2){pt.x=e2.clientX;pt.y=e2.clientY;const p=pt.matrixTransform(ctmInv);nodePositions[i].x=p.x-offsetX;nodePositions[i].y=p.y-offsetY;updateNode(i);updateEdges(i);}function onUp(){window.removeEventListener('mousemove',onMove);window.removeEventListener('mouseup',onUp);}window.addEventListener('mousemove',onMove);window.addEventListener('mouseup',onUp);});}
function clampAllNodes(){const svgEl=document.getElementById('svg');const pt=svgEl.createSVGPoint();const ctmInv=svgEl.getScreenCTM().inverse();const rect=svgEl.getBoundingClientRect();const tl=new DOMPoint(rect.left+radius,rect.top+radius).matrixTransform(ctmInv);const br=new DOMPoint(rect.right-radius,rect.bottom-radius).matrixTransform(ctmInv);nodePositions.forEach((pos,i)=>{pos.x=Math.max(tl.x,Math.min(br.x,pos.x));pos.y=Math.max(tl.y,Math.min(br.y,pos.y));updateNode(i);updateEdges(i);});}
window.addEventListener('resize',clampAllNodes);
function nextStep(){if(stepIndex<steps.length-1){stepIndex++;renderStep();}}
function prevStep(){if(stepIndex>0){stepIndex--;renderStep();}}
function updateButtons(){document.getElementById('prevBtn').disabled=stepIndex===0;document.getElementById('nextBtn').disabled=stepIndex===steps.length-1;}
function initializeDemo(){adjList=generateGraph(8);nodePositions=layoutGraph(adjList);steps=buildDfsSteps(adjList);stepIndex=0;document.getElementById('prevBtn').addEventListener('click',prevStep);document.getElementById('nextBtn').addEventListener('click',nextStep);renderStep();}
document.getElementById('generateBtn').addEventListener('click',()=>{const rawSize=parseInt(document.getElementById('graphSize').value,10)||8;const n=Math.min(15,Math.max(1,rawSize));adjList=generateGraph(n);nodePositions=layoutGraph(adjList);steps=buildDfsSteps(adjList);stepIndex=0;renderStep();});

let timer=null;const playBtn=document.getElementById('playBtn');const speedSelect=document.getElementById('speedSelect');playBtn.addEventListener('click',()=>{if(timer){clearInterval(timer);timer=null;playBtn.textContent='Play';}else{playBtn.textContent='Pause';timer=setInterval(()=>{if(stepIndex<steps.length-1)nextStep();else{clearInterval(timer);playBtn.textContent='Play';}},1000/parseInt(speedSelect.value,10));}});
speedSelect.addEventListener('change',()=>{if(timer){clearInterval(timer);playBtn.textContent='Pause';timer=setInterval(()=>{if(stepIndex<steps.length-1)nextStep();else{clearInterval(timer);playBtn.textContent='Play';}},1000/parseInt(speedSelect.value,10));}});
window.onload=initializeDemo;
</script>
</body>
</html>
