<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Warshall’s Algorithm Demo</title>
  <script src="../../../scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">

  <style>
    /* Minimal demo-specific styles; avoid overriding shared css */
    .demo-content { display: flex; gap: 1em; align-items: flex-start; }
    .graph-panel { flex: 1 1 auto; min-width: 220px; }
    .matrix-panel { flex: 0 0 auto; min-width: 220px; }
    .graph-panel svg {
      background: #fff;
      border: 1px solid #ccc;
      width: 100%;              /* fill available width */
      aspect-ratio: 1 / 1;      /* keep square */
      height: auto;             /* derive from aspect ratio */
      display: block;
    }

    /* Matrix layout and highlighting */
    .matrix-panel { display: flex; flex-direction: column; align-items: center; }
    .matrix-panel .matrix-container { display: grid; gap: 4px; padding: 6px; border-radius: 6px; background: transparent; }
    #matrix-r.matrix-container { position: relative; background: transparent; margin-top: 0.5em; }
    #matrix-r.matrix-container::before {
      content: '';
      position: absolute;
      top:    calc(6px + 36px);
      left:   calc(6px + 36px);
      right:  6px;
      bottom: 6px;
      background: rgba(79, 172, 248, 0.423);
      border-radius: 6px;
      pointer-events: none;
      z-index: 0;
    }
    .matrix-element, .matrix-index { position: relative; z-index: 1; }
    .matrix-element { width: 36px; height: 36px; border: 1px solid #333; display: flex; justify-content: center; align-items: center; font-family: monospace; background: transparent; transition: transform 0.3s, box-shadow 0.3s; font-size: 1.05em; }
    .matrix-element.highlight { box-shadow: 0 0 8px 2px rgba(126,87,194,0.8); }
    .matrix-element { position: relative; z-index: 0; }
    .matrix-element.col-highlight, .matrix-element.row-highlight { background: rgba(251, 242, 208, 0.45); }
    .matrix-element.via-highlight { box-shadow: inset 0 0 0 2px #1f77b4; }
    .matrix-element.highlight { z-index: 2; transform: scale(1.1); box-shadow: 0 0 8px 2px rgba(126, 87, 194, 0.8); background: rgba(126, 87, 194, 0.6); font-weight: bold; }
    .matrix-index { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; font-family: monospace; background: transparent; border: none; pointer-events: none; font-size: 1.0em; }

    /* Comment formatting tokens */
    .comment-row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .comment { margin-top: 0.25em; min-height: 5em; text-align: left; flex: 1; }
    .comment-opt { white-space: nowrap; font-size: 0.95em; }
    /* layout slider removed */
    .t-old { font-weight: 600; }
    .t-new { font-weight: 700; color: #333; }
    .t-result.update { color: #2ecc71; font-weight: 700; }
    .t-result.nochange { color: #ff7f0e; font-weight: 700; }
    .t-left, .t-right { background: rgba(249, 163, 3, 0.18); padding: 0 2px; border-radius: 3px; }
    .t-via { font-style: italic; }

    /* Node role coloring for clarity per step */
    .graphNode.source circle { fill: #2ecc71; }
    .graphNode.target circle { fill: #ff6b6b; }
  </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQ5LVZVFDC');
</script>
</head>
<body>
  <div class="demo-container">
    <h2>Warshall’s Algorithm Demo (Transitive Closure)</h2>

    <!-- Controls -->
    <div class="controls">
        <label>n:
          <input id="dim-input" type="number" min="1" max="10" value="5" style="width:4em;">
        </label>
        <button id="gen-btn">Generate</button>
        <button id="prev-btn" disabled>Previous</button>
        <button id="next-btn" disabled>Next</button>
        <button id="play-btn" disabled>Play</button>
        <label for="speed-select">Speed:
          <select id="speed-select">
            <option value="1">1×</option>
            <option value="2">2×</option>
            <option value="4">4×</option>
            <option value="8">8×</option>
            <option value="16">16×</option>
            <option value="32">32×</option>
          </select>
        </label>
    </div>

<!-- Legend (use shared demo.css classes) -->
<div class="legend">
  <strong class="legend-label">Legend:</strong>
  <div class="legend-items">
    <span class="legend-box" style="background-color: rgba(126,87,194,0.6)"></span> Current Cell
    <span class="legend-box" style="background-color: rgba(251,242,208,0.45)"></span> Row/Column k
    <span class="legend-box" style="background: transparent; border: 2px solid #1f77b4;"></span> Via cells D[i][k], D[k][j]<br>
    <svg viewBox="0 0 12 10" width="15" height="15" aria-hidden="true" style="vertical-align: middle; margin-left: 6px;">
      <defs>
        <marker id="legend-arrowhead-blue" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" refX="3.25" refY="1.5" orient="auto">
          <path d="M0,0 L0,3 L4,1.5 Z" fill="#1f77b4"/>
        </marker>
      </defs>
      <line x1="1" y1="5" x2="11" y2="5" stroke="#1f77b4" stroke-width="2" marker-end="url(#legend-arrowhead-blue)"/>
    </svg> Considered via k (solid = exists)
    <svg viewBox="0 0 12 10" width="15" height="15" aria-hidden="true" style="vertical-align: middle; margin-left: 8px;">
      <defs>
        <marker id="legend-arrowhead-gray" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" refX="3" refY="1.5" orient="auto">
          <path d="M0,0 L0,3 L4,1.5 Z" fill="#9e9e9e"/>
        </marker>
      </defs>
      <line x1="1" y1="5" x2="11" y2="5" stroke="#b0b0b0" stroke-width="2" stroke-dasharray="6 3" marker-end="url(#legend-arrowhead-gray)"/>
    </svg> D[i][j] missing (not added)
    <svg viewBox="0 0 12 10" width="15" height="15" aria-hidden="true" style="vertical-align: middle; margin-left: 8px;">
      <defs>
        <marker id="legend-arrowhead-orange" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" refX="3.25" refY="1.5" orient="auto">
          <path d="M0,0 L0,3 L4,1.5 Z" fill="#f28e2b"/>
        </marker>
      </defs>
      <line x1="1" y1="5" x2="11" y2="5" stroke="#f28e2b" stroke-width="2" marker-end="url(#legend-arrowhead-orange)"/>
    </svg> D[i][j] exists
    <svg viewBox="0 0 12 10" width="15" height="15" aria-hidden="true" style="vertical-align: middle; margin-left: 8px;">
      <line x1="1" y1="5" x2="11" y2="5" stroke="#f28e2b" stroke-width="2" stroke-dasharray="6 3" marker-end="url(#legend-arrowhead-orange)"/>
    </svg> D[i][j] added now
	<svg viewBox="0 0 12 4" width="24" height="4"
     aria-hidden="true" style="vertical-align:middle; margin-left:8px;">
  <line x1="0" y1="1" x2="12" y2="1" stroke="#333" stroke-width="2"/>
</svg>
    </svg> Original Edge
   <svg viewBox="0 0 12 4" width="24" height="4"
     aria-hidden="true" style="vertical-align:middle; margin-left:8px;">
      <line x1="0" y1="1" x2="12" y2="1" stroke="#999" stroke-width="1"/>
    </svg>  Derived Edge
  </div>
</div>

    <!-- Comment Row with option on the right -->
    <div class="comment-row">
      <div id="comment" class="comment">Initialize to begin...</div>
      <label class="comment-opt">
        <input id="only-original" type="checkbox"> Show only original edges
      </label>
    </div>
  </div>

    <!-- Demo Panels -->
    <div class="demo-content">
      <!-- Graph View -->
      <div class="graph-panel">
      <h3>Graph</h3>
      <svg id="graph-svg" width="560">
       <defs>
  <marker id="arrow" 
          markerWidth="10" 
          markerHeight="10" 
          refX="8" 
          refY="3" 
          orient="auto">
    <path d="M0,0 L0,6 L9,3 z" fill="#888"/>
  </marker>

  <marker id="arrow-highlight"
          markerUnits="strokeWidth"
          markerWidth="4"
          markerHeight="3"
          refX="3.25"
          refY="1.5"
          orient="auto">
    <path d="M0,0 L0,3 L4,1.5 Z" fill="#e74c3c"/>
  </marker>

  <!-- gray arrow head for missing (∞) edges -->
  <marker id="arrow-gray"
          markerUnits="strokeWidth"
          markerWidth="4"
          markerHeight="3"
          refX="3"
          refY="1.5"
          orient="auto">
    <path d="M0,0 L0,3 L4,1.5 Z" fill="#9e9e9e"/>
  </marker>
  <!-- direct edge marker (orange) -->
  <!-- distinct markers for the two considered legs -->
  <marker id="arrow-blue"
          markerUnits="strokeWidth"
          markerWidth="4"
          markerHeight="3"
          refX="3.25"
          refY="1.5"
          orient="auto">
    <path d="M0,0 L0,3 L4,1.5 Z" fill="#1f77b4"/>
  </marker>
  <marker id="arrow-orange"
          markerUnits="strokeWidth"
          markerWidth="4"
          markerHeight="3"
          refX="3.25"
          refY="1.5"
          orient="auto">
    <path d="M0,0 L0,3 L4,1.5 Z" fill="#f28e2b"/>
  </marker>
</defs>

        <!-- everything else will be drawn by JS -->
      </svg>
    </div>


      <!-- DP Matrix View -->
      <div class="matrix-panel">
        <h3>Computing D<sup id="current-k">0</sup></h3>
        <div id="matrix-r" class="matrix-container"></div>
      </div>
    </div>


  <script>
  (function() {
    const NS = 'http://www.w3.org/2000/svg';
    const dimInput   = document.getElementById('dim-input');
    const genBtn     = document.getElementById('gen-btn');
    const prevBtn    = document.getElementById('prev-btn');
    const nextBtn    = document.getElementById('next-btn');
    const playBtn    = document.getElementById('play-btn');
    const speedSelect= document.getElementById('speed-select');
    const graphSvg   = document.getElementById('graph-svg');
    const graphPanel = document.querySelector('.graph-panel');
    const matrixPanel= document.querySelector('.matrix-panel');
    const matR       = document.getElementById('matrix-r');
    const onlyOriginalChk = document.getElementById('only-original');
    let lastGraphSize = { w: 0, h: 0 };
    const commentBox = document.getElementById('comment');
    
    let A = [], edges = [], events = [], ptr = 0, timer = null;
    let playing = false, speed = 1;
    let direction = 'forward';
    let nodePos = []; // draggable node positions
    let dragging = null; // { idx }
    let hasNegCycle = false; // unused for Warshall
    let originalEdgeSet = new Set(); // original adjacency edges for styling/filtering

    // Utilities
    const rand = () => Math.random();

    // clone utility

    function matrixToEdges(M) {
      const ed = [];
      const n = M.length;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i !== j && M[i][j] !== Infinity) {
            ed.push({ from: i, to: j, weight: 1 });
          }
        }
      }
      return ed;
    }

    function baseEdgesFor(adj) {
      let ed = matrixToEdges(adj);
      if (onlyOriginalChk?.checked && originalEdgeSet) {
        ed = ed.filter(e => originalEdgeSet.has(`${e.from}-${e.to}`));
      }
      return ed;
    }

    // Generate random directed graph adjacency matrix + edges with options
    function genRandomGraph(n) {
      const M = Array.from({ length: n }, () => Array(n).fill(Infinity));
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (i === j) M[i][j] = 1; // reflexive closure
          else if (Math.random() < 0.3) M[i][j] = 1; // edge exists
        }
      }
      return { M, ed: matrixToEdges(M) };
    }


    function updateTheme(graphFill, graphStroke, matrixBg, k) {
    document.documentElement.style.setProperty('--graph-fill',    graphFill);
    document.documentElement.style.setProperty('--graph-stroke',  graphStroke);
    document.documentElement.style.setProperty('--matrix-bg',     matrixBg);
    document.getElementById('current-k').textContent = k+1;
  }


  // add this just inside your (function() { … }) wrapper, before rebuild()
  function fmt01(v) { return v === Infinity ? 0 : 1; }


    // Render graph nodes + edges
function renderGraph(adj, edges, highlight = {}) {
  const placedLabels = [];
  // (deprecated arrays retained in earlier versions)
  const labelItems = [];

  const w = graphSvg.clientWidth;
  const h = graphSvg.clientHeight;
  const n = adj.length;

  // 1) clear old elements (keep your <defs> in place)
  graphSvg
    .querySelectorAll(':scope > g, :scope > line, :scope > path, :scope > text')
    .forEach(el => el.remove());

  // Use persistent node positions (draggable); initialize if empty
  if (!nodePos || nodePos.length !== n) nodePos = getNodePositions(n);
  const pos = nodePos;

  // 1) draw phantom ∞-edges (gray dashed) for any missing candidate link
  // ── draw phantom ∞-edges ─────────────────────────────────────────────
if (Array.isArray(highlight.phantomEdges)) {
  const considerSet = new Set(
    (Array.isArray(highlight.considerEdges) ? highlight.considerEdges : [])
      .map(e => `${e.from}-${e.to}`)
  );
  highlight.phantomEdges.forEach(({ from, to }) => {
    if (considerSet.has(`${from}-${to}`)) return;
    // If this phantom is the direct i→j and it's being added now, skip gray phantom
    if (highlight.direct && highlight.updateState === 'update' &&
        highlight.direct.from === from && highlight.direct.to === to) {
      return;
    }
    const p1 = pos[from], p2 = pos[to];
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const L  = Math.hypot(dx, dy);
    const ux = L > 0 ? dx/L : 1;
    const uy = L > 0 ? dy/L : 0;
    const perpX = -uy, perpY = ux;
    const OFFSET   = (9 + 8)/2 + 2;
    const curvature = 30;
    const sx = p1.x + ux*17 + perpX*OFFSET;
    const sy = p1.y + uy*17 + perpY*OFFSET;
    const ex = p2.x - ux*17 + perpX*OFFSET;
    const ey = p2.y - uy*17 + perpY*OFFSET;
    const mx = (p1.x + p2.x)/2 + perpX*curvature;
    const my = (p1.y + p2.y)/2 + perpY*curvature;
    const d  = `M${sx},${sy} Q${mx},${my} ${ex},${ey}`;

    const ph = document.createElementNS(NS,'path');
    ph.setAttribute('d', d);
    ph.setAttribute('fill','none');
    ph.setAttribute('stroke','#b0b0b0');
    ph.setAttribute('stroke-width','3');
    ph.setAttribute('stroke-dasharray','6 3');
    ph.setAttribute('marker-end','url(#arrow-gray)');
    graphSvg.appendChild(ph);

    // no labels in Warshall demo
  });
}


 // ───── Real edges (from current adj) ─────────────────────────────────────
   edges.forEach((e, idx) => {
    // skip drawing the base edge if it's one of the considered legs to avoid dual-color overlays
    const isConsideredNow = Array.isArray(highlight.considerEdges) && highlight.considerEdges.some(pe => pe.from === e.from && pe.to === e.to);
    if (isConsideredNow) return;
    // any leg we’re “considering” goes yellow
    const isConsider = Array.isArray(highlight.considerEdges)
                     && highlight.considerEdges.some(pe =>
                          pe.from === e.from && pe.to === e.to
                        );
    const isPath     = Array.isArray(highlight.pathEdges)
                     && highlight.pathEdges.some(pe =>
                          pe.from === e.from && pe.to === e.to
                        );

												  
    const { x: x1, y: y1 } = pos[e.from];
    const { x: x2, y: y2 } = pos[e.to];
    const dx = x2 - x1, dy = y2 - y1;
    const L  = Math.hypot(dx, dy);
    const ux = L > 0 ? dx / L : 1;
    const uy = L > 0 ? dy / L : 0;
    const perpX = -uy, perpY = ux;

    // compute curve same as in preprocess…
    const DEFAULT_MARKER_W   = 9;
    const HIGHLIGHT_MARKER_W = 4 * 2;
    const OFFSET             = (DEFAULT_MARKER_W + HIGHLIGHT_MARKER_W)/2 + 2;
    const sx = x1 + ux*17 + perpX*OFFSET;
    const sy = y1 + uy*17 + perpY*OFFSET;
    const ex = x2 - ux*17 + perpX*OFFSET;
    const ey = y2 - uy*17 + perpY*OFFSET;
    const curvature = 30;
    const mx = (x1 + x2)/2 + perpX*curvature;
    const my = (y1 + y2)/2 + perpY*curvature;
    const d = `M${sx},${sy} Q${mx},${my} ${ex},${ey}`;

					 
    const path = document.createElementNS(NS,'path');
    path.setAttribute('d', d);
    path.setAttribute('fill', 'none');

    // pick color & marker (original edges darker and 1px wider; derived lighter)
    const isOriginal = (typeof originalEdgeSet !== 'undefined') && originalEdgeSet.has(`${e.from}-${e.to}`);
    let strokeColor = isOriginal ? '#333' : '#999';
    let strokeW = isOriginal ? 2 : 1;
    let markerId = 'arrow';


    path.setAttribute('stroke', strokeColor);
    path.setAttribute('stroke-width', strokeW);
    path.setAttribute('marker-end', `url(#${markerId})`);

    graphSvg.appendChild(path);

										 

    // draw the weight label using precomputed anchors when available
    // no base weight labels for Warshall


  });


  // 4) draw considered edges (same color) including loops
  if (Array.isArray(highlight.considerEdges)) {
    highlight.considerEdges.forEach((ce) => {
      const { from, to } = ce;
      const color = '#1f77b4';
      const markerId = 'arrow-blue';
      const isDirect = !!(highlight.direct && highlight.direct.from === from && highlight.direct.to === to);
      // If this considered leg is also the direct D[i][j] and that direct edge exists, skip (direct renderer draws it).
      if (isDirect && adj[from][to] < Infinity) return;
      let d;
      if (from === to) {
        // self-loop tangent to the node: center along inward normal so it stays inside the graph
        const p = pos[from];
        const w = graphSvg.clientWidth;
        const h = graphSvg.clientHeight;
        const cx = w / 2, cy = h / 2;
        const vx = cx - p.x, vy = cy - p.y; // inward toward center
        const vlen = Math.hypot(vx, vy) || 1;
        const ux = vx / vlen, uy = vy / vlen; // inward unit vector
        const nodeR = 20, loopR = 22;         // larger loop, tangent to node (no gap)
        let lx = p.x + ux * (nodeR + loopR);
        let ly = p.y + uy * (nodeR + loopR);
        // Clamp center to keep loop fully inside the SVG
        lx = Math.max(loopR + 2, Math.min(w - loopR - 2, lx));
        ly = Math.max(loopR + 2, Math.min(h - loopR - 2, ly));
        const startX = lx + loopR, startY = ly;
        const midX   = lx - loopR, midY   = ly;
        d = `M ${startX} ${startY} A ${loopR} ${loopR} 0 1 1 ${midX} ${midY} A ${loopR} ${loopR} 0 1 1 ${startX} ${startY}`;
      } else {
        const { x: x1, y: y1 } = pos[from];
        const { x: x2, y: y2 } = pos[to];
        const dx = x2 - x1, dy = y2 - y1;
        const L  = Math.hypot(dx, dy);
        const ux = L > 0 ? dx / L : 1;
        const uy = L > 0 ? dy / L : 0;
        const perpX = -uy, perpY = ux;
        const DEFAULT_MARKER_W   = 9;
        const HIGHLIGHT_MARKER_W = 8;
        const OFFSET             = (DEFAULT_MARKER_W + HIGHLIGHT_MARKER_W)/2 + 2;
        const sx = x1 + ux*17 + perpX*OFFSET;
        const sy = y1 + uy*17 + perpY*OFFSET;
        const ex = x2 - ux*17 + perpX*OFFSET;
        const ey = y2 - uy*17 + perpY*OFFSET;
        const curvature = 30;
        const mx = (x1 + x2)/2 + perpX*curvature;
        const my = (y1 + y2)/2 + perpY*curvature;
        d = `M${sx},${sy} Q${mx},${my} ${ex},${ey}`;
      }
      const pth = document.createElementNS(NS,'path');
      pth.setAttribute('d', d);
      pth.setAttribute('fill', 'none');
      pth.setAttribute('stroke', color);
      pth.setAttribute('stroke-width', '3');
      pth.setAttribute('marker-end', `url(#${markerId})`);
      if (adj[from][to] === Infinity) {
        pth.setAttribute('stroke-dasharray', '6 3');
        pth.setAttribute('stroke-opacity', '0.95');
      }
      graphSvg.appendChild(pth);
  });
  }

  // 4.5) highlight the direct existing edge i→j in orange (if present)
  if (highlight.direct && adj[highlight.direct.from][highlight.direct.to] < Infinity) {
    const from = highlight.direct.from;
    const to   = highlight.direct.to;
    if (from !== to) {
      const alsoConsider = Array.isArray(highlight.considerEdges) && highlight.considerEdges.some(pe => pe.from === from && pe.to === to);
      const { x: x1, y: y1 } = pos[from];
      const { x: x2, y: y2 } = pos[to];
      const dx = x2 - x1, dy = y2 - y1;
      const L  = Math.hypot(dx, dy), ux = dx / L, uy = dy / L;
      const perpX = -uy, perpY = ux;
      const DEFAULT_MARKER_W   = 9;
      const HIGHLIGHT_MARKER_W = 8;
      const OFFSET             = (DEFAULT_MARKER_W + HIGHLIGHT_MARKER_W)/2 + 2;
      const sx = x1 + ux*17 + perpX*OFFSET;
      const sy = y1 + uy*17 + perpY*OFFSET;
      const ex = x2 - ux*17 + perpX*OFFSET;
      const ey = y2 - uy*17 + perpY*OFFSET;
      const curvature = 30;
      const mx = (x1 + x2)/2 + perpX*curvature;
      const my = (y1 + y2)/2 + perpY*curvature;
      const d = `M${sx},${sy} Q${mx},${my} ${ex},${ey}`;
      const pth = document.createElementNS(NS,'path');
      pth.setAttribute('d', d);
      pth.setAttribute('fill', 'none');
      pth.setAttribute('stroke', '#f28e2b');
      pth.setAttribute('stroke-width', '3');
      pth.setAttribute('marker-end', 'url(#arrow-orange)');
      // If this edge is being added in this step, use dashed orange
      if (highlight.updateState === 'update') {
        pth.setAttribute('stroke-dasharray', '6 3');
      }
      graphSvg.appendChild(pth);
      let labelPath = pth;

      // no numeric labels for Warshall
    }
  }

  // 4.8) draw labels last so they sit above edges, with a white halo for readability
  labelItems.forEach(({x,y,text,color}) => {
    const lbl = document.createElementNS(NS, 'text');
    lbl.setAttribute('x', x);
    lbl.setAttribute('y', y);
    lbl.setAttribute('text-anchor', 'middle');
    lbl.setAttribute('dominant-baseline', 'central');
    lbl.setAttribute('font-weight', 'bold');
    lbl.setAttribute('fill', color || '#000');
    lbl.setAttribute('pointer-events','none');
    lbl.style.userSelect = 'none';
    // halo
    lbl.setAttribute('stroke', '#fff');
    lbl.setAttribute('stroke-width', '3');
    lbl.setAttribute('stroke-linejoin', 'round');
    lbl.style.paintOrder = 'stroke fill';
    lbl.textContent = text;
    graphSvg.appendChild(lbl);
  });

  // 5) draw nodes on top
  adj.forEach((_, i) => {
    const { x, y } = pos[i];
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const cls = ['graphNode'];
    if (highlight.node === i) cls.push('current');
    if (highlight.source === i) cls.push('source');
    if (highlight.target === i) cls.push('target');
    g.setAttribute('class', cls.join(' '));
    g.dataset.idx = String(i);

    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx', x); c.setAttribute('cy', y); c.setAttribute('r', 20);
    g.appendChild(c);

    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x); t.setAttribute('y', y); t.textContent = i;
    g.appendChild(t);

    graphSvg.appendChild(g);

    // Drag handlers
    g.addEventListener('mousedown', (ev) => {
      const idx = parseInt(g.dataset.idx, 10);
      dragging = { idx };
      ev.preventDefault();
    });
  });
}

    function renderMatrix(container, M, highlight = {}) {
  container.innerHTML = '';
  const n = M.length;
  const viaCells = Array.isArray(highlight.viaCells) ? highlight.viaCells : [];

  // make room for the extra index row/column
  container.style.gridTemplateColumns = `36px repeat(${n},1fr)`;
  container.style.gridTemplateRows    = `36px repeat(${n},1fr)`;

  // (0,0) corner empty
  const corner = document.createElement('div');
  corner.className = 'matrix-index';
  container.appendChild(corner);

  // column headers
  for (let j = 0; j < n; j++) {
    const colLabel = document.createElement('div');
    colLabel.className = 'matrix-index';
    colLabel.textContent = j;
    container.appendChild(colLabel);
  }

  // each row: first a row‐index cell, then the row’s data
  for (let i = 0; i < n; i++) {
    // row header
    const rowLabel = document.createElement('div');
    rowLabel.className = 'matrix-index';
    rowLabel.textContent = i;
    container.appendChild(rowLabel);

    // the actual matrix cells
    for (let j = 0; j < n; j++) {
      const div = document.createElement('div');
      div.className = 'matrix-element';

      // highlight the k-th row/col or cell
      if (highlight.k !== undefined && j === highlight.k) {
        div.classList.add('col-highlight');
      }
      if (highlight.k !== undefined && i === highlight.k) {
        div.classList.add('row-highlight');
      }
      if (highlight.i === i && highlight.j === j) {
        div.classList.add('highlight');
      }
      // mark via cells (i,k) and (k,j)
      if (viaCells.some(vc => vc.i === i && vc.j === j)) {
        div.classList.add('via-highlight');
      }

      div.textContent = String(M[i][j] === Infinity ? 0 : 1);
      container.appendChild(div);
    }
  }
    }


    function cloneMatrix(M) { return M.map(row => row.slice()); }

  // Warshall (Transitive Closure) events
function buildEvents(D) {
  const ev = [];
  const n = D.length;
  let Rprev = cloneMatrix(D);

  // emit a single init event
  ev.push({ type: 'init', R: cloneMatrix(Rprev) });
												   

  // for each intermediate vertex k
  for (let k = 0; k < n; k++) {
					   
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const oldVal = Rprev[i][j] !== Infinity; // boolean
        const left   = Rprev[i][k] !== Infinity;
        const right  = Rprev[k][j] !== Infinity;
        const via    = left && right;
        const newVal = oldVal || via;

								
        // snapshot the matrix before any update
        const oldR = cloneMatrix(Rprev);

        // apply boolean update
        if (newVal && !oldVal) {
          Rprev[i][j] = 1;
        }

        // emit exactly one 'cell' event per (i,j,k)
        ev.push({
          type:    'cell',
          k, i, j,
          oldVal, left, right, via, newVal,
          Rprev:   oldR
        });
      }
    }
  }

  return ev;
}
    // Rebuild UI per event
    function rebuild() {
  const e = events[ptr];
  if (!e) return;

  if (e.type === 'init') {
    const baseEdges = baseEdgesFor(e.R);
    renderGraph(e.R, baseEdges);
    renderMatrix(matR, e.R);
    commentBox.textContent = 'Computing transitive closure: D[i][j] = D[i][j] OR (D[i][k] AND D[k][j])';
    prevBtn.disabled = true;
    nextBtn.disabled = false;
    playBtn.disabled = false;
  }
  // rebuild()’s cell step:
else if (e.type === 'cell') {
  // 1) the two legs we’re “considering” this step (omit self-edges for clarity)
  const candidateEdges = [
    { from: e.i, to: e.k },
    { from: e.k, to: e.j }
  ];

  // 2) phantom ∞-edges relative to current D (before updating this cell)
  const phantomEdges = [
    { from: e.i, to: e.j },
    ...candidateEdges
  ].filter(ep => e.Rprev[ep.from][ep.to] === Infinity);

  // 3) highlight exactly those applicable legs in yellow
  const considerEdges = candidateEdges.map((ed, idx) => ({ ...ed, roleIndex: idx }));

  // Build the updated matrix state for this step (after applying update)
  const updatedR = e.Rprev.map(r => r.slice());
  updatedR[e.i][e.j] = e.newVal;

  // 4) one draw call with considered edges only (suppress shortest-path overlay for clarity)
  const opts = {
    node:           e.k,
    source:         e.i,
    target:         e.j,
    direct:         { from: e.i, to: e.j },
    updateState:    (e.newVal < e.oldVal) ? 'update' : 'nochange',
    directOld:      e.oldVal,
    directNew:      e.newVal,
    phantomEdges,
    considerEdges
  };
  const baseEdges = baseEdgesFor(updatedR);
  renderGraph(updatedR, baseEdges, opts);

  // 4) update the D-matrix and comment as before
  renderMatrix(matR, updatedR, { i: e.i, j: e.j, k: e.k, viaCells: [ { i: e.i, j: e.k }, { i: e.k, j: e.j } ] });

  const a = e.oldVal ? 1 : 0;
  const b = e.left ? 1 : 0;
  const c = e.right ? 1 : 0;
  const viaVal = e.via ? 1 : 0;
  const newVal01 = e.newVal ? 1 : 0;
  const changed = e.newVal && !e.oldVal;

  const vee = '∨';
  const wedge = '∧';

  const boldSymDirect = changed ? `D[${e.i}][${e.j}]` : `<b>D[${e.i}][${e.j}]</b>`;
  const boldSymVia = changed
    ? `<b>D[${e.i}][${e.k}] ${wedge} D[${e.k}][${e.j}]</b>`
    : `D[${e.i}][${e.k}] ${wedge} D[${e.k}][${e.j}]`;

  const aNum = changed ? `${a}` : `<b>${a}</b>`;
  const viaNum = changed ? `<b>${viaVal}</b>` : `${viaVal}`;
  // For the first numeric expression, bold the deciding side
  const aNumFirst = aNum; // same rule: bold when unchanged
  const bNumFirst = changed ? `<b>${b}</b>` : `${b}`;
  const cNumFirst = changed ? `<b>${c}</b>` : `${c}`;

  commentBox.innerHTML = `
(k,i,j) = (${e.k}, ${e.i}, ${e.j}): Is there a path ${e.i}&#x279E;${e.k}&#x279E;${e.j} that connects ${e.i}&#x279E;${e.j}?<br>
<table border=0>
  <tr>
    <td>D[${e.i}][${e.j}]</td>
    <td>= ${boldSymDirect} ${vee} (${boldSymVia})</td>
  </tr>
  <tr>
    <td></td>
    <td>= ${aNumFirst} ${vee} (${bNumFirst} ${wedge} ${cNumFirst}) = ${aNum} ${vee} ${viaNum} = <b>${newVal01}</b> ${changed ? '&nbsp;&nbsp;<b>Connected via k</b>' : '&nbsp;&nbsp;No change'}</td>
  </tr>
</table>
`;

  prevBtn.disabled = nextBtn.disabled = false;
}
 else if (e.type === 'afterK') {
  const baseEdges = baseEdgesFor(e.R);
  renderGraph(e.R, baseEdges, { node: e.k });
  renderMatrix(matR, e.R, { changed: e.changed });
  const n = A.length;
   if (e.k < n - 1) {
  commentBox.innerHTML = 
      `Computing D<sup>${e.k+2}</sup> from D<sup>${e.k+1}</sup> (allowing vertex ${e.k+1} as an intermediate).`;
   }
  // ← make sure you can always step forward again
  prevBtn.disabled = false;
  nextBtn.disabled = false;
  playBtn.disabled = false;
}
// New
else if (e.type === 'done') {
  const baseEdges = baseEdgesFor(e.R);
  renderGraph(e.R, baseEdges);
  renderMatrix(matR, e.R);

  // explicitly show R^n
  updateTheme(
    '#fde2e2',            // keep your pink fill
    '#e63946',            // keep your red stroke
    'rgba(198,219,239,0.7)', // keep your matrix bg
    A.length              // ← n, not n-1
  );

  commentBox.textContent = 'Done! Transitive closure computed.';
  prevBtn.disabled = false;
  nextBtn.disabled = true;
  playBtn.disabled = true;
}

}

function getNodePositions(n) {
  // Use safe fallbacks if graph is currently collapsed (0×0)
  const cw = graphSvg.clientWidth  || 300;
  const ch = graphSvg.clientHeight || 300;
  const w = Math.max(120, cw);
  const h = Math.max(120, ch);
  const pad = 40;  // how far from the border you want your nodes

  const availW = Math.max(40, w - 2*pad);
  const availH = Math.max(40, h - 2*pad);
  const perim  = 2*(availW + availH);

  return Array.from({ length: n }, (_, i) => {
    const d = (i * perim) / n;
    if (d < availW) {
      return { x: pad + d, y: pad };
    } else if (d < availW + availH) {
      return { x: w - pad, y: pad + (d - availW) };
    } else if (d < 2*availW + availH) {
      return { x: w - pad - (d - (availW + availH)), y: h - pad };
    } else {
      return { x: pad, y: h - pad - (d - (2*availW + availH)) };
    }
  });
}

// ─────────── NEW ───────────
function preprocessEdgeWeights(edges, pos) {
  const arrowMargin      = 12;                       // px back from arrowhead
  const labelRadius      = 8;                        // half-text width
  const DEFAULT_MARKER_W = 9;
  const HIGHLIGHT_MARKER_W = 8;                      // 4*2 
  const OFFSET           = (DEFAULT_MARKER_W + HIGHLIGHT_MARKER_W)/2 + 2;
  const curvature        = 30;

  edges.forEach(e => {
    if (e.weight == null) return;

    // compute the same bezier‐curve you draw in renderGraph:
    const p1 = pos[e.from], p2 = pos[e.to];
						 
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const L  = Math.hypot(dx, dy), ux = dx/L, uy = dy/L;
								   
    const perpX = -uy, perpY = ux;

    const sx = p1.x + ux*17 + perpX*OFFSET;
    const sy = p1.y + uy*17 + perpY*OFFSET;
    const ex = p2.x - ux*17 + perpX*OFFSET;
    const ey = p2.y - uy*17 + perpY*OFFSET;
    const mx = (p1.x + p2.x)/2 + perpX*curvature;
    const my = (p1.y + p2.y)/2 + perpY*curvature;

    const d  = `M${sx},${sy} Q${mx},${my} ${ex},${ey}`;

    // temporarily append, sample a point, then remove it:
    const tempPath = document.createElementNS(NS, 'path');
    tempPath.setAttribute('d', d);
    graphSvg.appendChild(tempPath);

    let pt = null;
    try {
      const totalLen = tempPath.getTotalLength();
      // Place label at a stable fraction along the curve to avoid jumping.
      const frac = 0.6; // 60% along the path, keeps clear of arrowhead
      const len  = arrowMargin + (totalLen - arrowMargin - labelRadius) * frac;
      pt   = tempPath.getPointAtLength(Math.max(arrowMargin, Math.min(totalLen - labelRadius, len)));
    } catch {}
				  
    if (pt) {
      e.lx = pt.x;
      e.ly = pt.y;
    } else {
      e.lx = (p1.x + p2.x) / 2;
      e.ly = (p1.y + p2.y) / 2;
    }
    graphSvg.removeChild(tempPath);
  });
}

// walk i→j by following nextHop[i][j], building node‐list
// Guard against cycles (especially with negative cycles) to avoid infinite loops
function reconstructPath(i, j, nextHop, limit = 200) {
  if (nextHop[i][j] == null) return [];
  const path = [i];
  let u = i;
  const visited = new Set([i]);
  let steps = 0;
  while (u !== j && steps < limit) {
    const v = nextHop[u][j];
    if (v == null) return [];
    if (visited.has(v)) {
      // cycle encountered; path is not simple — return empty to avoid lockup
      return [];
    }
    path.push(v);
    visited.add(v);
    u = v;
    steps++;
  }
  if (u !== j) return [];
  return path;
}

// convert [u0,u1,u2…] into [{from:u0,to:u1},{from:u1,to:u2},…]
function pathToEdges(nodes) {
  return nodes.slice(0, -1).map((u, idx) => ({
    from: u,
    to:   nodes[idx + 1]
  }));
}

    // Generate Button Handler
// Mutually exclusive toggles: if negative cycle checked, ignore negative edges
genBtn.addEventListener('click', () => {
  // 1) read & clamp n
  let n = parseInt(dimInput.value, 10) || 0;
  if (n < 1) n = 1;
  if (n > 10) n = 10;
  dimInput.value = n;

  // 2) generate a fresh random graph
  const g = genRandomGraph(n);
  hasNegCycle = false;
  A     = g.M;
  edges = g.ed;
  // record original adjacency edge set for styling later
  originalEdgeSet = new Set(edges.map(e => `${e.from}-${e.to}`));

  // 3) PREPROCESS: compute node coords & weight‐label positions
  nodePos = getNodePositions(A.length);
  preprocessEdgeWeights(edges, nodePos);

  // 4) rebuild the event sequence & reset
  events  = buildEvents(A);
  ptr     = 0;
  clearInterval(timer);
  playing = false;
  playBtn.textContent = 'Play';

  // 5) style & render the very first frame
  updateTheme(
    '#fde2e2',              // graph fill
    '#e63946',              // graph stroke
    'rgba(198,219,239,0.7)',// matrix bg
    0                       // initial k
  );
  rebuild();
});

  // ─── New nextBtn handler ─────────────────────────────────────────────────────
nextBtn.addEventListener('click', () => {
  direction = 'forward';
    if (ptr < events.length - 1) {
    // move forward one event...
    ptr++;
    // …but if that event is the final afterK (k === n-1) with no comment, skip it straight to done
    const peek = events[ptr];
    if (peek.type === 'afterK' && peek.k === A.length - 1) {
      ptr++;
    }
  } else {
    ptr = 0;
  }
  const e = events[ptr];
  if (e.type !== 'done') {
    const kVal = (e.k !== undefined)
      ? (e.type === 'afterK' ? e.k + 1 : e.k)
      : 0;
    updateTheme('#fde2e2','#e63946','rgba(198,219,239,0.7)', kVal);
  }
  rebuild();
});

 // Prev button (skip the final “done” event)
 prevBtn.addEventListener('click', () => {
   direction = 'backward';

   // if we're currently on the 'done' event, drop back one more immediately
   if (events[ptr]?.type === 'done') {
     ptr--;
   }

   if (ptr > 0) {
     // undo exactly one real step
     const evUndo = events[ptr];
     ptr--;
   } else {
     return; // at the very start
   }

   // now update your theme and UI based on the new ptr
   const e = events[ptr];
   const kVal = (e.k !== undefined)
     ? (e.type === 'afterK' ? e.k + 1 : e.k)
     : 0;
   updateTheme('#fde2e2', '#e63946', 'rgba(198,219,239,0.7)', kVal);
   rebuild();
 });

    playBtn.addEventListener('click', () => {
      if (!playing) {
        playing = true;
        playBtn.textContent = 'Pause';
        const baseDelay = 700 / speed;
        const interval = Math.max(33, Math.floor(baseDelay)); // cap at ~30fps
        timer = setInterval(() => {
          if (ptr >= events.length - 1) {
            clearInterval(timer);
            playing = false;
            playBtn.textContent = 'Play';
            return;
          }
          // advance multiple steps if baseDelay is faster than interval
          const stepAdvance = Math.max(1, Math.round(interval / baseDelay));
          for (let s = 0; s < stepAdvance && ptr < events.length - 1; s++) {
            ptr++;
          }
          const e = events[ptr];
          if (e && e.type !== 'done') {
            const kVal = (e.k !== undefined)
              ? (e.type === 'afterK' ? e.k + 1 : e.k)
              : 0;
            updateTheme('#fde2e2', '#e63946', 'rgba(198,219,239,0.7)', kVal);
          }
          rebuild();
        }, interval);
      } else {
        clearInterval(timer);
        playing = false;
        playBtn.textContent = 'Play';
      }
    });
    speedSelect.addEventListener('change', () => { speed = parseInt(speedSelect.value,10)||1; });
    // toggle for showing only original edges
    onlyOriginalChk.addEventListener('change', () => {
      rebuild();
    });

    // Build current highlight payload for redraws during drag
    function currentGraphHighlight() {
      const e = events[ptr];
      if (!e) return {};
      if (e.type === 'cell') {
        const candidateEdges = [
          { from: e.i, to: e.k, roleIndex: 0 },
          { from: e.k, to: e.j, roleIndex: 1 }
        ];
        const phantomEdges = [ { from: e.i, to: e.j }, ...candidateEdges ].filter(ep => e.Rprev[ep.from][ep.to] === Infinity);
        return {
          node: e.k,
          source: e.i,
          target: e.j,
          direct: { from: e.i, to: e.j },
          updateState: (e.newVal < e.oldVal) ? 'update' : 'nochange',
          directOld: e.oldVal,
          directNew: e.newVal,
          phantomEdges,
          considerEdges: candidateEdges
        };
      } else if (e.type === 'afterK') {
        return { node: e.k };
      }
      return {};
    }

    // Adjacency and edges corresponding to current event view
    function currentAdjEdges() {
      const e = events[ptr];
      if (!e) return { adj: A, ed: edges };
      if (e.type === 'cell') {
        const updatedR = e.Rprev.map(r => r.slice());
        updatedR[e.i][e.j] = e.newVal;
        return { adj: updatedR, ed: baseEdgesFor(updatedR) };
      }
      if (e.R) return { adj: e.R, ed: baseEdgesFor(e.R) };
      return { adj: A, ed: edges };
    }

    // Drag loop listeners
    function svgPointFromEvent(ev) {
      const rect = graphSvg.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      return { x: Math.max(20, Math.min(rect.width - 20, x)), y: Math.max(20, Math.min(rect.height - 20, y)) };
    }
    window.addEventListener('mousemove', (ev) => {
      if (!dragging) return;
      const { x, y } = svgPointFromEvent(ev);
      const idx = dragging.idx;
      // update in the same coordinate space used by renderGraph
      nodePos[idx] = { x, y };
      const { adj, ed } = currentAdjEdges();
      renderGraph(adj, ed, currentGraphHighlight());
    });
    window.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = null;
      // recompute weight label anchors for new geometry
      preprocessEdgeWeights(edges, nodePos);
      const { adj, ed } = currentAdjEdges();
      renderGraph(adj, ed, currentGraphHighlight());
    });

    // Keep nodes in-bounds on resize/fullscreen changes
    function clampAllNodePos() {
      const w = graphSvg.clientWidth;
      const h = graphSvg.clientHeight;
      const margin = 20; // node radius
      if (!nodePos || !nodePos.length) return;
      for (let i = 0; i < nodePos.length; i++) {
        const p = nodePos[i];
        if (!p) continue;
        p.x = Math.max(margin, Math.min(w - margin, p.x));
        p.y = Math.max(margin, Math.min(h - margin, p.y));
      }
    }
    let resizeScheduled = false;
    function onResize() {
      if (resizeScheduled) return;
      resizeScheduled = true;
      requestAnimationFrame(() => {
        resizeScheduled = false;
        const w = graphSvg.clientWidth;
        const h = graphSvg.clientHeight;
        // Skip if size effectively unchanged
        if (Math.abs(w - lastGraphSize.w) < 1 && Math.abs(h - lastGraphSize.h) < 1) return;

        const wasTiny = (lastGraphSize.w < 60 || lastGraphSize.h < 60);
        const isGood  = (w >= 120 && h >= 120);
        if (isGood && wasTiny) {
          nodePos = getNodePositions(A.length);
        }
        lastGraphSize = { w, h };

        clampAllNodePos();
        preprocessEdgeWeights(edges, nodePos);
        const { adj, ed } = currentAdjEdges();
        renderGraph(adj, ed, currentGraphHighlight());
      });
    }
    // Observe actual element size changes (covers accordion/minimized cases).
    if ('ResizeObserver' in window) {
      const ro = new ResizeObserver(() => onResize());
      ro.observe(graphSvg);
    }
    window.addEventListener('resize', onResize);
    document.addEventListener('fullscreenchange', onResize);

    // Init
    genBtn.click();
    // If first render happens while collapsed, try a follow-up pass soon after.
    setTimeout(() => onResize(), 0);
  })();
  </script>
</body>
</html>
