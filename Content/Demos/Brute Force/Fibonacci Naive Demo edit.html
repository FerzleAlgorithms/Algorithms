<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Naïve Recursive Fibonacci Demo</title>
  <!-- Common CSS -->
  <script src="../../../scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">
  <style>
    /* Controls styling similar to Recursion Tree Demo */
    #controls { margin-bottom: 1em; }
    #controls input, #controls button, #controls select {
      margin-left: 0.5em;
      padding: 0.3em 0.6em;
      font-size: 1em;
      cursor: pointer;
    }
    #controls button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    /* Node styling */
    .graphNode circle {
      fill: #cce3ff;
      stroke: #444;
      stroke-width: 1px;
    }
    .graphNode.current circle {
      stroke: #000;
      stroke-width: 2px;
    }
    .graphNode.highlight circle {
      fill: lightgreen;
    }
    .node-text {
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      font-family: sans-serif;
    }
    #commentary { margin-top: 10px; font-family: sans-serif; font-style: italic; }
  </style>
</head>
<body>
  <h2>Naïve Recursive Fibonacci Demo</h2>
  <div id="controls">
    <label><strong>Enter n:</strong>
      <input id="inputN" type="number" value="5" min="2" max="9" style="width:4em;"></label>
    <button id="startBtn">Set n</button>
    <button id="prevBtn" disabled>Previous</button>
    <button id="nextBtn" disabled>Next</button>
    <button id="playBtn">Play</button>
    <label for="speed">Speed:</label>
    <select id="speed"><option value="1">1×</option><option value="2">2×</option><option value="4">4×</option></select>
    <span id="nodesCount">Nodes drawn: 0</span>
  </div>
  <svg id="treeSvg" width="800" height="600" preserveAspectRatio="xMinYMin meet" style="display:block;margin:0 auto;overflow:visible;">
    <g id="linkLayer"></g>
    <g id="nodeLayer"></g>
  </svg>
  <div id="commentary"></div>
  <script>
    // Adapted draw functions to use <g class="graphNode">
    const svg = document.getElementById('treeSvg');
    const svgNS = 'http://www.w3.org/2000/svg';
    let events = [], pointer = 0, playing = false, intervalId = null;
    let positions = {}, globalId = 0;
    
    function computeFib(k) { return k < 2 ? k : computeFib(k-1) + computeFib(k-2); }
    
    function buildEvents(n) {
      events = [];
      positions = {};
      globalId = 0;
      function traverse(k, parent=null, depth=0) {
        const id = globalId++;
        events.push({ type:'call', id, n:k, parent });
        if (k < 2) {
          events.push({ type:'return', id, n:k, value:k });
        } else {
          traverse(k-1,id,depth+1);
          traverse(k-2,id,depth+1);
          events.push({ type:'return', id, n:k, value:computeFib(k) });
        }
      }
      traverse(n);
      pointer = 0;
    }
    
    function clearSvg() {
      document.getElementById('linkLayer').innerHTML = '';
      document.getElementById('nodeLayer').innerHTML = '';
    }
    
    function renderStep() {
      if (pointer >= events.length) return;
      const ev = events[pointer++];
      clearHighlights();
      if (ev.type === 'call') {
        drawNode(ev);
        commentary.textContent = `Call fib(${ev.n})`;
      } else {
        showValue(ev);
        commentary.textContent = `Return fib(${ev.n}) = ${ev.value}`;
      }
      document.getElementById('nodesCount').textContent = `Nodes drawn: ${pointer}`;
      updateButtons();
    }
    
    function drawNode(ev) {
      const { id, n, parent } = ev;
      const depth = 0; // for simplicity; positions can be precomputed if needed
      const x = (800 / (events.length+1)) * id + 40;
      const y = 40 + depth * 90;
      const g = document.createElementNS(svgNS,'g');
      g.setAttribute('id',`node-${id}`);
      g.classList.add('graphNode','current');
      const c = document.createElementNS(svgNS,'circle');
      c.setAttribute('cx',x);c.setAttribute('cy',y);c.setAttribute('r',12);
      g.appendChild(c);
      const lab = document.createElementNS(svgNS,'text');
      lab.setAttribute('x',x);lab.setAttribute('y',y-20);
      lab.setAttribute('text-anchor','middle');lab.textContent=`F(${n})`;
      g.appendChild(lab);
      const vt = document.createElementNS(svgNS,'text');
      vt.setAttribute('x',x);vt.setAttribute('y',y+4);
      vt.setAttribute('text-anchor','middle');vt.classList.add('node-text');
      g.appendChild(vt);
      document.getElementById('nodeLayer').appendChild(g);
      if (parent !== null) {
        const p = document.getElementById(`node-${parent}`).querySelector('circle');
        const px = p.getAttribute('cx'), py = p.getAttribute('cy');
        const ln = document.createElementNS(svgNS,'line');
        ln.setAttribute('x1',px); ln.setAttribute('y1',py*1+12);
        ln.setAttribute('x2',x); ln.setAttribute('y2',y-12);
        document.getElementById('linkLayer').appendChild(ln);
      }
    }
    
    function showValue(ev) {
      const g = document.getElementById(`node-${ev.id}`);
      const texts = g.querySelectorAll('text');
      texts[texts.length-1].textContent = ev.value;
      g.classList.add('highlight');
    }
    
    function clearHighlights() {
      document.querySelectorAll('.graphNode').forEach(n => n.classList.remove('current','highlight'));
    }
    
    function updateButtons() {
      document.getElementById('prevBtn').disabled = pointer <= 1;
      document.getElementById('nextBtn').disabled = pointer >= events.length;
    }
    
    document.getElementById('startBtn').onclick = () => {
      const v = parseInt(document.getElementById('inputN').value,10);
      if (!isNaN(v) && v >= 2) {
        buildEvents(v);
        clearSvg();
        pointer = 0;
      }
    };
    document.getElementById('nextBtn').onclick = renderStep;
    document.getElementById('prevBtn').onclick = () => { clearSvg(); pointer = Math.max(0, pointer-1); for (let i=0;i<pointer;i++) renderStep(); };
    document.getElementById('playBtn').onclick = function() {
      if (playing) { clearInterval(intervalId); playing = false; this.textContent = 'Play'; }
      else {
        playing = true; this.textContent = 'Pause';
        const speed = parseInt(document.getElementById('speed').value,10) || 1;
        intervalId = setInterval(renderStep, 1000 / speed);
      }
    };
    
    window.addEventListener('load', () => {
      buildEvents(5);
      clearSvg();
    });
  </script>
</body>
</html>
