<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Convex Hull Brute-Force Demo</title>
  <script src="../../../scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
  <style>
    /* Minimal inline styles to complement existing demo.css */
    .controls label { display: inline-flex; align-items: center; gap: .4rem; }
    #stepInfo {
      margin-left: auto;
      font-size: .9rem;
      opacity: .85;
      display: inline-block;          /* allow fixed height without breaking layout */
      line-height: 1.2em;             /* consistent line spacing */
      min-height: calc(1.2em * 3);    /* reserve space for 3 lines */
      white-space: pre-line;          /* render \n as line breaks */
      vertical-align: top;
    }
    .canvas-wrap { position: relative; border: 1px solid #ddd; background: #fff; }
    #ch-canvas { width: 100%; height: 520px; display: block; }
    /* Legend uses shared styles from demo.css */
  </style>
</head>
<body class="no-tooltips">
  <div class="demo-container">
    <h2>Convex Hull Brute-Force Demo</h2>
    <div class="controls">
      <label>Points:
        <input id="pointCount" type="number" min="10" max="200" value="30" step="1" style="width: 70px;">
      </label>
      <button id="generateBtn">Generate</button>
      <br>
      <button id="prevBtn">Previous</button>
      <button id="nextBtn">Next</button>
      <button id="playBtn">Play</button>
      <label for="speed">Speed:</label>
      <select id="speed">
        <option value="1">1×</option>
        <option value="2">2×</option>
        <option value="4">4×</option>
        <option value="8">8×</option>
        <option value="16">16×</option>
        <option value="32">32×</option>
        <option value="64">64×</option>
        <option value="128">128×</option>
      </select>
      <br>
      <span id="stepInfo">Step 0 / 0</span>
    </div>
    
    <div class="canvas-wrap">
      <canvas id="ch-canvas"></canvas>
    </div>
    <div class="legend">
      <strong class="legend-label">Legend:</strong>
      <div class="legend-items">
        <span class="legend-box" style="background-color:#222"></span> Points
        <span class="legend-box" style="background-color:#1f77b4"></span> Left-side points
        <span class="legend-box" style="background-color:#ff7f0e"></span> Right-side points
        <span class="legend-box" style="background-color:#d62728"></span> Highlighted points<br>
        <span class="legend-box" style="background-color:#27ae60"></span> Hull edges (solid)
        <span class="legend-box" style="background-color:#8e44ad"></span> Current edge (focus)
        <span class="legend-box" style="background-color:#ff9900"></span> Distance (dotted)
      </div>
    </div>
  </div>

  <script>
    //
    // Brute-force convex hull demo: test every pair (i,j)
    // Edge (i,j) is on the hull if all other points lie on one side (or collinear).
    //
    (function() {
      const canvas = document.getElementById('ch-canvas');
      const ctx = canvas.getContext('2d');

      const pointCountEl = document.getElementById('pointCount');
      const generateBtn = document.getElementById('generateBtn');
      const prevBtn = document.getElementById('prevBtn');
      const playBtn = document.getElementById('playBtn');
      const nextBtn = document.getElementById('nextBtn');
      const speedEl = document.getElementById('speed');
      const stepInfoEl = document.getElementById('stepInfo');


      const COLORS = {
        points: '#222',
        current: '#8e44ad',       // current edge under test (dashed)
        distance: '#ff9900',      // dotted candidate visualization
        hull: '#27ae60',          // final hull edges (solid)
        highlight: '#d62728',
        leftSide: '#1f77b4',      // blue
        rightSide: '#ff7f0e'      // orange
      };

      const EDGE_MARGIN = 20;

      function getPointCount() {
        const v = parseInt(pointCountEl.value, 10) || 0;
        const n = Math.max(3, Math.min(200, v));
        if (n !== v) pointCountEl.value = n;
        return n;
      }

      const state = {
        points: [],
        steps: [],
        current: 0,
        timer: null,
        speed: 1,
        view: { mode: null, normalW: 0, normalH: 0, fullscreenW: 0, fullscreenH: 0 }
      };

      // Decide canvas height:
      // - fullscreen: fill viewport minus controls
      // - normal: ~65vh clamped to [360, 640]
      function computeCanvasHeight() {
        const controlsEl = document.querySelector('.controls');
        if (document.fullscreenElement) {
          const pad = 16;
          const controlsH = controlsEl ? controlsEl.getBoundingClientRect().height : 0;
          return Math.max(300, window.innerHeight - controlsH - pad * 2);
        }
        const target = Math.round(window.innerHeight * 0.65);
        return Math.max(360, Math.min(640, target));
      }

      // Resize canvas to element size and scale stored geometry to fill
      function resizeCanvas() {
        // Let CSS height be driven by JS for responsiveness/fullscreen
        canvas.style.height = computeCanvasHeight() + 'px';
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        // If we have a logical coordinate system, map it to screen with uniform scale
        if (state.view && state.view.logicalW && state.view.logicalH) {
          const lw = state.view.logicalW; const lh = state.view.logicalH;
          const s = Math.max(0.0001, Math.min(cssWidth / lw, cssHeight / lh));
          const tx = (cssWidth - s * lw) / 2;
          const ty = (cssHeight - s * lh) / 2;
          ctx.setTransform(dpr * s, 0, 0, dpr * s, dpr * tx, dpr * ty);
          render();
          return;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Only scale stored geometry when toggling fullscreen mode, not on every resize
        const mode = document.fullscreenElement ? 'fullscreen' : 'normal';
        const v = state.view;
        if (v.mode == null) {
          v.mode = mode;
          if (mode === 'fullscreen') { v.fullscreenW = cssWidth; v.fullscreenH = cssHeight; }
          else { v.normalW = cssWidth; v.normalH = cssHeight; }
        } else if (v.mode !== mode) {
          const fromW = v.mode === 'fullscreen' ? v.fullscreenW : v.normalW;
          const fromH = v.mode === 'fullscreen' ? v.fullscreenH : v.normalH;
          const sx = fromW ? cssWidth / fromW : 1;
          const sy = fromH ? cssHeight / fromH : 1;
          if (state.points && state.points.length && isFinite(sx) && isFinite(sy) && (Math.abs(sx - 1) > 1e-6 || Math.abs(sy - 1) > 1e-6)) {
            for (const p of state.points) { p.x *= sx; p.y *= sy; }
            for (const s of state.steps) {
              if (s.distances) {
                for (const d of s.distances) {
                  if (d && d.foot) { d.foot.x *= sx; d.foot.y *= sy; }
                }
              }
            }
            // ensure everything remains within visible bounds
            const margin = 2;
            const w = canvas.clientWidth || canvas.width;
            const h = canvas.clientHeight || canvas.height;
            const maxX = Math.max(1, w - margin);
            const maxY = Math.max(1, h - margin);
            for (const p of state.points) {
              p.x = Math.max(margin, Math.min(maxX, p.x));
              p.y = Math.max(margin, Math.min(maxY, p.y));
            }
            for (const s of state.steps) {
              if (s && s.distances) {
                for (const d of s.distances) {
                  if (d && d.foot) {
                    d.foot.x = Math.max(margin, Math.min(maxX, d.foot.x));
                    d.foot.y = Math.max(margin, Math.min(maxY, d.foot.y));
                  }
                }
              }
            }
          }
          v.mode = mode;
          if (mode === 'fullscreen') { v.fullscreenW = cssWidth; v.fullscreenH = cssHeight; }
          else { v.normalW = cssWidth; v.normalH = cssHeight; }
        } else {
          // same mode: record previous size and update to latest
          if (mode === 'fullscreen') {
            const prevW = v.fullscreenW, prevH = v.fullscreenH;
            v.fullscreenW = cssWidth; v.fullscreenH = cssHeight;
            // if canvas area shrank, clamp points to keep all visible
            if ((prevW && cssWidth < prevW) || (prevH && cssHeight < prevH)) {
              // On same-mode shrink, clamp minimally to keep points visible without shifting layout
              const maxX = Math.max(1, cssWidth - 1);
              const maxY = Math.max(1, cssHeight - 1);
              for (const p of state.points) {
                p.x = Math.max(1, Math.min(maxX, p.x));
                p.y = Math.max(1, Math.min(maxY, p.y));
              }
              for (const s of state.steps) {
                if (s && s.distances) {
                  for (const d of s.distances) {
                    if (d && d.foot) {
                      d.foot.x = Math.max(1, Math.min(maxX, d.foot.x));
                      d.foot.y = Math.max(1, Math.min(maxY, d.foot.y));
                    }
                  }
                }
              }
            }
          } else {
            const prevW = v.normalW, prevH = v.normalH;
            v.normalW = cssWidth; v.normalH = cssHeight;
            if ((prevW && cssWidth < prevW) || (prevH && cssHeight < prevH)) {
              const maxX = Math.max(1, cssWidth - 1);
              const maxY = Math.max(1, cssHeight - 1);
              for (const p of state.points) {
                p.x = Math.max(1, Math.min(maxX, p.x));
                p.y = Math.max(1, Math.min(maxY, p.y));
              }
              for (const s of state.steps) {
                if (s && s.distances) {
                  for (const d of s.distances) {
                    if (d && d.foot) {
                      d.foot.x = Math.max(1, Math.min(maxX, d.foot.x));
                      d.foot.y = Math.max(1, Math.min(maxY, d.foot.y));
                    }
                  }
                }
              }
            }
          }
        }
        render();
      }
      window.addEventListener('resize', resizeCanvas);
      document.addEventListener('fullscreenchange', resizeCanvas);

      function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

      function generatePoints(n) {
        const w = (state.view && state.view.logicalW) || canvas.clientWidth || 900;
        const h = (state.view && state.view.logicalH) || canvas.clientHeight || 520;
        const pad = EDGE_MARGIN;
        const seen = new Set();
        const pts = [];
        while (pts.length < n) {
          const x = randInt(pad, w - pad);
          const y = randInt(pad, h - pad);
          const key = `${x},${y}`;
          if (!seen.has(key)) {
            seen.add(key);
            pts.push({ id: pts.length, x, y });
          }
        }
        return pts;
      }

      // Geometry helpers
      function cross(a, b, c) { return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); }
      function distanceToLine(a, b, p) {
        const A = b.y - a.y, B = a.x - b.x, C = b.x * a.y - a.x * b.y;
        const denom = Math.hypot(A, B) || 1;
        const d = Math.abs(A * p.x + B * p.y + C) / denom;
        //
        // foot of perpendicular from p to line ab
        const abx = b.x - a.x, aby = b.y - a.y;
        const t = ((p.x - a.x) * abx + (p.y - a.y) * aby) / (abx * abx + aby * aby || 1);
        const foot = { x: a.x + t * abx, y: a.y + t * aby };
        return { d, foot };
      }
      function isLeft(a, b, p) { return cross(a, b, p) > 0; }
      function sameEdge(e1, e2) {
        if (!e1 || !e2) return false;
        const { a: a1, b: b1 } = e1, { a: a2, b: b2 } = e2;
        return (a1 === a2 && b1 === b2) || (a1 === b2 && b1 === a2);
      }

      // Step recording
      function addStep(step) {
        state.steps.push({
          desc: step.desc || '',
          // three-line comment area content
          comment1: step.comment1 || '',
          comment2: step.comment2 || '',
          comment3: step.comment3 || '',
          // current edge being discussed [{a,b}]
          dividing: step.dividing || [],
          // new subproblem edges introduced this step
          sublines: step.sublines || [],
          // [{p, foot}]
          distances: step.distances || [],
          // [{a,b}]
          hullEdges: step.hullEdges || [],
          highlightPts: step.highlightPts || [],
          // stack of active edges [{a,b,type:'dividing'|'subline'}]
          persistent: step.persistent || [],
          // for brute-force: cumulative side classification
          sides: step.sides || null,
          // major step marker for navigation
          major: !!step.major
        });
      }

      // Brute-force: test every pair (i,j)
      function bruteHull(points) {
        state.steps = [];
        if (points.length < 2) return;

        const pts = points.slice();

        // Intro step
        addStep({
          desc: 'Points initialized. Click Next to begin testing edges.',
          comment1: 'Points initialized.',
          comment2: 'Press Next to begin.',
          comment3: '',
          major: true
        });

        const n = pts.length;
        const hullSet = new Set(); // for de-duping edges (by id pair sorted)

        for (let i = 0; i < n; i++) {
          // Announce which vertex is used as the first endpoint (line 1 remains while i is fixed)
          const firstLine = `Looking at edges with first endpoint ${pts[i].id}.`;
          addStep({
            desc: firstLine,
            comment1: firstLine,
            comment2: '',
            comment3: '',
            highlightPts: [pts[i]],
            major: true
          });
          for (let j = i + 1; j < n; j++) {
            const A = pts[i], B = pts[j];

            // Start testing edge (A,B)
            addStep({
              desc: `Test edge (${A.id},${B.id}).`,
              comment1: firstLine,
              comment2: `Checking edge (${A.id},${B.id}).`,
              comment3: '',
              dividing: [{ a: A, b: B }],
              highlightPts: [A, B],
              major: true
            });

            let sawPos = false, sawNeg = false;
            let invalid = false;
            const leftSoFar = [];
            const rightSoFar = [];

            for (let k = 0; k < n; k++) {
              if (k === i || k === j) continue;
              const P = pts[k];
              const s = cross(A, B, P);
              const { foot } = distanceToLine(A, B, P);
              if (s > 0) leftSoFar.push(P); else if (s < 0) rightSoFar.push(P);
              const sideStr = (s < 0) ? 'the right' : (s > 0) ? 'the left' : 'collinear';
              const thirdLine = (s === 0)
                ? `Vertex ${P.id} is collinear with (${A.id},${B.id}).`
                : `Vertex ${P.id} is on ${sideStr} of (${A.id},${B.id}).`;
              addStep({
                desc: `Check position of vertex ${P.id} relative to edge (${A.id},${B.id}).`,
                comment1: firstLine,
                comment2: `Checking edge (${A.id},${B.id}).`,
                comment3: thirdLine,
                dividing: [{ a: A, b: B }],
                distances: [{ p: P, foot }],
                // keep endpoints highlighted; color P via side coloring to avoid red overlay
                highlightPts: [A, B],
                sides: { left: leftSoFar.slice(), right: rightSoFar.slice() },
                major: false
              });
              if (s > 0) sawPos = true; else if (s < 0) sawNeg = true;
              if (sawPos && sawNeg) {
                addStep({
                  desc: `Found vertices on both sides of edge (${A.id},${B.id}); not a hull edge.`,
                  comment1: firstLine,
                  comment2: `Checking edge (${A.id},${B.id}).`,
                  comment3: 'Vertices found on both sides; not a hull edge.',
                  dividing: [{ a: A, b: B }],
                  highlightPts: [A, B],
                  sides: { left: leftSoFar.slice(), right: rightSoFar.slice() },
                  major: true
                });
                invalid = true;
                break;
              }
            }

            if (!invalid) {
              // All points on one side (or collinear)
              const key = `${Math.min(A.id,B.id)}-${Math.max(A.id,B.id)}`;
              if (!hullSet.has(key)) {
                hullSet.add(key);
                addStep({
                  desc: `All vertices lie on one side (or collinear); edge (${A.id},${B.id}) is on the hull.`,
                  comment1: firstLine,
                  comment2: `Checking edge (${A.id},${B.id}).`,
                  comment3: 'All vertices lie on one side; edge is on the hull.',
                  hullEdges: [{ a: A, b: B }],
                  highlightPts: [A, B],
                  sides: { left: leftSoFar.slice(), right: rightSoFar.slice() },
                  major: true
                });
              }
            }
          }
        }

        addStep({
          desc: 'Convex hull complete.',
          comment1: 'Convex hull complete.',
          comment2: '',
          comment3: '',
          major: true
        });
      }

      // Rendering
      function drawLine(a, b, color, width = 1, dash = []) {
        ctx.save();
        ctx.setLineDash(dash);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.restore();
      }

      function drawPoint(p, color = COLORS.points, r = 3) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        ctx.stroke();
        // ensure context is restored
        ctx.restore();
      }

      function drawInfiniteLine(a, b, color, width = 1, dash = []) {
        const w = (state.view && state.view.logicalW) || canvas.clientWidth || canvas.width;
        const h = (state.view && state.view.logicalH) || canvas.clientHeight || canvas.height;
        const x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;
        const dx = x2 - x1, dy = y2 - y1;
        const pts = [];
        function addIfWithin(x, y) {
          if (x >= 0 && x <= w && y >= 0 && y <= h) pts.push({ x, y });
        }
        if (Math.abs(dx) > 1e-9) {
          let t = (0 - x1) / dx; addIfWithin(0, y1 + t * dy);
          t = (w - x1) / dx; addIfWithin(w, y1 + t * dy);
        }
        if (Math.abs(dy) > 1e-9) {
          let t = (0 - y1) / dy; addIfWithin(x1 + t * dx, 0);
          t = (h - y1) / dy; addIfWithin(x1 + t * dx, h);
        }
        // dedupe close points
        const uniq = [];
        for (const p of pts) {
          if (!uniq.some(q => Math.hypot(q.x - p.x, q.y - p.y) < 1)) uniq.push(p);
        }
        if (uniq.length >= 2) {
          drawLine(uniq[0], uniq[1], color, width, dash);
        } else {
          drawLine(a, b, color, width, dash);
        }
      }

      // Draw extended edge with thin line outside segment and thicker over the segment
      function drawExtendedEdge(a, b, color) {
        ctx.save();
        ctx.globalAlpha = 0.6;             // de-emphasize the infinite extension
        drawInfiniteLine(a, b, color, 1, [6, 6]);
        ctx.restore();
        // emphasize the actual segment
        drawLine(a, b, color, 3, [6, 6]);
      }

      function drawLabel(p, text, color = '#111') {
        ctx.save();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textBaseline = 'bottom';
        ctx.textAlign = 'left';
        // light text halo for contrast
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 3;
        const x = p.x + 6;
        const y = p.y - 6;
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.restore();
      }

      function collectHullEdgesUpTo(stepIndex) {
        const edges = [];
        for (let i = 0; i <= stepIndex && i < state.steps.length; i++) {
          const s = state.steps[i];
          if (s.hullEdges) edges.push(...s.hullEdges);
        }
        return edges;
      }

      function render() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.steps.length === 0) {
          stepInfoEl.textContent = 'Step 0 / 0';
          return;
        }

        const i = Math.max(0, Math.min(state.current, state.steps.length - 1));
        const step = state.steps[i];

        // Persistent hull edges discovered so far
        const hullEdges = collectHullEdgesUpTo(i);
        for (const e of hullEdges) drawLine(e.a, e.b, COLORS.hull, 3);

        // Current edge under test — thin infinite extension + thicker segment
        for (const e of step.dividing) drawExtendedEdge(e.a, e.b, COLORS.current);

        // Candidate visualization dotted (per-step only)
        for (const d of step.distances) drawLine(d.p, d.foot, COLORS.distance, 1.5, [2, 6]);

        // Draw base points after lines so vertices appear above edges
        for (const p of state.points) drawPoint(p, COLORS.points, 3);

        // Side-colored points accumulated so far for the current edge
        if (step.sides) {
          const left = step.sides.left || [];
          const right = step.sides.right || [];
          for (const p of left) drawPoint(p, COLORS.leftSide, 4.5);
          for (const p of right) drawPoint(p, COLORS.rightSide, 4.5);
        }

        // Highlight points for this step
        if (step.highlightPts) {
          for (const p of step.highlightPts) drawPoint(p, COLORS.highlight, 4);
        }

        // Add numeric labels next to vertices mentioned this step
        const labeled = new Set();
        function labelPoint(p, col) {
          const key = p.id;
          if (labeled.has(key)) return; labeled.add(key);
          drawLabel(p, String(p.id), col);
        }
        for (const e of (step.dividing || [])) { labelPoint(e.a); labelPoint(e.b); }
        for (const e of (step.sublines || [])) { labelPoint(e.a, '#225'); labelPoint(e.b, '#225'); }
        for (const d of (step.distances || [])) { labelPoint(d.p, '#603'); }
        for (const p of (step.highlightPts || [])) { labelPoint(p, COLORS.highlight); }

        const c1 = step.comment1 || '';
        const c2 = step.comment2 || '';
        const c3 = step.comment3 || '';
        // Show exactly three lines to keep control height stable.
        // Line 1 combines the step counter with the first comment line.
        stepInfoEl.textContent = `Step ${i + 1} / ${state.steps.length} — ${c1}\n${c2}\n${c3}`;
      }

      // Playback controls
      function stop() {
        if (state.timer) {
          clearInterval(state.timer);
          state.timer = null;
        }
        playBtn.textContent = 'Play';
      }
      function play() {
        if (state.timer) { stop(); return; }
        playBtn.textContent = 'Pause';
        // ms
        const baseDelay = 750;
        const spd = parseInt(speedEl.value, 10) || 1;
        const delay = Math.max(16, baseDelay / spd);
        state.timer = setInterval(() => {
          if (state.current >= state.steps.length - 1) {
            stop();
            return;
          }
          state.current++;
          render();
        }, delay);
      }

      // Events
      speedEl.addEventListener('change', () => {
        // if playing, restart with new speed
        if (state.timer) { stop(); play(); }
      });

      generateBtn.addEventListener('click', () => {
        stop();
        // ensure size before generating
        resizeCanvas();
        // Reset logical coordinate system to current CSS size
        state.view.logicalW = canvas.clientWidth || 900;
        state.view.logicalH = canvas.clientHeight || 520;
        state.points = generatePoints(getPointCount());
        // Keep points within view with a margin
        (function(){
          const w = state.view.logicalW; const h = state.view.logicalH;
          const maxX = Math.max(1, w - EDGE_MARGIN); const maxY = Math.max(1, h - EDGE_MARGIN);
          for (const p of state.points) { p.x = Math.max(EDGE_MARGIN, Math.min(maxX, p.x)); p.y = Math.max(EDGE_MARGIN, Math.min(maxY, p.y)); }
        })();
        state.current = 0;
        bruteHull(state.points);
        render();
      });

      prevBtn.addEventListener('click', () => {
        stop();
        state.current = Math.max(0, state.current - 1);
        render();
      });

      nextBtn.addEventListener('click', () => {
        stop();
        state.current = Math.min(state.steps.length - 1, state.current + 1);
        render();
      });

      // (Major-step navigation removed for brute-force demo)

      playBtn.addEventListener('click', play);

      // Init
      function init() {
        resizeCanvas();
        // Establish logical coordinate system based on current CSS size
        state.view.logicalW = canvas.clientWidth || 900;
        state.view.logicalH = canvas.clientHeight || 520;
        state.points = generatePoints(getPointCount());
        bruteHull(state.points);
        render();
      }
      init();
    })();
  </script>
</body>
</html>
