<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brute-Force Polynomial Evaluation Demo</title>

  <script src="../../../scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">

  <style>
    .polynomial {
      margin-bottom: 0.5em;
      font-size: 1.2em;
    }
    .term {
      padding: 0 0.2em;
    }
    .term.current {
      background-color: #fffb91;
      font-weight: bold;
    }
    table {
      border-collapse: collapse;
      margin-top: 1em;
      width: auto;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.4em;
      text-align: center;
      font-family: monospace;
    }
    th {
      background: #f0f0f0;
    }
    .controls {
      margin-bottom: 1em;
    }
    .comment {
      margin-top: 0.5em;
      font-style: italic;
      min-height: 2em; /* space for two lines */
    }
    .stats {
      margin-top: 0.5em;
      font-style: italic;
      min-height: 1em;
    }
    .highlight-cell {
      background-color: #fffb91;
    }
    button {
      padding: 0.3em 0.6em;
      margin-left: 0.5em;
      font-size: 1em;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
  </style>
</head>
<body>
  <div class="demo-container">
    <h2>Brute-Force Polynomial Evaluation</h2>

    <div class="controls">
      <label>
        <strong>Enter x:</strong>
        <input id="x-input" type="number" value="2">
      </label>
      <button id="prev-btn" disabled>Previous</button>
      <button id="next-btn">Next</button>
    </div>

    <div class="polynomial" id="poly-display">
      <!-- Polynomial with superscripts will be shown here -->
    </div>

    <div class="comment" id="comment">
      <br>
    </div>
    <div class="stats" id="stats">
      <!-- Shows total multiplications/additions -->
    </div>

    <table id="step-table">
      <thead>
        <tr>
          <th>i (term index)</th>
          <th>term = a<sub>i</sub>·x<sup>i</sup></th>
          <th>result</th>
          <th>#mult</th>
          <th>#add</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be appended here -->
      </tbody>
    </table>
  </div>

  <script>
    // 6th-degree polynomial: [1, -2, 3, -4, 5, -6, 7]
    // Represents: 1 - 2x + 3x^2 - 4x^3 + 5x^4 - 6x^5 + 7x^6
    const coefficients = [1, -2, 3, -4, 5, -6, 7];

    // DOM elements
    const polyDisplay = document.getElementById('poly-display');
    const stepTableBody = document.querySelector('#step-table tbody');
    const xInput = document.getElementById('x-input');
    const nextBtn = document.getElementById('next-btn');
    const prevBtn = document.getElementById('prev-btn');
    const commentDiv = document.getElementById('comment');
    const statsDiv = document.getElementById('stats');

    // Event structure
    let events = [];          // array of event objects
    let pointer = -1;         // current event index
    let termToSpan = [];      // map nonzero term index → <span> element

    // Build polynomial HTML with signs and <sup>
    function buildPolynomialHTML(coeffs) {
      const termStrings = [];
      for (let i = 0; i < coeffs.length; i++) {
        const a = coeffs[i];
        if (a === 0) continue;
        let sign = '';
        if (termStrings.length > 0) {
          sign = (a > 0) ? '+ ' : '- ';
        } else {
          sign = (a < 0) ? '- ' : '';
        }
        const absA = Math.abs(a);
        let term = '';
        if (i === 0) {
          term = `${absA}`;
        } else {
          term = (absA !== 1 ? `${absA}` : '') + 'x' + (i > 1 ? `<sup>${i}</sup>` : '');
        }
        termStrings.push(sign + term);
      }
      return termStrings;
    }

    // Render polynomial and track spans
    function renderPolynomial() {
      polyDisplay.innerHTML = '';
      const termStrings = buildPolynomialHTML(coefficients);
      termToSpan = [];
      termStrings.forEach((ts, idx) => {
        const span = document.createElement('span');
        span.className = 'term';
        span.innerHTML = ts;
        span.setAttribute('data-nz-index', idx);
        termToSpan[idx] = span;
        polyDisplay.appendChild(span);
        if (idx < termStrings.length - 1) {
          polyDisplay.appendChild(document.createTextNode(' '));
        }
      });
    }

    // Build event list based on current x
    function buildEvents(x) {
      events = [];
      let cumulative = 0;
      let rowIdx = -1;
      // Identify nonzero indices
      const nonzeroIndices = [];
      for (let i = 0; i < coefficients.length; i++) {
        if (coefficients[i] !== 0) nonzeroIndices.push(i);
      }

      nonzeroIndices.forEach((i, nzIdx) => {
        const coeff = coefficients[i];
        // Create new row with initial term = coefficient
        rowIdx++;
        events.push({
          type: 'createRow',
          rowIdx,
          termIdx: nzIdx,
          i,
          initialTerm: coeff,
          desc: `Start i=${i}, term=${coeff}`
        });

        // Multiplication steps
        let prevTerm = coeff;
        let multCount = 0;
        for (let j = 1; j <= i; j++) {
          const term = prevTerm * x;
          multCount++;
          events.push({
            type: 'updateMult',
            rowIdx,
            i,
            prevTerm,
            x,
            term,
            multCount,
            total: cumulative,
            totalMultSteps: i,
            desc: `Multiply x: ${prevTerm} * ${x} = ${term} (multiplication ${multCount} of ${i})`
          });
          prevTerm = term;
        }

        // Addition step
        const term = prevTerm;
        const prevTotal = cumulative;
        cumulative += term;
        events.push({
          type: 'updateAdd',
          rowIdx,
          i,
          prevTotal,
          term,
          total: cumulative,
          addCount: 1,
          desc: `Add term to result: ${prevTotal} + ${term} = ${cumulative}`
        });
      });

      // Final event: done with answer
      events.push({
        type: 'done',
        final: events.length > 1 ? events[events.length - 2].total : 0,
        desc: `All terms processed. Answer is ${events.length > 1 ? events[events.length - 2].total : 0}`
      });
    }

    // Rebuild display up to current pointer
    function rebuildDisplay() {
      // 1) CLEAR ALL EXISTING HIGHLIGHTS BEFORE REBUILDING ANY ROWS
      document.querySelectorAll('.highlight-cell').forEach(td => {
        td.classList.remove('highlight-cell');
      });
      document.querySelectorAll('.term.current').forEach(span => {
        span.classList.remove('current');
      });

      // 2) WIPE OUT THE TABLE BODY COMPLETELY
      stepTableBody.innerHTML = '';

      // 3) REBUILD UP TO pointer
      const rows = [];
      let totalMult = 0;
      let totalAdd = 0;
      let lastHighlight = null;   // we will re‐apply exactly one highlight at the end

      for (let idx = 0; idx <= pointer; idx++) {
        const ev = events[idx];
        switch (ev.type) {
          case 'createRow': {
            const { rowIdx, termIdx, i, initialTerm } = ev;

            // 3a) Highlight the new polynomial term
            document.querySelectorAll('.term.current').forEach(el =>
              el.classList.remove('current')
            );
            termToSpan[termIdx].classList.add('current');

            // 3b) Build the new <tr> (no intermediate highlight here)
            const tr = document.createElement('tr');

            // i cell
            const tdI = document.createElement('td');
            tdI.textContent = i;
            tr.appendChild(tdI);

            // term cell (coefficient) – we do NOT highlight here
            const tdTerm = document.createElement('td');
            tdTerm.textContent = initialTerm;
            tr.appendChild(tdTerm);

            // result cell (blank for now)
            const tdRes = document.createElement('td');
            tdRes.textContent = '';
            tr.appendChild(tdRes);

            // multCount cell
            const tdMult = document.createElement('td');
            tdMult.textContent = '';
            tr.appendChild(tdMult);

            // addCount cell
            const tdAdd = document.createElement('td');
            tdAdd.textContent = '';
            tr.appendChild(tdAdd);

            rows[rowIdx] = tr;
            stepTableBody.appendChild(tr);

            // 3c) Remember to highlight this “term” cell at the very end:
            lastHighlight = { rowIdx, cellIdx: 1 };
            break;
          }

          case 'updateMult': {
            const { rowIdx, term, multCount } = ev;
            totalMult++;

            const tr = rows[rowIdx];
            const cells = tr.querySelectorAll('td');

            // Update term text and #mult (no intermediate highlight)
            cells[1].textContent = term;
            cells[3].textContent = multCount;

            // Track highlight: term cell at the very end
            lastHighlight = { rowIdx, cellIdx: 1 };
            break;
          }

          case 'updateAdd': {
            const { rowIdx, total, addCount } = ev;
            totalAdd++;

            const tr = rows[rowIdx];
            const cells = tr.querySelectorAll('td');

            // Update result text and #add (no intermediate highlight)
            cells[2].textContent = total;
            cells[4].textContent = addCount;

            // Track highlight: result cell at the very end
            lastHighlight = { rowIdx, cellIdx: 2 };
            break;
          }

          case 'done':
            break;
        }
      }

      // 4) RE‐APPLY exactly ONE highlight (the one pointed to by lastHighlight)
      if (lastHighlight) {
        const tr = rows[lastHighlight.rowIdx];
        const cell = tr.querySelectorAll('td')[ lastHighlight.cellIdx ];
        cell.classList.add('highlight-cell');
      }

      // 5) UPDATE COMMENT / STATS / BUTTONS
      if (pointer < 0) {
        commentDiv.innerHTML = '<br>';
      } else {
        commentDiv.innerHTML = events[pointer].desc + '<br>';
      }
      statsDiv.textContent = `Total multiplications: ${totalMult}, Total additions: ${totalAdd}`;
      prevBtn.disabled = (pointer <= -1);
      nextBtn.disabled = (pointer >= events.length - 1);
    }

    // Initialize demo
    function initDemo() {
      renderPolynomial();
      const x = parseFloat(xInput.value) || 0;
      buildEvents(x);
      pointer = -1;
      rebuildDisplay();
    }

    // Event listeners
    nextBtn.addEventListener('click', () => {
      if (pointer < events.length - 1) {
        pointer++;
        rebuildDisplay();
      }
    });
    prevBtn.addEventListener('click', () => {
      if (pointer > -1) {
        pointer--;
        rebuildDisplay();
      }
    });
    xInput.addEventListener('change', initDemo);

    // On load
    initDemo();
  </script>
</body>
</html>
