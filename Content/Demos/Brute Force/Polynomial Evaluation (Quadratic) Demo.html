<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brute-Force Polynomial Evaluation Demo</title>

 <script src="/Algorithms/scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/demo.css">

  <style>
    .polynomial {
      margin-bottom: 0.5em;
      font-size: 1.2em;
    }
    .term {
      padding: 0 0.2em;
    }
    .term.current {
      background-color: #fffb91;
      font-weight: bold;
    }
    table {
      border-collapse: collapse;
      margin-top: 1em;
      width: auto;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.4em;
      text-align: center;
      font-family: monospace;
    }
    th {
      background: #f0f0f0;
    }
    .controls {
      margin-bottom: 1em;
    }
    .comment {
      margin-top: 0.5em;
      font-style: italic;
      min-height: 2em; /* space for two lines */
    }
    .stats {
      margin-top: 0.5em;
      font-style: italic;
      min-height: 1em;
    }
    .highlight-cell {
      background-color: #fffb91;
    }

    /* Styles for Play/Pause and Speed controls */
    #play {
      margin-left: 0.5em;
    }
    #speed {
      margin-left: 0.25em;
    }

    /* Scrollable table container */
    .table-container {
      /* Responsive purely via CSS: adjusts with viewport changes */
      max-height: 70vh;
      min-height: 300px;
      overflow-y: auto;
      border: 1px solid #eee;
      padding: 2px;
      margin-top: 8px;
      background: #fff;
      box-sizing: border-box;
      width: 100%;
      -webkit-overflow-scrolling: touch;
    }

    /* Sticky table header within scroll pane */
    #step-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f0f0f0; /* re-assert to cover underlay */
    }
    
  </style>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DQ5LVZVFDC');
</script>
</head>
<body class = "no-tooltips">
  <div class="demo-container">
    <h2>Polynomial Evaluation (Brute-Force Quadratic)</h2>


    <style>
      .input-row {
        margin-bottom: 16px; /* ← adjust as needed */
      }
    </style>
    
    <div class="controls">
      <!-- (1) NEW: coefficients input + button, then Enter x, all on one line -->
      <div class="input-row" style="display: flex; align-items: center; gap: 0.75em;">
        <label>
          <strong>Coefficients:</strong>
          <input
            id="coeff-input"
            type="text"
            value="1,-2,3,-4,5,-6,7"
            size="30"
            placeholder="e.g. 1,-2,3,-4,5,-6,7"
          >
        </label>
        <button id="create-coeffs-btn">Use Coefficients</button>
  
        <!-- keep Enter x on the same row, spaced a bit from Create Coefficients -->
        <label style="margin-left: 1.5em;">
          <strong>Enter x:</strong>
          <input id="x-input" type="number" value="2" style="width: 4em">
        </label>
      </div>
  
      <!-- (2) unchanged: play/next/previous buttons, etc. -->
      <div class="button-row">
        <button id="prev-btn" disabled>Previous</button>
        <button id="next-btn">Next</button>
        <button id="play">Play</button>
        <label for="speed">Speed:</label>
        <select id="speed">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="4">4×</option>
        </select>
      </div>
    </div>
  
    

    <div class="polynomial" id="poly-display">
      <!-- Polynomial with superscripts will be shown here -->
    </div>

    <div class="comment" id="comment">
      <br>
    </div>
    <div class="stats" id="stats">
      <!-- Shows total multiplications/additions -->
    </div>

    <div class="table-container">
    <table id="step-table">
      <thead>
        <tr>
          <th>i</th>
          <th>computation</th>
          <th>result</th>
          <th>#mult</th>
          <th>#add</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be appended here -->
      </tbody>
    </table>
    </div>
  </div>

  <script>
    // 6th-degree polynomial: [1, -2, 3, -4, 5, -6, 7]
    // Represents: 1 - 2x + 3x^2 - 4x^3 + 5x^4 - 6x^5 + 7x^6
    let coefficients = [1, -2, 3, -4, 5, -6, 7];


    // DOM elements
    const polyDisplay     = document.getElementById('poly-display');
    const stepTableBody   = document.querySelector('#step-table tbody');
    const xInput          = document.getElementById('x-input');
    const nextBtn         = document.getElementById('next-btn');
    const prevBtn         = document.getElementById('prev-btn');
    const commentDiv      = document.getElementById('comment');
    const statsDiv        = document.getElementById('stats');
    const playBtn         = document.getElementById('play');
    const speedSelect     = document.getElementById('speed');

    // ─── (A) NEW: “Create Coefficients” listener ───
    const coeffInput      = document.getElementById('coeff-input');
    const createCoeffsBtn = document.getElementById('create-coeffs-btn');

    createCoeffsBtn.addEventListener('click', () => {
      const parsed = coeffInput.value
        .split(',')
        .map(s => parseFloat(s.trim()))
        .filter(n => !isNaN(n));

      if (parsed.length > 0) {
        coefficients = parsed;
        initDemo();
      } else {
        alert('Please enter at least one valid numeric coefficient, separated by commas.');
      }
    });
    // ───────────────────────────────────────────────────

    // Event structure
    let events = [];
    let pointer = -1;
    let lastPointer = -1; // for auto-scroll detection
    let termToSpan = [];

    // Play/Pause state
    let playing = false;
    let intervalId = null;

// … rest of your code (renderPolynomial, buildEvents, rebuildDisplay, initDemo, etc.) …


    // Build polynomial HTML with signs and <sup>
    function buildPolynomialHTML(coeffs) {
      const termStrings = [];
      for (let i = 0; i < coeffs.length; i++) {
        const a = coeffs[i];
        if (a === 0) continue;
        let sign = '';
        if (termStrings.length > 0) {
          sign = (a > 0) ? '+ ' : '- ';
        } else {
          sign = (a < 0) ? '- ' : '';
        }
        const absA = Math.abs(a);
        let term = '';
        if (i === 0) {
          term = `${absA}`;
        } else {
          term = (absA !== 1 ? `${absA}` : '') + 'x' + (i > 1 ? `<sup>${i}</sup>` : '');
        }
        termStrings.push(sign + term);
      }
      return termStrings;
    }

    // Render polynomial and track spans
    function renderPolynomial() {
      polyDisplay.innerHTML = '';
      const termStrings = buildPolynomialHTML(coefficients);
      termToSpan = [];
      termStrings.forEach((ts, idx) => {
        const span = document.createElement('span');
        span.className = 'term';
        span.innerHTML = ts;
        span.setAttribute('data-nz-index', idx);
        termToSpan[idx] = span;
        polyDisplay.appendChild(span);
        if (idx < termStrings.length - 1) {
          polyDisplay.appendChild(document.createTextNode(' '));
        }
      });
    }

    // Build event list based on current x
    function buildEvents(x) {
      events = [];
      let cumulative = 0;

      // Global initialization step (explicit)
      events.push({
        type: 'init',
        computation: 'Initialize: result = 0; power resets per term',
        resultAfter: 0,
        multCount: 0,
        addCount: 0,
        desc: 'Initialize result to 0.'
      });

      // Identify nonzero indices
      const nonzeroIndices = [];
      for (let i = 0; i < coefficients.length; i++) {
        if (coefficients[i] !== 0) nonzeroIndices.push(i);
      }

      nonzeroIndices.forEach((i, nzIdx) => {
        const coeff = coefficients[i];

        // Create term start event
        events.push({
          type: 'createRow',
          rowIdx: nzIdx,
          termIdx: nzIdx,
          i,
          power: 1,
          desc: `Start term i = ${i}: power = 1`
        });

        // Compute power = x^i
        let power = 1;
        let multCount = 0;
        for (let j = 0; j < i; j++) {
          const prevPower = power;
          power *= x;
          multCount++;
          events.push({
            type: 'updatePower',
            rowIdx: nzIdx,
            termIdx: nzIdx,
            i,
            prevPower,
            x,
            power,
            multCount,
            total: cumulative,
            totalMultSteps: i + 1,
            desc: `power = ${prevPower} * ${x} = ${power}  (step ${multCount} of ${i} to build x^${i})`
          });
        }

        // Multiply by coefficient and add result in one step
        const term = coeff * power;
        multCount++;
        const prevTotal = cumulative;
        cumulative += term;
        events.push({
          type: 'updateAdd',
          rowIdx: nzIdx,
          termIdx: nzIdx,
          i,
          prevTotal,
          term,
          power,
          coeff,
          multCount,      // cumulative for term
          total: cumulative,
          addCount: 1,
          desc: `term = a[${i}] * power = ${coeff} * ${power} = ${term}<br>result = ${prevTotal} + ${term} = ${cumulative}`
        });
      });

      // Final event: done with answer
      events.push({
        type: 'done',
        final: cumulative,
        desc: `All terms processed. Answer is ${cumulative}`
      });
    }

    // Rebuild display up to current pointer
    // Height management: try to size relative to top window when embedded
    function setTableContainerHeight() {
      const container = document.querySelector('.table-container');
      if (!container) return;

      let topWin = window;
      try {
        if (window.top && window.top !== window) topWin = window.top;
      } catch (e) { /* cross-origin: stay within iframe */ }

      let viewportH = 0;
      try {
        viewportH = (topWin.visualViewport && topWin.visualViewport.height) || topWin.innerHeight || window.innerHeight;
      } catch (e) {
        viewportH = window.innerHeight;
      }

      // Compute container's offset from the top-level viewport
      let offsetTop = container.getBoundingClientRect().top;
      try {
        if (topWin !== window && window.frameElement && window.frameElement.getBoundingClientRect) {
          const iframeRect = window.frameElement.getBoundingClientRect();
          offsetTop += iframeRect.top;
        }
      } catch (e) { /* ignore if cross-origin */ }

      const footerPad = 16;
      const available = Math.max(0, Math.floor(viewportH - offsetTop - footerPad));
      const target = Math.floor(viewportH * 0.70);
      const heightPx = Math.max(300, Math.min(target, available));
      container.style.height = heightPx + 'px';
    }

    function rebuildDisplay() {
      // Clear table and highlights
      stepTableBody.innerHTML = '';
      document.querySelectorAll('.term.current').forEach(el => el.classList.remove('current'));

      let totalMult = 0;
      let totalAdd = 0;

      for (let idx = 0; idx <= pointer; idx++) {
        const ev = events[idx];

        if (ev.type === 'init') {
          const tr = document.createElement('tr');
          const tdI = document.createElement('td'); tdI.textContent = '—';
          const tdC = document.createElement('td'); tdC.innerHTML = ev.computation;
          const tdR = document.createElement('td'); tdR.textContent = ev.resultAfter;
          const tdM = document.createElement('td'); tdM.textContent = '0';
          const tdA = document.createElement('td'); tdA.textContent = '0';
          tr.appendChild(tdI); tr.appendChild(tdC); tr.appendChild(tdR); tr.appendChild(tdM); tr.appendChild(tdA);
          stepTableBody.appendChild(tr);
          if (idx === pointer) tdC.classList.add('highlight-cell');
          continue;
        }

        if (ev.type === 'createRow') {
          // highlight current term
          const span = termToSpan[ev.termIdx];
          if (span && idx === pointer) span.classList.add('current');

          const tr = document.createElement('tr');
          const tdI = document.createElement('td'); tdI.textContent = ev.i;
          const tdC = document.createElement('td'); tdC.innerHTML = `Start term i=${ev.i}: power = 1`;
          const tdR = document.createElement('td'); tdR.textContent = '';
          const tdM = document.createElement('td'); tdM.textContent = '0';
          const tdA = document.createElement('td'); tdA.textContent = '0';
          tr.appendChild(tdI); tr.appendChild(tdC); tr.appendChild(tdR); tr.appendChild(tdM); tr.appendChild(tdA);
          stepTableBody.appendChild(tr);
          if (idx === pointer) tdC.classList.add('highlight-cell');
          continue;
        }

        if (ev.type === 'updatePower') {
          totalMult += 1;
          const span = termToSpan[ev.termIdx];
          if (span && idx === pointer) span.classList.add('current');

          const tr = document.createElement('tr');
          const tdI = document.createElement('td'); tdI.textContent = ev.i;
          const tdC = document.createElement('td'); tdC.innerHTML = `power = ${ev.prevPower} * ${ev.x} = ${ev.power}`;
          const tdR = document.createElement('td'); tdR.textContent = ev.total;
          const tdM = document.createElement('td'); tdM.textContent = '1';
          const tdA = document.createElement('td'); tdA.textContent = '0';
          tr.appendChild(tdI); tr.appendChild(tdC); tr.appendChild(tdR); tr.appendChild(tdM); tr.appendChild(tdA);
          stepTableBody.appendChild(tr);
          if (idx === pointer) tdC.classList.add('highlight-cell');
          continue;
        }

        if (ev.type === 'updateAdd') {
          totalMult += 1; // coefficient * power
          totalAdd  += 1;
          const span = termToSpan[ev.termIdx];
          if (span && idx === pointer) span.classList.add('current');

          const tr = document.createElement('tr');
          const tdI = document.createElement('td'); tdI.textContent = ev.i;
          const tdC = document.createElement('td'); tdC.innerHTML = ev.desc; // already two lines
          const tdR = document.createElement('td'); tdR.textContent = ev.total;
          const tdM = document.createElement('td'); tdM.textContent = '1';
          const tdA = document.createElement('td'); tdA.textContent = '1';
          tr.appendChild(tdI); tr.appendChild(tdC); tr.appendChild(tdR); tr.appendChild(tdM); tr.appendChild(tdA);
          stepTableBody.appendChild(tr);
          if (idx === pointer) tdC.classList.add('highlight-cell');
          continue;
        }

        if (ev.type === 'done') {
          // no row; just show comment below
          continue;
        }
      }

      // Comment & stats
      const ev = pointer >= 0 ? events[pointer] : null;
      if (!ev) {
        commentDiv.innerHTML = '<br>';
      } else if (ev.type === 'done') {
        commentDiv.innerHTML = `Done! Final answer = ${ev.final}`;
      } else {
        commentDiv.innerHTML = ev.desc;
      }
      statsDiv.textContent = `Total multiplications: ${totalMult}, Total additions: ${totalAdd}`;
      prevBtn.disabled = (pointer <= -1);
      nextBtn.disabled = (pointer >= events.length - 1);

      // Auto-scroll to bottom only when advancing
      if (pointer >= 0 && pointer > lastPointer) {
        const container = document.querySelector('.table-container');
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      }
      lastPointer = pointer;

      // Recompute height in case layout/viewport changed
      setTableContainerHeight();
    }

    // Initialize demo
    function initDemo() {
      renderPolynomial();
      const x = parseFloat(xInput.value) || 0;
      buildEvents(x);
      pointer = -1;
      lastPointer = -1;
      rebuildDisplay();
      // Ensure height matches current viewport
      setTableContainerHeight();
    }

    // Event listeners
    nextBtn.addEventListener('click', () => {
      if (pointer < events.length - 1) {
        pointer++;
        rebuildDisplay();
      }
    });
    prevBtn.addEventListener('click', () => {
      if (pointer > -1) {
        pointer--;
        rebuildDisplay();
      }
    });
    xInput.addEventListener('change', initDemo);

    // Playback (Play/Pause & Speed)
    playBtn.addEventListener('click', () => {
      if (playing) {
        // Pause
        playing = false;
        playBtn.textContent = 'Play';
        clearInterval(intervalId);
        intervalId = null;
      } else {
        // Start playing
        playing = true;
        playBtn.textContent = 'Pause';
        const speed = parseInt(speedSelect.value, 10);
        const delay = 1000 / speed;
        intervalId = setInterval(() => {
          if (pointer < events.length - 1) {
            pointer++;
            rebuildDisplay();
          } else {
            // Stop at the end
            playing = false;
            playBtn.textContent = 'Play';
            clearInterval(intervalId);
            intervalId = null;
          }
        }, delay);
      }
    });

    speedSelect.addEventListener('change', () => {
      if (playing) {
        clearInterval(intervalId);
        playing = false;
        playBtn.textContent = 'Play';
        // Restart playback at new speed
        playBtn.click();
      }
    });

    // On load
    initDemo();
    // Adjust height with viewport changes (best effort)
    window.addEventListener('resize', setTableContainerHeight);
    window.addEventListener('orientationchange', setTableContainerHeight);
    try {
      if (window.top && window.top !== window && window.top.visualViewport) {
        window.top.visualViewport.addEventListener('resize', setTableContainerHeight);
      } else if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', setTableContainerHeight);
      }
    } catch (e) { /* cross-origin */ }
  </script>
</body>
</html>
