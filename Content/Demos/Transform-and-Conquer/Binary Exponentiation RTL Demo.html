<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Right-to-Left Binary Exponentiation Demo (NEW)</title>

  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">

  <style>
    /* Controls */
    .controls { margin-bottom: 1em; }
    .input-row { margin-bottom: 12px; display: flex; align-items: center; gap: 1em; flex-wrap: wrap; }
    .button-row { display: flex; align-items: center; gap: 0.5em; flex-wrap: wrap; }
    button { padding: 0.3em 0.6em; font-size: 1em; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: default; }
    #speed { margin-left: 0.25em; }

    /* Table */
    table { border-collapse: collapse; margin-top: 0.5em; width: auto; }
    th, td { border: 1px solid #ccc; padding: 0.4em; text-align: center; font-family: monospace; }
    th { background: #f0f0f0; }

    /* Highlights for actions */
    .highlight-cell { background-color: #fffb91; }
    .square-step { background-color: #e8f2ff; }   /* blue-ish for squaring pow */
    .mul-step { background-color: #e8ffe8; }      /* green-ish for result *= pow */

    /* Comment & stats */
    .comment { margin-top: 0.5em; font-style: italic; min-height: 2em; }
    .stats { margin-top: 0.25em; font-style: italic; min-height: 1em; }

    /* Bits strip */
    .bits-strip { font-size: 1.1em; letter-spacing: 1px; margin-bottom: 0; }

    /* Pseudocode box */
    .pc-box { margin-top: 10px; background: #fcfcff; border: 1px solid #dfe3ff; padding: 8px 10px; }
    .pc-line { font-family: monospace; padding: 2px 4px; }
    .pc-inner { padding-left: 1.5em; display: block; }
    .pc-active { background: #fff7cc; outline: 1px solid #e0b000; }

    /* Make some table columns bold for quick scanning */
    #step-table th:nth-child(1),
    #step-table td:nth-child(1),
    #step-table th:nth-child(3),
    #step-table td:nth-child(3),
    #step-table th:nth-child(4),
    #step-table td:nth-child(4) { font-weight: bold; }
  </style>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);} 
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
</head>
<body class="no-tooltips">
  <div class="demo-container">
    <h2>Binary Exponentiation (Right-to-Left)</h2>

    <div class="controls">
      <div class="input-row">
        <label>
          <strong>Base (a):</strong>
          <input id="a-input" type="number" value="3" min="0" max="99" style="width: 4em;"
            aria-label="Base a">
        </label>
        <label>
          <strong>Exponent (n):</strong>
          <input id="n-input" type="number" value="101" min="0" max="1023" style="width: 6em;"
            aria-label="Exponent n">
        </label>
        <button id="reset-btn" title="Reset to current values">Reset</button>
      </div>
      <div class="button-row">
        <button id="prev-btn" disabled title="Previous step (Left Arrow)">Previous</button>
        <button id="next-btn" title="Next step (Right Arrow)">Next</button>
        <button id="play" title="Play/Pause (Space)">Play</button>
        <label for="speed">Speed:</label>
        <select id="speed" aria-label="Playback speed">
          <option value="1">1×</option>
          <option value="2">2×</option>
          <option value="4">4×</option>
        </select>
      </div>
    </div>
    
    <div class="pc-box">
      <div class="pc-line" id="pc-while">while (n &gt; 0) {</div>
      <div class="pc-line pc-inner" id="pc-line1">if (n % 2 == 1) result *= pow;  // include current power</div>
      <div class="pc-line pc-inner" id="pc-line2">pow = pow * pow;                // square power of a</div>
      <div class="pc-line pc-inner" id="pc-line3">n = floor(n / 2);               // shift right one bit</div>
      <div class="pc-line" id="pc-close">}</div>
    </div>

    <div class="comment" id="comment" aria-live="polite"></div>
    <div class="stats" id="stats" aria-live="polite"></div>
    <div class="stats bits-strip" id="bits-display"></div>
    <div class="comment" id="final-display"></div>

    <table id="step-table">
      <thead>
        <tr>
          <th>n</th>
          <th>bit (n%2)</th>
          <th>pow = a^(2^i)</th>
          <th>result</th>
          <th>step</th>
          <th>multiplies</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div style="margin-top:8px; font-size:0.95em; color:#555;">
      Counting convention: each squaring counts as one multiply; when bit = 1, we count one extra multiply for result *= pow.
    </div>
  </div>

  <script>
    function toSuperscript(num) {
      const supMap = { '0':'⁰','1':'¹','2':'²','3':'³','4':'⁴','5':'⁵','6':'⁶','7':'⁷','8':'⁸','9':'⁹' };
      return String(num).split('').map(ch => supMap[ch] || '').join('');
    }

    // Globals & DOM
    let events = [];
    let pointer = -1;
    let playing = false;
    let intervalId = null;

    const aInput = document.getElementById('a-input');
    const nInput = document.getElementById('n-input');
    const resetBtn = document.getElementById('reset-btn');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const playBtn = document.getElementById('play');
    const speedSelect = document.getElementById('speed');
    const commentDiv = document.getElementById('comment');
    const statsDiv = document.getElementById('stats');
    const bitsDisplayDiv = document.getElementById('bits-display');
    const stepTableBody = document.querySelector('#step-table tbody');
    const finalDisplayDiv = document.getElementById('final-display');

    // Build events for RTL
    function buildExpEvents(a, n) {
      const evs = [];

      // Special case n=0: a^0 = 1, zero multiplies
      if (n === 0) {
        evs.push({ type: 'done', finalResult: 1, binaryRep: `${a}${toSuperscript(0)}`, totalMults: 0, zeroCase: true });
        return evs;
      }

      let result = 1;
      let aPower = a;       // numeric accumulator for pow
      let exponent = 1;     // 1,2,4,8,... (this is 2^i)
      let expExpr = `${a}`; // symbolic for pow column
      let totalMults = 0;
      let currentN = n;

      // First check the initial LSB
      const initialBit = currentN % 2;
      if (initialBit === 1) {
        evs.push({
          type: 'iter', n: currentN, bit: 1, aPowerVal: aPower, exponent, expExpr,
          resultComp: `bit=1 → <span class="mul-step">result = ${expExpr}</span>`,
          aPowComp: `${expExpr} = ${aPower}`,
          multCount: 0, resultAfter: aPower, totalMultsSoFar: totalMults
        });
        result = aPower;
      } else {
        evs.push({
          type: 'iter', n: currentN, bit: 0, aPowerVal: aPower, exponent, expExpr,
          resultComp: 'bit=0 → result unchanged',
          aPowComp: `${expExpr} = ${aPower}`,
          multCount: 0, resultAfter: result, totalMultsSoFar: totalMults
        });
      }

      // Loop until n becomes 1; each loop squares pow, shifts n, and maybe multiplies result
      while (currentN > 1) {
        // Square pow (one multiply)
        const prevExpExpr = expExpr;
        const newAPower = aPower * aPower; // numeric
        totalMults += 1;

        // Update pow and its symbolic exponent
        aPower = newAPower;
        exponent = exponent * 2;
        if (expExpr === `${a}`) {
          expExpr = `${expExpr}${toSuperscript(2)}`;
        } else {
          expExpr = `${a}${toSuperscript(exponent)}`;
        }

        // Shift n and check new LSB
        currentN = Math.floor(currentN / 2);
        const bitNow = currentN % 2;

        let resultCompStr = `<span class="square-step">pow = pow<sup>2</sup></span><br>`;
        let multThisIter = 1; // squaring
        if (bitNow === 1) {
          const oldResult = result;
          result = oldResult * aPower;
          resultCompStr += `<span class="mul-step">bit=1 → result *= pow</span>`;
          multThisIter += 1;
          totalMults += 1;
        } else {
          resultCompStr += 'bit=0 → skip multiply';
        }

        const aPowDisplay = `${expExpr} = ${aPower}`;
        evs.push({
          type: 'iter', n: currentN, bit: bitNow, aPowerVal: aPower, exponent, expExpr,
          prevExpExpr, resultComp: resultCompStr, aPowComp: aPowDisplay,
          multCount: multThisIter, resultAfter: result, totalMultsSoFar: totalMults
        });
      }

      // Final event
      const bits = n.toString(2).split('').map(Number); // MSB→LSB
      const weights = bits
        .map((b,i) => b ? 2 ** (bits.length - 1 - i) : null)
        .filter(Boolean)
        .sort((x,y) => y - x);
      const binRepr = weights.map(w => `${a}${toSuperscript(w)}`).join(' × ');
      evs.push({ type: 'done', finalResult: result, binaryRep: binRepr, totalMults: totalMults });
      return evs;
    }

    function rebuildAllEvents() {
      const aVal = clampInt(aInput.value, 1, 99, 3);
      const nVal = clampInt(nInput.value, 0, 1023, 101);
      aInput.value = aVal; nInput.value = nVal;
      events = buildExpEvents(aVal, nVal);
      pointer = -1;
      finalDisplayDiv.innerHTML = '';
      rebuildDisplay();
    }

    function clampInt(val, min, max, fallback) {
      let x = parseInt(val, 10);
      if (Number.isNaN(x)) x = fallback;
      if (x < min) x = min;
      if (x > max) x = max;
      return x;
    }

    function rebuildDisplay() {
      stepTableBody.innerHTML = '';
      finalDisplayDiv.innerHTML = '';

      if (pointer < 0) {
        commentDiv.innerHTML = '';
        statsDiv.textContent = '';
        bitsDisplayDiv.innerHTML = buildBitsStrip();
        prevBtn.disabled = true;
        nextBtn.disabled = false;
        setPseudocodeActive({ whileLine: false, ifLine: false, square: false, shift: false });
        return;
      }

      const ev = events[pointer];

      // Build rows up to current pointer
      for (let idx = 0; idx <= pointer; idx++) {
        const e = events[idx];
        if (e.type !== 'iter') continue;
        const tr = document.createElement('tr');

        // n
        const tdN = document.createElement('td'); tdN.textContent = e.n; tr.appendChild(tdN);
        // bit
        const tdBit = document.createElement('td'); tdBit.textContent = e.bit; tr.appendChild(tdBit);
        // pow
        const tdPow = document.createElement('td'); tdPow.textContent = e.aPowComp; tr.appendChild(tdPow);
        // result
        const tdRes = document.createElement('td'); tdRes.textContent = e.resultAfter; tr.appendChild(tdRes);
        // step text
        const tdStep = document.createElement('td'); tdStep.innerHTML = e.resultComp; tr.appendChild(tdStep);
        // multiplies this iter
        const tdCnt = document.createElement('td'); tdCnt.textContent = e.multCount; tr.appendChild(tdCnt);

        if (idx === pointer) {
          if (e.resultComp.includes('pow<sup>2</sup>')) tdStep.classList.add('square-step');
          if (e.bit === 1) tdStep.classList.add('mul-step');
        }
        stepTableBody.appendChild(tr);
      }

      if (ev.type === 'done') {
        commentDiv.innerHTML = ev.zeroCase
          ? `Done! Final answer = ${ev.finalResult} (returned 1 for n=0)<br>Binary representation: ${ev.binaryRep}`
          : `Done! Final answer = ${ev.finalResult}<br>Binary representation: ${ev.binaryRep || '—'}`;
        statsDiv.textContent = `Total multiplications: ${ev.totalMults}`;
        bitsDisplayDiv.innerHTML = buildBitsStrip();
        setPseudocodeActive({ whileLine: false, ifLine: false, square: false, shift: false });
      } else {
        // Step comment
        if (pointer === 0) {
          commentDiv.innerHTML = ev.bit === 1
            ? 'Initial LSB is 1 → include a^1 in result.'
            : 'Initial LSB is 0 → result stays 1.';
          setPseudocodeActive({ whileLine: false, ifLine: true, square: false, shift: false });
        } else {
          commentDiv.innerHTML = `Square pow; shift n; ${ev.bit === 1 ? 'then multiply result by pow.' : 'skip multiply.'}`;
          setPseudocodeActive({ whileLine: false, ifLine: ev.bit === 1, square: true, shift: true });
        }
        statsDiv.textContent = `Total multiplications so far: ${ev.totalMultsSoFar}`;
        bitsDisplayDiv.innerHTML = buildBitsStrip(pointer);
      }

      prevBtn.disabled = (pointer < 0);
      nextBtn.disabled = (pointer >= events.length - 1);
    }

    function buildBitsStrip(activeIdx = undefined) {
      // Visualize n in natural MSB→LSB order and highlight current processed bit
      const nVal = clampInt(nInput.value, 0, 1023, 19);
      const rawBits = nVal.toString(2).split('').map(Number); // MSB→LSB

      // event bits are stored per iteration in LSB→MSB order; compute which index to highlight
      const iterBits = events.filter(e => e.type === 'iter').map(e => e.bit); // LSB→MSB
      const display = rawBits.slice();
      let highlightIndex = undefined;
      if (activeIdx !== undefined && iterBits.length > 0) {
        // activeIdx 0 = first iteration (LSB), which is last in MSB→LSB display
        highlightIndex = display.length - activeIdx - 1;
      }

      const parts = display.map((b, i) => i === highlightIndex ? `<span class="highlight-cell">${b}</span>` : `${b}`);
      return `n in binary: ${parts.join('')}`;
    }

    function setPseudocodeActive({ whileLine, ifLine, square, shift }) {
      // Only highlight the lines inside the loop, not the while/closing brace
      const l1 = document.getElementById('pc-line1');
      const l2 = document.getElementById('pc-line2');
      const l3 = document.getElementById('pc-line3');
      [l1,l2,l3].forEach(el => el.classList.remove('pc-active'));
      if (ifLine) l1.classList.add('pc-active');
      if (square) l2.classList.add('pc-active');
      if (shift) l3.classList.add('pc-active');
    }

    // Controls
    nextBtn.addEventListener('click', () => { if (pointer < events.length - 1) { pointer++; rebuildDisplay(); }});
    prevBtn.addEventListener('click', () => { if (pointer > -1) { pointer--; rebuildDisplay(); }});
    playBtn.addEventListener('click', () => {
      if (playing) { playing = false; playBtn.textContent = 'Play'; clearInterval(intervalId); intervalId = null; }
      else {
        playing = true; playBtn.textContent = 'Pause';
        const speed = parseInt(speedSelect.value, 10) || 1; const delay = 1000 / speed;
        intervalId = setInterval(() => {
          if (pointer < events.length - 1) { pointer++; rebuildDisplay(); }
          else { playing = false; playBtn.textContent = 'Play'; clearInterval(intervalId); intervalId = null; }
        }, delay);
      }
    });
    speedSelect.addEventListener('change', () => { if (playing) { clearInterval(intervalId); playing = false; playBtn.textContent = 'Play'; playBtn.click(); }});
    aInput.addEventListener('change', rebuildAllEvents);
    nInput.addEventListener('change', rebuildAllEvents);
    resetBtn.addEventListener('click', rebuildAllEvents);
    // (presets removed)

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') { nextBtn.click(); e.preventDefault(); }
      else if (e.key === 'ArrowLeft') { prevBtn.click(); e.preventDefault(); }
      else if (e.code === 'Space') { playBtn.click(); e.preventDefault(); }
    });

    // Initialize
    rebuildAllEvents();
  </script>
</body>
</html>
