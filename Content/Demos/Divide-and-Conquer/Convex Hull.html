<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Convex Hull Divide-and-Conquer Algorithm Demo</title>
  <script src="../../../scripts/demoScripts.js"></script>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
  <style>
    /* Minimal inline styles to complement existing demo.css */
    .controls label { display: inline-flex; align-items: center; gap: .4rem; }
    #stepInfo { margin-left: auto; font-size: .9rem; opacity: .85; }
    .canvas-wrap { position: relative; border: 1px solid #ddd; background: #fff; }
    #ch-canvas { width: 100%; height: 520px; display: block; }
    /* Legend uses shared styles from demo.css */
  </style>
</head>
<body class="no-tooltips">
  <div class="demo-container">
    <h2>Convex Hull Divide-and-Conquer Algorithm Demo</h2>
    <div class="controls">
      <label>Points:
        <input id="pointCount" type="number" min="10" max="200" value="30" step="1" style="width: 70px;">
      </label>
      <button id="generateBtn">Generate</button>
      <br>
      <button id="prevMajorBtn" title="Jump to previous major step">Previous (major)</button>
      <button id="prevBtn">Previous</button>
      <button id="nextBtn">Next</button>
      <button id="nextMajorBtn" title="Skip detailed scans">Next (major)</button>
      <button id="playBtn">Play</button>
      <label for="speed">Speed:</label>
      <select id="speed">
        <option value="1">1×</option>
        <option value="2">2×</option>
        <option value="4">4×</option>
      </select>
      <br>
      <span id="stepInfo">Step 0 / 0</span>
    </div>
    
    <div class="canvas-wrap">
      <canvas id="ch-canvas"></canvas>
    </div>
    <div class="legend">
      <strong class="legend-label">Legend:</strong>
      <div class="legend-items">
        <span class="legend-box" style="background-color:#222"></span> Points
        <span class="legend-box" style="background-color:#27ae60"></span> Hull edges (solid)
        <span class="legend-box" style="background-color:#8e44ad"></span> Current edge (focus)
        <span class="legend-box" style="background-color:#888"></span> Other dividing (dashed)<br>
        <span class="legend-box" style="background-color:#2d7dd2"></span> Subproblem (dashed)
        <span class="legend-box" style="background-color:#ff9900"></span> Distance (dotted)
        <span class="legend-box" style="background-color:#d62728"></span> Highlighted points
      </div>
    </div>
  </div>

  <script>
    //
    // QuickHull interactive demo with step recording and playback
    //
    (function() {
      const canvas = document.getElementById('ch-canvas');
      const ctx = canvas.getContext('2d');

      const pointCountEl = document.getElementById('pointCount');
      const generateBtn = document.getElementById('generateBtn');
      const prevBtn = document.getElementById('prevBtn');
      const playBtn = document.getElementById('playBtn');
      const nextBtn = document.getElementById('nextBtn');
      const speedEl = document.getElementById('speed');
      const stepInfoEl = document.getElementById('stepInfo');
      const nextMajorBtn = document.getElementById('nextMajorBtn');
      const prevMajorBtn = document.getElementById('prevMajorBtn');

      const COLORS = {
        points: '#222',
        // generic dividing line
        dividing: '#888',
        // current focus dividing line
        current: '#8e44ad',
        // dashed
        subproblem: '#2d7dd2',
        // dotted
        distance: '#ff9900',
        // solid
        hull: '#27ae60',
        highlight: '#d62728',
        // initial minX–maxX (always visible)
        mainDividing: '#666'
      };

      const EDGE_MARGIN = 20;

      function getPointCount() {
        const v = parseInt(pointCountEl.value, 10) || 0;
        const n = Math.max(3, Math.min(200, v));
        if (n !== v) pointCountEl.value = n;
        return n;
      }

      const state = {
        points: [],
        steps: [],
        current: 0,
        timer: null,
        speed: 1,
        // {a,b} initial minX–maxX line, persistent
        mainAB: null,
        // step index from which to show mainAB
        showMainABFrom: Infinity,
        // track sizes to scale geometry only when toggling fullscreen
        view: { mode: null, normalW: 0, normalH: 0, fullscreenW: 0, fullscreenH: 0 }
      };

      // Decide canvas height:
      // - fullscreen: fill viewport minus controls
      // - normal: ~65vh clamped to [360, 640]
      function computeCanvasHeight() {
        const controlsEl = document.querySelector('.controls');
        if (document.fullscreenElement) {
          const pad = 16;
          const controlsH = controlsEl ? controlsEl.getBoundingClientRect().height : 0;
          return Math.max(300, window.innerHeight - controlsH - pad * 2);
        }
        const target = Math.round(window.innerHeight * 0.65);
        return Math.max(360, Math.min(640, target));
      }

      // Resize canvas to element size and scale stored geometry on fullscreen toggle
      function resizeCanvas() {
        // Let CSS height be driven by JS for responsiveness/fullscreen
        canvas.style.height = computeCanvasHeight() + 'px';
        const cssWidth = canvas.clientWidth;
        const cssHeight = canvas.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(cssWidth * dpr);
        canvas.height = Math.round(cssHeight * dpr);
        // If logical size is established, map logical→screen with uniform scale
        if (state.view && state.view.logicalW && state.view.logicalH) {
          const lw = state.view.logicalW; const lh = state.view.logicalH;
          const s = Math.max(0.0001, Math.min(cssWidth / lw, cssHeight / lh));
          const tx = (cssWidth - s * lw) / 2;
          const ty = (cssHeight - s * lh) / 2;
          ctx.setTransform(dpr * s, 0, 0, dpr * s, dpr * tx, dpr * ty);
          render();
          return;
        }
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        // Only scale stored geometry when switching between normal/fullscreen
        const mode = document.fullscreenElement ? 'fullscreen' : 'normal';
        const v = state.view;
        if (v.mode == null) {
          v.mode = mode;
          if (mode === 'fullscreen') { v.fullscreenW = cssWidth; v.fullscreenH = cssHeight; }
          else { v.normalW = cssWidth; v.normalH = cssHeight; }
        } else if (v.mode !== mode) {
          const fromW = v.mode === 'fullscreen' ? v.fullscreenW : v.normalW;
          const fromH = v.mode === 'fullscreen' ? v.fullscreenH : v.normalH;
          const sx = fromW ? cssWidth / fromW : 1;
          const sy = fromH ? cssHeight / fromH : 1;
          if (state.points && state.points.length && isFinite(sx) && isFinite(sy) && (Math.abs(sx - 1) > 1e-6 || Math.abs(sy - 1) > 1e-6)) {
            for (const p of state.points) { p.x *= sx; p.y *= sy; }
            for (const s of state.steps) {
              if (s && s.distances) {
                for (const d of s.distances) { if (d && d.foot) { d.foot.x *= sx; d.foot.y *= sy; } }
              }
            }
          // keep all geometry within visible canvas with minimal clamp to avoid drift
          const maxX = Math.max(1, cssWidth - 1);
          const maxY = Math.max(1, cssHeight - 1);
          for (const p of state.points) {
            p.x = Math.max(1, Math.min(maxX, p.x));
            p.y = Math.max(1, Math.min(maxY, p.y));
          }
          for (const s of state.steps) {
            if (s && s.distances) {
              for (const d of s.distances) {
                if (d && d.foot) {
                  d.foot.x = Math.max(1, Math.min(maxX, d.foot.x));
                  d.foot.y = Math.max(1, Math.min(maxY, d.foot.y));
                }
              }
            }
          }
          }
          v.mode = mode;
          if (mode === 'fullscreen') { v.fullscreenW = cssWidth; v.fullscreenH = cssHeight; }
          else { v.normalW = cssWidth; v.normalH = cssHeight; }
        } else {
          if (mode === 'fullscreen') { v.fullscreenW = cssWidth; v.fullscreenH = cssHeight; }
          else { v.normalW = cssWidth; v.normalH = cssHeight; }
        }
        render();
      }
      window.addEventListener('resize', resizeCanvas);
      document.addEventListener('fullscreenchange', resizeCanvas);

      function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

      function generatePoints(n) {
        const w = (state.view && state.view.logicalW) || canvas.clientWidth || 900;
        const h = (state.view && state.view.logicalH) || canvas.clientHeight || 520;
        const pad = EDGE_MARGIN;
        const seen = new Set();
        const pts = [];
        while (pts.length < n) {
          const x = randInt(pad, w - pad);
          const y = randInt(pad, h - pad);
          const key = `${x},${y}`;
          if (!seen.has(key)) {
            seen.add(key);
            pts.push({ id: pts.length, x, y });
          }
        }
        return pts;
      }

      // Geometry helpers
      function cross(a, b, c) { return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); }
      function distanceToLine(a, b, p) {
        const A = b.y - a.y, B = a.x - b.x, C = b.x * a.y - a.x * b.y;
        const denom = Math.hypot(A, B) || 1;
        const d = Math.abs(A * p.x + B * p.y + C) / denom;
        //
        // foot of perpendicular from p to line ab
        const abx = b.x - a.x, aby = b.y - a.y;
        const t = ((p.x - a.x) * abx + (p.y - a.y) * aby) / (abx * abx + aby * aby || 1);
        const foot = { x: a.x + t * abx, y: a.y + t * aby };
        return { d, foot };
      }
      function isLeft(a, b, p) { return cross(a, b, p) > 0; }
      function sameEdge(e1, e2) {
        if (!e1 || !e2) return false;
        const { a: a1, b: b1 } = e1, { a: a2, b: b2 } = e2;
        return (a1 === a2 && b1 === b2) || (a1 === b2 && b1 === a2);
      }

      // Step recording
      function addStep(step) {
        state.steps.push({
          desc: step.desc || '',
          // current edge being discussed [{a,b}]
          dividing: step.dividing || [],
          // new subproblem edges introduced this step
          sublines: step.sublines || [],
          // [{p, foot}]
          distances: step.distances || [],
          // [{a,b}]
          hullEdges: step.hullEdges || [],
          highlightPts: step.highlightPts || [],
          // stack of active edges [{a,b,type:'dividing'|'subline'}]
          persistent: step.persistent || [],
          // major step marker for navigation
          major: !!step.major
        });
      }

      // QuickHull with persistent-line stack
      function quickHull(points) {
        state.steps = [];
        state.mainAB = null;
        if (points.length < 2) return;

        const pts = points.slice().sort((p, q) => p.x - q.x || p.y - q.y);
        const A = pts[0], B = pts[pts.length - 1];
        // always visible
        state.mainAB = { a: A, b: B };

        // Initial step before determining endpoints
        addStep({
          desc: 'Points initialized. Click Next to find the leftmost vertex.',
          major: true
        });

        // Record explicit steps for finding min/max instead of starting there
        addStep({
          desc: `Find leftmost point (min x): vertex ${A.id}.`,
          highlightPts: [A],
          major: true
        });
        addStep({
          desc: `Find rightmost point (max x): vertex ${B.id}.`,
          highlightPts: [B],
          major: true
        });

        addStep({
          desc: 'Initial split by minX–maxX.',
          dividing: [{ a: A, b: B }],
          highlightPts: [A, B],
          // mainAB is drawn separately
          persistent: [],
          major: true
        });
        // from this step onward, show the main AB line
        state.showMainABFrom = state.steps.length - 1;

        const leftSet = pts.filter(p => isLeft(A, B, p));
        const rightSet = pts.filter(p => isLeft(B, A, p));


        // Maintain a stack of active dividing/subproblem lines
        // elements: {a,b,type:'dividing'|'subline'}
        const active = [];

        function findHull(S, A, B, label) {
          // Enter edge A->B
          active.push({ a: A, b: B, type: 'dividing' });
          const isTopLevelForSide = active.length === 1; // first edge for this side
          addStep({
            desc: `Finding ${label} hull — focus on edge (${A.id},${B.id}).`,
            dividing: [{ a: A, b: B }],
            persistent: active.slice(),
            highlightPts: isTopLevelForSide ? [A, B, ...S] : [A, B],
            major: true
          });

          if (S.length === 0) {
            // AB is a hull edge
            addStep({
              desc: `No points lie strictly outside this line; edge (${A.id},${B.id}) is on the hull.`,
              hullEdges: [{ a: A, b: B }],
              persistent: active.slice(),
              highlightPts: [A, B],
              major: true
            });
            // leave section
            active.pop();
            return;
          }

          // Farthest point from AB — show scan details
          let far = null, maxd = -1, foot = null;
          for (const p of S) {
            const { d, foot: f } = distanceToLine(A, B, p);
            // add a micro-step for this candidate
            addStep({
              desc: `Check distance from vertex ${p.id} to edge (${A.id},${B.id}).`,
              dividing: [{ a: A, b: B }],
              distances: [{ p, foot: f }],
              highlightPts: far ? [A, B, p, far] : [A, B, p],
              persistent: active.slice(),
              major: false
            });
            if (d > maxd) { maxd = d; far = p; foot = f; }
          }

          // summary step for farthest point and introduce both sublines
          addStep({
            desc: `Farthest point from edge (${A.id},${B.id}) is vertex ${far.id}. We need to explore edges (${A.id},${far.id}) and (${far.id},${B.id}).`,
            dividing: [{ a: A, b: B }],
            sublines: [{ a: A, b: far }, { a: far, b: B }],
            distances: [{ p: far, foot }],
            highlightPts: [A, far, B],
            persistent: active.slice(),
            major: true
          });

          const S1 = S.filter(p => isLeft(A, far, p));
          const S2 = S.filter(p => isLeft(far, B, p));

          // Keep BOTH sublines visible while solving both halves
          active.push({ a: A, b: far, type: 'subline' });
          active.push({ a: far, b: B, type: 'subline' });
          findHull(S1, A, far, label);
          findHull(S2, far, B, label);
          active.pop();
          active.pop();

          // Leave edge A->B section
          active.pop();
        }

        // Process lower hull first, then upper hull
        findHull(leftSet, A, B, 'lower');
        findHull(rightSet, B, A, 'upper');

        // Final step
        addStep({
          desc: 'Convex hull complete.',
          major: true
        });
      }

      // Rendering
      function drawLine(a, b, color, width = 1, dash = []) {
        ctx.save();
        ctx.setLineDash(dash);
        ctx.lineWidth = width;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
        ctx.restore();
      }

      function drawPoint(p, color = COLORS.points, r = 3) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        ctx.stroke();
        // ensure context is restored
        ctx.restore();
      }

      function drawInfiniteLine(a, b, color, width = 1, dash = []) {
        const w = (state.view && state.view.logicalW) || canvas.clientWidth || canvas.width;
        const h = (state.view && state.view.logicalH) || canvas.clientHeight || canvas.height;
        const x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;
        const dx = x2 - x1, dy = y2 - y1;
        const pts = [];
        function addIfWithin(x, y) {
          if (x >= 0 && x <= w && y >= 0 && y <= h) pts.push({ x, y });
        }
        if (Math.abs(dx) > 1e-9) {
          let t = (0 - x1) / dx; addIfWithin(0, y1 + t * dy);
          t = (w - x1) / dx; addIfWithin(w, y1 + t * dy);
        }
        if (Math.abs(dy) > 1e-9) {
          let t = (0 - y1) / dy; addIfWithin(x1 + t * dx, 0);
          t = (h - y1) / dy; addIfWithin(x1 + t * dx, h);
        }
        const uniq = [];
        for (const p of pts) {
          if (!uniq.some(q => Math.hypot(q.x - p.x, q.y - p.y) < 1)) uniq.push(p);
        }
        if (uniq.length >= 2) {
          drawLine(uniq[0], uniq[1], color, width, dash);
        } else {
          drawLine(a, b, color, width, dash);
        }
      }

      function drawExtendedEdge(a, b, color) {
        ctx.save();
        ctx.globalAlpha = 0.6;
        drawInfiniteLine(a, b, color, 1, [6, 6]);
        ctx.restore();
        drawLine(a, b, color, 3, [6, 6]);
      }

      function drawInfiniteLine(a, b, color, width = 1, dash = []) {
        const w = canvas.clientWidth || canvas.width;
        const h = canvas.clientHeight || canvas.height;
        const x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;
        const dx = x2 - x1, dy = y2 - y1;
        const pts = [];
        function addIfWithin(x, y) {
          if (x >= 0 && x <= w && y >= 0 && y <= h) pts.push({ x, y });
        }
        if (Math.abs(dx) > 1e-9) {
          let t = (0 - x1) / dx; addIfWithin(0, y1 + t * dy);
          t = (w - x1) / dx; addIfWithin(w, y1 + t * dy);
        }
        if (Math.abs(dy) > 1e-9) {
          let t = (0 - y1) / dy; addIfWithin(x1 + t * dx, 0);
          t = (h - y1) / dy; addIfWithin(x1 + t * dx, h);
        }
        const uniq = [];
        for (const p of pts) {
          if (!uniq.some(q => Math.hypot(q.x - p.x, q.y - p.y) < 1)) uniq.push(p);
        }
        if (uniq.length >= 2) {
          drawLine(uniq[0], uniq[1], color, width, dash);
        } else {
          drawLine(a, b, color, width, dash);
        }
      }

      function drawExtendedEdge(a, b, color) {
        ctx.save();
        ctx.globalAlpha = 0.6;
        drawInfiniteLine(a, b, color, 1, [6, 6]);
        ctx.restore();
        drawLine(a, b, color, 3, [6, 6]);
      }

      function drawLabel(p, text, color = '#111') {
        ctx.save();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textBaseline = 'bottom';
        ctx.textAlign = 'left';
        // light text halo for contrast
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 3;
        const x = p.x + 6;
        const y = p.y - 6;
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.restore();
      }

      function collectHullEdgesUpTo(stepIndex) {
        const edges = [];
        for (let i = 0; i <= stepIndex && i < state.steps.length; i++) {
          const s = state.steps[i];
          if (s.hullEdges) edges.push(...s.hullEdges);
        }
        return edges;
      }

      function render() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.steps.length === 0) {
          stepInfoEl.textContent = 'Step 0 / 0';
          return;
        }

        const i = Math.max(0, Math.min(state.current, state.steps.length - 1));
        const step = state.steps[i];

        // Show the initial main dividing line only after initial split step
        if (state.mainAB && i >= state.showMainABFrom) {
          drawLine(state.mainAB.a, state.mainAB.b, COLORS.mainDividing, 2, [6, 6]);
        }

        // Persistent hull edges discovered so far
        const hullEdges = collectHullEdgesUpTo(i);
        for (const e of hullEdges) drawLine(e.a, e.b, COLORS.hull, 3);

        // Persistent dividing/subproblem lines active at this step
        if (step.persistent && step.persistent.length) {
          for (const e of step.persistent) {
            // avoid doubling the main AB (already drawn)
            if (state.mainAB && sameEdge(e, state.mainAB)) continue;
            const style = e.type === 'subline'
              ? { color: COLORS.subproblem, width: 1.5, dash: [6, 6] }
              : { color: COLORS.dividing, width: 1.5, dash: [6, 6] };
            drawLine(e.a, e.b, style.color, style.width, style.dash);
          }
        }

        // Current dividing lines — thin infinite extension + thicker segment
        for (const e of step.dividing) drawExtendedEdge(e.a, e.b, COLORS.current);

        // Subproblem lines introduced in this step (dashed)
        for (const e of step.sublines) drawLine(e.a, e.b, COLORS.subproblem, 1.5, [6, 6]);

        // Farthest distance dotted (per-step only)
        for (const d of step.distances) drawLine(d.p, d.foot, COLORS.distance, 1.5, [2, 6]);

        // Draw base points after lines so vertices appear above edges
        for (const p of state.points) drawPoint(p, COLORS.points, 3);

        // Highlight points for this step
        if (step.highlightPts) {
          for (const p of step.highlightPts) drawPoint(p, COLORS.highlight, 4);
        }

        // Add numeric labels next to vertices mentioned this step
        const labeled = new Set();
        function labelPoint(p, col) {
          const key = p.id;
          if (labeled.has(key)) return; labeled.add(key);
          drawLabel(p, String(p.id), col);
        }
        for (const e of (step.dividing || [])) { labelPoint(e.a); labelPoint(e.b); }
        for (const e of (step.sublines || [])) { labelPoint(e.a, '#225'); labelPoint(e.b, '#225'); }
        for (const d of (step.distances || [])) { labelPoint(d.p, '#603'); }
        for (const p of (step.highlightPts || [])) { labelPoint(p, COLORS.highlight); }

        stepInfoEl.textContent = `Step ${i + 1} / ${state.steps.length} — ${step.desc}`;
      }

      // Playback controls
      function stop() {
        if (state.timer) {
          clearInterval(state.timer);
          state.timer = null;
        }
        playBtn.textContent = 'Play';
      }
      function play() {
        if (state.timer) { stop(); return; }
        playBtn.textContent = 'Pause';
        // ms
        const baseDelay = 750;
        const spd = parseInt(speedEl.value, 10) || 1;
        const delay = Math.max(100, baseDelay / spd);
        state.timer = setInterval(() => {
          if (state.current >= state.steps.length - 1) {
            stop();
            return;
          }
          state.current++;
          render();
        }, delay);
      }

      // Events
      speedEl.addEventListener('change', () => {
        // if playing, restart with new speed
        if (state.timer) { stop(); play(); }
      });

      generateBtn.addEventListener('click', () => {
        stop();
        // ensure size before generating
        resizeCanvas();
        // reset logical coordinate system
        state.view.logicalW = canvas.clientWidth || 900;
        state.view.logicalH = canvas.clientHeight || 520;
        state.points = generatePoints(getPointCount());
        state.current = 0;
        quickHull(state.points);
        render();
      });

      prevBtn.addEventListener('click', () => {
        stop();
        state.current = Math.max(0, state.current - 1);
        render();
      });

      nextBtn.addEventListener('click', () => {
        stop();
        state.current = Math.min(state.steps.length - 1, state.current + 1);
        render();
      });

      nextMajorBtn.addEventListener('click', () => {
        stop();
        let j = state.current + 1;
        while (j < state.steps.length && !state.steps[j].major) j++;
        state.current = Math.min(j, state.steps.length - 1);
        render();
      });

      prevMajorBtn.addEventListener('click', () => {
        stop();
        let j = state.current - 1;
        while (j > 0 && !state.steps[j].major) j--;
        state.current = Math.max(0, j);
        render();
      });

      playBtn.addEventListener('click', play);

      // Init
      function init() {
        resizeCanvas();
        // establish logical coordinate system
        state.view.logicalW = canvas.clientWidth || 900;
        state.view.logicalH = canvas.clientHeight || 520;
        state.points = generatePoints(getPointCount());
        quickHull(state.points);
        render();
      }
      init();
    })();
  </script>
</body>
</html>
