<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Counting Sort Demo</title>
  <script src="../../../scripts/demoScripts.js" defer></script>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/demo.css">
  <style>
    #controls, #buttons { margin: 10px 0; }
    #description { margin-top: 10px; font-style: italic; }
    #phase-label, #minmax-label { margin: 10px 0; font-weight: bold; }
    .count-wrapper { display: flex; flex-direction: column; align-items: center; }
    .count-label { font-size: 0.8em; margin-top: 4px; }
    /* Arrow indicator under input */
    #input-container {
      position: relative;
      display: flex;
    }
    .element.active::after {
      content: '↑';
      position: absolute;
      left: 50%;
      bottom: -1em; /* tweak so arrow sits just below */
      transform: translateX(-50%);
      font-size: 1.2em;
      pointer-events: none;
    }
    .arrow {
      position: absolute;
      font-size: 1.2em;
      display: none;
      text-align: center;
      transform: translateX(-50%);
    }
    .array-container { margin-bottom: 30px; }
  </style>
</head>
<body>
  <h1>Counting Sort Demo</h1>

  <div id="controls">
    <label>Size:
      <input type="number" id="arraySize" min="1" max="20" value="10" size="2">
    </label>
    <button id="generate">Random Array</button>
    <input type="text" id="customArray" placeholder="e.g. 4,1,3,2,5" size="40">
    <button id="useCustom">Create Array</button>
  </div>

  <div id="buttons">
    <button id="prev" disabled>Previous</button>
    <button id="next" disabled>Next</button>
    <button id="play">Play</button>
    <label for="speed">Speed:</label>
    <select id="speed">
      <option value="1">1x</option>
      <option value="2">2x</option>
      <option value="4">4x</option>
    </select>
  </div>

  <div id="phase-label"><strong>Phase:</strong> <span id="phase-name">Initialization</span></div>
  <div id="minmax-label">
    <strong>Range:</strong>
    Min: <span id="curr-min"></span>
    Max: <span id="curr-max"></span>
    (size <span id="range-size"></span>)
  </div>

  <div id="input-label"><strong>Input Array:</strong></div>
  <div class="array-container" id="input-container">
    <div id="input-arrow" class="arrow">↑</div>
  </div>

  <div id="count-label"><strong>Count Array:</strong></div>
  <div class="array-container" id="count-container"></div>

  <div id="output-label"><strong>Output Array:</strong></div>
  <div class="array-container" id="output-container"></div>

  <div id="description">Press "Next" to begin.</div>

  <script>
    let steps = [], cur = 0;
    const phaseNames = {
      range_init:       'Finding Range',
      range_check:      'Finding Range',
      range_update_min: 'Updating Min',
      range_update_max: 'Updating Max',
      range_end:        'Range Found',
      init:             'Initialization',
      count:            'Counting Occurrences',
      count_end:        'Counting Complete',
      prefix_select:    'Select Prefix Inputs',
      prefix_calc:      'Perform Summation',
      prefix_end:       'Prefix Complete',
      output_input:     'Select Element',
      output_count:     'Determine Position',
      output_place:     'Place Element',
      output_end:       'Output Complete',
      done:             'Complete'
    };

    function record(state) {
      steps.push({
        input:      state.input.slice(),
        count:      (state.count || []).slice(),
        output:     state.output.slice(),
        phase:      state.phase,
        index:      state.index,
        value:      state.value,
        outPos:     state.outPos,
        min:        state.min,
        currMinIdx: state.currMinIdx,
        currMaxIdx: state.currMaxIdx,
        inc:        state.inc  
      });
    }

    function generateSteps(arr) {
      const input = arr.slice();
      const output = Array(input.length).fill(null);
      steps = [];

      // First pass: find min and max
      let currMin = input[0], currMax = input[0];
      let currMinIdx = 0, currMaxIdx = 0;
      record({ input, count: [], output, phase: 'range_init', index: 0, currMinIdx, currMaxIdx, min: currMin });

      for (let i = 1; i < input.length; i++) {
        record({ input, count: [], output, phase: 'range_check', index: i, currMinIdx, currMaxIdx, min: currMin });
        if (input[i] < currMin) {
          currMin = input[i];
          currMinIdx = i;
          record({ input, count: [], output, phase: 'range_update_min', index: i, currMinIdx, currMaxIdx, min: currMin });
        }
        if (input[i] > currMax) {
          currMax = input[i];
          currMaxIdx = i;
          record({ input, count: [], output, phase: 'range_update_max', index: i, currMinIdx, currMaxIdx, min: currMin });
        }
      }
      record({ input, count: [], output, phase: 'range_end', currMinIdx, currMaxIdx, min: currMin });

      // Now initialize count using discovered range
      const min = currMin, max = currMax;
      const count = Array(max - min + 1).fill(0);
      record({ input, count, output, phase: 'init', min });

      // Counting occurrences
      input.forEach((v, i) => {
        let inc = false;
        record({ inc, input, count, output, phase: 'count', index: i, value: v, min });
        count[v - min]++;
        inc = true;
        record({ inc, input, count, output, phase: 'count', index: i, value: v, min });
      });
      record({ input, count, output, phase: 'count_end', min });

      // Prefix sum
      for (let i = 1; i < count.length; i++) {
        record({ input, count, output, phase: 'prefix_select', index: i, min });
        count[i] += count[i - 1];
        record({ input, count, output, phase: 'prefix_calc', index: i, min });
      }
      record({ input, count, output, phase: 'prefix_end', min });

      // Build output
      for (let i = input.length - 1; i >= 0; i--) {
        const v = input[i];
        record({ input, count, output, phase: 'output_input', index: i, value: v, min });
        record({ input, count, output, phase: 'output_count', index: i, value: v, min });
        const pos = --count[v - min];
        output[pos] = v;
        record({ input, count, output, phase: 'output_place', index: i, outPos: pos, value: v, min });
      }
      record({ input, count, output, phase: 'output_end', min });
      record({ input, count, output, phase: 'done', min });

      return steps;
    }

    function positionInputArrow(i) {
      const arrow     = document.getElementById('input-arrow');
      const container = document.getElementById('input-container');
      const cells     = container.querySelectorAll('.element');

      if (i < 0 || i >= cells.length) {
        arrow.style.display = 'none';
        return;
      }
      const target = cells[i];
      arrow.style.width = `${target.offsetWidth}px`;
      arrow.style.left  = `${target.offsetLeft + target.offsetWidth / 2}px`;
      arrow.style.top   = `${target.offsetTop + target.offsetHeight + 4}px`;
      arrow.style.display = 'block';
    }

    function render() {
      const inpC       = document.getElementById('input-container');
      const cntC       = document.getElementById('count-container');
      const outC       = document.getElementById('output-container');
      const desc       = document.getElementById('description');
      const phaseLabel = document.getElementById('phase-name');
      const rangeEl    = document.getElementById('range-size');

      inpC.innerHTML = '<div id="input-arrow" class="arrow">↑</div>';
      cntC.innerHTML = '';
      outC.innerHTML = '';
      if (!steps.length) return;

      const st = steps[cur];
      phaseLabel.textContent = phaseNames[st.phase] || st.phase;

      st.input.forEach(v => {
        const d = document.createElement('div');
        d.className = 'element';
        d.textContent = v;
        inpC.appendChild(d);
      });

      if (st.phase.startsWith('range')) {
        document.getElementById('curr-min').textContent = st.input[st.currMinIdx];
        document.getElementById('curr-max').textContent = st.input[st.currMaxIdx];

        positionInputArrow(st.index);

        switch (st.phase) {
          case 'range_init':
            desc.textContent = `Start range at index 0 (${st.input[0]})`;
            break;
          case 'range_check':
            desc.textContent = `Checking index ${st.index} (${st.input[st.index]})`;
            break;
          case 'range_update_min':
            desc.textContent = `New min: ${st.input[st.index]} at index ${st.index}`;
            break;
          case 'range_update_max':
            desc.textContent = `New max: ${st.input[st.index]} at index ${st.index}`;
            break;
          case 'range_end':
            desc.textContent = `Range determined: min=${st.input[st.currMinIdx]}, max=${st.input[st.currMaxIdx]}`;
            rangeEl.textContent = st.count ? st.count.length : '';
            break;
        }
        return;
      }

      if (st.count && st.count.length) {
        st.count.forEach((c, i) => {
          const wrapper = document.createElement('div');
          wrapper.className = 'count-wrapper';
          const d = document.createElement('div');
          d.className = 'element';
          d.textContent = c;
          const lbl = document.createElement('div');
          lbl.className = 'count-label';
          lbl.textContent = st.min + i;
          wrapper.appendChild(d);
          wrapper.appendChild(lbl);
          cntC.appendChild(wrapper);
        });
      }

      st.output.forEach(v => {
        const d = document.createElement('div');
        d.className = 'element';
        if (v !== null) d.textContent = v;
        outC.appendChild(d);
      });
      st.output.forEach((v, i) => {
        if (v !== null) outC.children[i].classList.add('finished');
      });

      [inpC, cntC, outC].forEach(container =>
        Array.from(container.children).forEach(c => c.classList.remove('comparing'))
      );

      switch (st.phase) {
        case 'init':
          desc.textContent = 'Initial state.';
          inpC.querySelectorAll('.element').forEach(el => el.classList.remove('active'));
          const target = inpC.querySelectorAll('.element')[st.index];
          if (target) target.classList.add('active');
          break;

        case 'count':
          const ccIdx = st.value - st.min;

          if (st.inc === false) {
            desc.innerHTML =
              `Value <strong>${st.value}</strong> at index <strong>${st.index}</strong> →<br>` +
              `count index = <strong>${st.value} − ${st.min} = ${ccIdx}</strong>`;
          } else {
            desc.innerHTML =
              `increment <code>count[${ccIdx}]</code>`;
          }

          inpC.querySelectorAll('.element')[st.index].classList.add('comparing');
          positionInputArrow(st.index);
          cntC.children[ccIdx].querySelector('.element').classList.add('comparing');
          break;

        case 'count_end':
          desc.textContent = 'Counting phase complete.';
          positionInputArrow(-1);
          break;

        case 'prefix_select':
          const cIdx = st.index, pIdx = st.index - 1;
          desc.textContent = `Selecting count[${st.min + pIdx}] and count[${st.min + cIdx}] to sum.`;
          positionInputArrow(-1);
          cntC.children[cIdx].querySelector('.element').classList.add('comparing');
          cntC.children[pIdx].querySelector('.element').classList.add('comparing');
          break;

        case 'prefix_calc':
          desc.textContent = `Updating count[${st.min + st.index}] to ${st.count[st.index]} (sum of previous + current).`;
          positionInputArrow(-1);
          cntC.children[st.index].querySelector('.element').classList.add('comparing');
          break;

        case 'prefix_end':
          desc.textContent = 'Prefix summation complete.';
          positionInputArrow(-1);
          break;

        case 'output_input':
          desc.textContent = `Selecting input element ${st.value} at index ${st.index}.`;
          inpC.querySelectorAll('.element')[st.index].classList.add('comparing');
          positionInputArrow(st.index);
          break;

        case 'output_count':
          desc.innerHTML = `Determining position from count[${st.value - st.min}] -1 <br>(output index = ${st.count[st.value - st.min]} - 1 = ${st.count[st.value - st.min]-1}).`;
          inpC.querySelectorAll('.element')[st.index].classList.add('comparing');
          positionInputArrow(st.index);
          cntC.children[st.value - st.min].querySelector('.element').classList.add('comparing');
          break;

        case 'output_place':
          desc.innerHTML = `Placing value ${st.value} at output index ${st.outPos}.
		  <br> decremented count[${st.value - st.min}]`;
          inpC.querySelectorAll('.element')[st.index].classList.add('comparing');
          positionInputArrow(st.index);
          cntC.children[st.value - st.min].querySelector('.element').classList.add('comparing');
          outC.children[st.outPos].classList.add('finished');
          break;

        case 'output_end':
          desc.textContent = 'Output building complete.';
          positionInputArrow(-1);
          break;

        case 'done':
          desc.textContent = 'Counting Sort complete!';
          positionInputArrow(-1);
          break;
      }
    }

    // Hook into demoScripts
    window.onGenerate = function(isCustom) {
      if (isCustom) {
        const txt = document.getElementById('customArray').value.trim();
        return txt.split(',').map(s => parseInt(s.trim(), 10));
      }
      const n = parseInt(document.getElementById('arraySize').value, 10);
      return Array.from({ length: n }, () => Math.floor(Math.random() * 10));
    };

    window.genSteps = function(arr) {
      return generateSteps(arr);
    };

    window.renderStep = function(stepsArr, idx, original) {
      steps = stepsArr;
      cur = idx;
      render();
    };
  </script>
</body>
</html>