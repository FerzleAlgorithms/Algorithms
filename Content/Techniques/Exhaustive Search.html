<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Technique: Exhaustive Search</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
</head>
<body class="technique-page">
  <h1>Exhaustive Search</h1>
  
  <!-- Motivation & Introduction -->
  
  <section id="introduction">
    <h2>Introduction</h2>
    <p>
      Exhaustive Search is a subtype of Brute Force in which we explicitly
      enumerate every possible candidate solution from a well-defined search 
      space, then test each candidate to see if it satisfies the problem's 
      constraints. Whereas Brute Force can also refer simply to "follow the 
      problem's definition verbatim" (e.g. Naive Fibonacci or Polynomial 
      Evaluation), Exhaustive Search emphasizes "generate & test all 
      candidates"&mdash;for example, every subset, every assignment, or every 
      placement&mdash;without pruning. Although it is simple and guarantees 
      correctness, the search space often grows exponentially (or worse), 
      making it feasible only for relatively small inputs or as a baseline 
      for comparison against more advanced techniques.
    </p>
      <p>
    At a high level, exhaustive search algorithms are easy to describe &mdash; phrases like "try every subset" or "check every permutation" capture the core idea in just a few words. In practice, however, writing code that actually "tries every subset" or "checks every arrangement" requires some thought: you must decide how to represent each candidate, how to iterate (or recurse) through all possibilities, and how to efficiently test each candidate against the problem's constraints. That implementation effort is where the real work lies, even though the overarching concept remains straightforward.
  </p>
  </section>

  <section id="examples">
    <h2>Examples</h2>

    <!-- Example 1: Subset-Sum -->
    <div class="example-box">
      <strong class="example-title">Example 1: Subset-Sum</strong>
      <p>The 
    <a class="problem" href="?path=Problems/Other/Subset%20Sum">Subset-Sum</a> 
    problem asks: Given a set \(S = \{a_0, a_1, \dots, a_{n-1}\}\) of numbers (typically integers) 
    and a target \(T,\) is there a subset \(X \subseteq S\) whose elements sum to \(T?\)  
    The exhaustive search space consists of all \(2^n\) subsets of \(S.\)
     For each subset \(Xx\) the algorithms computes \(\displaystyle\sum_{x \in X} x\) 
     and compare it against \(T\).</p>

  <p>Here is over-simplified pseudocode for the exhaustive search Subset-Sum algorithm 
  that leaves out the important detail of how to generate each of the subsets of \(S\).
  See the 
    <a class="problem" 
    href="?path=Algorithms/Exhaustive Search/Subset%20Sum">Subset-Sum (Exhaustive Search)</a>
    page for more complete details about that part.</p>
    
<pre><code style="width: 400px;">function subsetSumBruteForce(S, T):
    for each subset X of S do
        if sum of elements in X = T then
            output X
        end if
    end for</code></pre>

<p>Here is a example demo that shows how the exchaustive search algorithm for Subset-Sum works.
</p>
 <div class="embeddedDemoContainer">
      <iframe
        class="embeddedDemo"
        src="/Algorithms/Content/Demos/Exhaustive Search/Subset Sum Demo.html"
        allow="fullscreen"
        name="SubsetSum-demo-bf"
      ></iframe>
    </div>
      <p>
      Assuming you have taken a discrete mathematics course, you know that there are \(2^n\)
      subsets of a set of size \(n,\) and since each subset has up to \(n\) elements, 
      computing the sum of the elements of a subset takes up to \(O(n)\) time.
      Thus, this algorithm has a computational complexity of \(O(n \cdot 2^n)\).
      Clearly that is not very fast, and this algorithm is only reasonable to use
      on reasonably small sets.
      </p>
      <p>
       For more details about this algorithm see the <a class="problem" 
    href="?path=Algorithms/Exhaustive Search/Subset%20Sum">Subset-Sum (Exhaustive Search)</a>
    algorithm page.
      </p>
    </div>
    
    
    <!-- Example 2: N-Queens -->
    <div class="example-box">
      <strong class="example-title">Example 2: N-Queens</strong>
      <p>
        The <a class="problem" href="?path=Problems/Other/N-Queens">N-Queens</a> 
        problem asks: Determine all legal ways of placing \(N\) queens on an \(N \times N\) chessboard,
        where by legal we mtan that none of the queens are attacking each other.
        If you are unfamilair with chess and/or what it means for queens to attack each other, read
        the N-Queens problem page before continuing.
        </p>
        <p>
  To generate all \(N^N\) assignments in a structured way, we build the array \(Q\) entry by entry, where each entry corresponds to a specific row. At step \(r\) (for \(r = 0, 1, \dots, N-1\)), we choose a single column \(c\) (from \(0\) to \(N-1\)) and set \(Q[r] = c\). Once \(Q[r]\) is set, we recurse to fill \(Q[r+1]\) through \(Q[N-1]\) in the same manner. After exploring every possible way to fill rows \(r+1\) through \(N-1\) with that fixed \(Q[r]\), we backtrack and try the next column value for \(Q[r]\). Only when \(Q[0]\) through \(Q[N-1]\) have all been assigned do we check the complete configuration for column or diagonal conflicts. This entry-by-entry, depth-first approach is exactly what the pseudocode below implements.
  This version outputs all valid solutions. (It uses the Java-like <code>Math.abs()</code> function
  that can be replaced with whatever method for computing absolute values your langauge has.)
</p>

<pre><code>
// Start recursion to place queens on an NxN board
void findAllQueenPlacements(int boardSize) {
    int[] queenCols = new int[boardSize]; 
    placeQueenInRow(0, queenCols, boardSize);
}

// Try each column for row currentRow, then recurse
void placeQueenInRow(int currentRow, int[] queenCols, int boardSize) {
    if (currentRow == boardSize) { // We have filled the board. Check it.
        if (isValidConfiguration(queenCols, boardSize)) 
            outputSolution(queenCols);
    }
    // The core of the algorithm: For each column of the board,
    // place the queen in that column for this row and recursively
    // try all possible placements for the rest of the rows.
    for (int col = 0; col < boardSize; col++) {
        queenCols[currentRow] = col;
        placeQueenInRow(currentRow + 1, queenCols, boardSize);
    }
}

// Check no two queens share a column or diagonal
boolean isValidConfiguration(int[] queenCols, int boardSize) {
    for (int r1 = 0; r1 < boardSize; r1++) {
        for (int r2 = r1 + 1; r2 < boardSize; r2++) {
            int c1 = queenCols[r1], c2 = queenCols[r2];
            if (c1 == c2 || Math.abs(r1 - r2) == Math.abs(c1 - c2)) 
                return false;
        }
    }
    return true;
}
</code></pre>
<p>The following demonstration shows this exhaustive-search algorithm in action for \(3 \le N \le 8\). Even at the highest speed, you will need to wait quite a while before a valid solution appears for \(N = 7\) or \(N = 8\). This clearly illustrates how quickly the exhaustive search approach becomes impractical as \(N\) increases.
</p>

 <div class="embeddedDemoContainer">
      <iframe
        class="embeddedDemo"
        src="/Algorithms/Content/Demos/Exhaustive Search/N-Queens Demo.html"
        allow="fullscreen"
        name="SubsetSum-demo-bf"
      ></iframe>
    </div>

<p>The brute-force approach tries all \(N^N\) possible assignments and performs an \(O(N)\) conflict check on each, yielding an overall time complexity of \(O(N \times N^N)=O(N^{N+1})\). 
Because \(N^{N+1}\) grows so quickly, this method is only practical for very small values of \(N\)
(as you may have seen if you ran the demo for \(N = 7\) or \(N = 8\)).
  For a more complete explanation and discussion of the algorithm, see this 
  <a class="problem" href="?path=Algorithms/Exhaustive Search/N-Queens">
    N-Queens (Exhaustive Search)
  </a> algorithm page. 
</p>
  </section>
  
  <section id="applicability">
  <h2>When to Use</h2>
  <ul>
    <li>
      <strong>Very Small Input Sizes:</strong>  
      Because Exhaustive Search literally visits every candidate, the search space often grows as \(2^n\), \(N^N\), \(N!\), or \(k^n\). Use it only when the key parameter is small enough that enumerating every candidate is still feasible. 
      For instance,  
      <ul>
        <li>For Subset-Sum, when \(n \le 20\), \(2^n \le 1{,}048{,}576\) subsets may be examinable in a reasonable time.</li>
        <li>For N-Queens, when \(N \le 8\), the \(8^8 = 16{,}777{,}216\) assignments are still within reach of a fast 
        machine (as the demo shows)&mdash;beyond that, pure enumeration becomes impractical.</li>
      </ul>
    </li>

    <li>
      <strong>Need for Guaranteed Completeness:</strong>  
      When you absolutely must find all solutions or prove that no solution exists&mdash;e.g., listing every valid \(N\)-queen arrangement or cataloging all subsets that sum to \(T\). Because Exhaustive Search is a "generate &amp; test" approach (a special case of Brute Force), it cannot prune any potential candidate until after it is fully generated, so it guarantees that no possibility is missed.
    </li>

    <li>
      <strong>Baseline or Correctness Comparison:</strong>  
      Use Exhaustive Search as a sanity check or performance baseline before deploying a more sophisticated method&mdash;e.g., branch-and-bound, dynamic programming, or backtracking with constraints. By comparing results on small inputs, you can confirm that your optimized solution is correct. Because pure brute force is guaranteed to test every candidate, it serves as an ideal "ground truth."  
      <ul>
        <li>Example: Before implementing a clever SAT solver, run an exhaustive \(2^n\)-assignment checker on \(n \le 20\) to confirm that your optimized solver returns the same satisfiable/unsatisfiable answers.</li>
        <li>Example: Use a recursion-tree enumeration of all subsets to verify that a faster meet-in-the-middle or dynamic-programming subset-sum implementation produces identical counts or solutions for \(n \le 20\).</li>
      </ul>
    </li>

    <li>
      <strong>Educational or Illustrative Purposes:</strong>  
      Because Exhaustive Search is conceptually the simplest way to solve many combinatorial problems, it is often used as a teaching tool. By watching all \(2^n\) subsets being generated or all \(N^N\) queen assignments being tested&mdash;and then pruned&mdash;students clearly see why the search space "blows up" and how optimizations&mdash;pruning, DP, heuristics&mdash;drastically reduce work.  
      <ul>
        <li>Example: Visualize the recursion tree for a 4-element set to illustrate why there are \(2^4 = 16\) leaves (subsets) and how each leaf requires \(O(n)\) work to compute the sum, resulting in \(O(n\,2^n)\) overall.</li>
        <li>Example: Run the N-Queens exhaustive demo for \(N = 7\) or \(8\) to show how quickly \(N^N\) assignments grow and why enforcing one queen per column (reducing to \(N!\)) still remains large for \(N > 10\).</li>
      </ul>
    </li>

    <li>
      <strong>Prototype or Fallback Implementation:</strong>  
      When you need a quick, reliable solution and you know the input is small enough that performance is not an immediate concern. For a proof-of-concept or a temporary script&mdash;especially under tight deadlines&mdash;writing an exchaustive search solver can be far faster than designing an optimized algorithm. Because Exhaustive Search is a special case of Brute Force with "check-every-possibility" logic, it requires minimal problem-specific insight beyond a correct representation of each candidate.
    </li>
  </ul>
</section>



<section id="limitations">
  <h2>Limitations</h2>
  <ul><li>
      <strong>Exponential (or Worse) Growth &amp; Unsuitability for Large Inputs:</strong>
      The candidate space typically scales as \(2^n\), \(N^N\), or \(N!\). Even moderate values of \(n\) already become infeasible&mdash;so Exhaustive Search cannot handle large inputs. For example:
      <ul>
        <li>For \(n = 30\), \(2^n = 1{,}073{,}741{,}824\) subsets&ndash;already billions of candidates.</li>
        <li>For \(N = 10\) in N-Queens, \(10^{10} = 10{,}000{,}000{,}000\) assignments (pure \(N^N\)) or \(10! = 3{,}628{,}800\) permutations if you enforce one queen per column.</li>
      </ul>
      In practice, when \(n > 25\) for \(2^n\)-type problems or \(N > 10\) for \(N^N\) or \(N!\)-type problems, 
      the sheer number of candidates exceeds any reasonable computational budget&mdash;you must switch to a pruned backtracking, dynamic programming, or heuristic algorithm.
    </li>
    <li>
      <strong>Exponential (or Worse) Growth:</strong>
      The candidate space typically scales as \(2^n\), \(N^N\), or \(N!\). 
      Even moderate values of \(n\) quickly become infeasible:
      <ul>
        <li>For \(n = 30\), \(2^n = 1{,}073{,}741{,}824\) subsets&mdash;already billions of candidates.</li>
        <li>For \(N = 10\) in N-Queens, \(10^{10} = 10{,}000{,}000{,}000\) assignments (pure \(N^N\)) or \(10! = 3{,}628{,}800\) permutations if you insist on one queen per column.</li>
      </ul>
    </li>
    <li>
      <strong>No Pruning Unless Added Explicitly:</strong>
      By definition, Exhaustive Search is a special case of Brute Force where <em>every</em> candidate must be generated and then tested. In the pure form, you do not stop exploring a branch even if a partial assignment already violates constraints. As a result, you often perform a great deal of redundant work.
    </li>
    <li>
      <strong>High Per-Candidate Overhead:</strong>
      Each candidate typically incurs \(O(n)\) or \(O(N)\) cost to verify (e.g., summing elements in Subset-Sum or checking row/column/diagonal conflicts in N-Queens). That linear factor multiplies the already exponential number of candidates, yielding an overall cost like \(O(n \cdot 2^n)\) or \(O(N \cdot N^N)\).
    </li>
    <li>
      <strong>Deep Recursion Risks:</strong>
      Recursive implementations can reach depth \(n\) or \(N\). On large inputs, this may cause a stack overflow or excessive call-stack memory usage. Iterative or bitmask techniques can avoid deep recursion, but at the expense of code clarity.
    </li>
    <li>
      <strong>Memory Overhead for Storing Solutions:</strong>
      If you need to collect all valid solutions (rather than just count or output them one by one), the memory usage can become prohibitive. For example, storing all valid 8-Queens arrangements (92 solutions) is fine, but storing all subsets of a 20-element set could require gigabytes of memory.
    </li>
    <li>
      <strong>Poor Exploitation of Problem Structure:</strong>
      Because pure Exhaustive Search treats every candidate equally, it fails to leverage domain-specific constraints (e.g., symmetries, partial-assignment checks, etc.). In many cases, even a small amount of pruning or memoization 
      reduces runtime from exponential to feasible.
      (Memoization is a technique that caches the results of expensive function calls so that if the same inputs recur, 
      the cached result can be returned immediately without recomputation&mdash;we will discuss it in the Dynamic Programming
      section.)
    </li>
  </ul>
</section>


<section id="tips">
  <h2>Implementation Tips &amp; Common Pitfalls</h2>
  <ul>
  <li>
  <strong>Use a General Recursive or Iterative Pattern:</strong>
  Rather than hard-coding loops for each size or permutation, write a generic routine that builds one candidate at a time, 
  checks its validity, and only then outputs it. 
  Below are two pseudocode styles&mdash;recursive and iterative&mdash;showing how to "generate & test" every subset. 
  In each case, replace the <code>isValid(...)</code> check with whatever your problem's criterion 
  is (for example, <code>sum(subset) == T</code> in Subset-Sum).

<br>
<font style="font-size:2em; color:red">I am here</font>

  <pre><code>
// Recursive pseudocode: build one subset at a time, then test it
function generateSubsets(i, element[], n, currentSubset[], size):
    if i == n then
        // We have a complete subset in currentSubset[0..size-1]
        if isValid(currentSubset, size) then
            output currentSubset[0..size-1]
        end if
        return
    end if

    // 1) EXCLUDE element[i]
    generateSubsets(i + 1, element, n, currentSubset, size)

    // 2) INCLUDE element[i]
    currentSubset[size] = element[i]
    generateSubsets(i + 1, element, n, currentSubset, size + 1)
end function

// Initial call (e.g., in main):
// element[] = { ... }             // input array of length n
// currentSubset = new int[n]      // allocate array of size n
// generateSubsets(0, element, n, currentSubset, 0)
  </code></pre>

  <pre><code>
// Iterative pseudocode: interpret each integer from 0..2^n-1 as a candidate subset
function processAllSubsets(element[], n):
    totalMasks = 1 << n           // 2^n possible subsets
    for mask = 0 to totalMasks - 1 do
        // Build one subset according to bits of mask
        subset = new int[n]
        size = 0
        for j = 0 to n - 1 do
            if ((mask & (1 << j)) != 0) then
                subset[size] = element[j]
                size = size + 1
            end if
        end for

        // Test the candidate subset
        if isValid(subset, size) then
            output subset[0..size-1]
        end if
    end for
end function

// Initial call (e.g., in main):
// element[] = { ... }            // input array of length n
// processAllSubsets(element, n)
  </code></pre>
</li>

  
  
    <li>
      <strong>Use a General Recursive or Iterative Pattern:</strong>  
      Rather than writing nested loops for each candidate size, use a single recursion parameterized by an index \(i\). For example, to generate all subsets of a set of size \(n\), write:
      
      <pre><code>
function generateSubsets(i, currentSubset):
    if i = n then
        output currentSubset
        return
    end if
    // Exclude element i
    generateSubsets(i + 1, currentSubset)
    // Include element i
    currentSubset.append(element[i])
    generateSubsets(i + 1, currentSubset)
    currentSubset.pop()
      </code></pre>
      Alternatively, use an iterative bitmask loop for "all assignments":
      <pre><code>
for mask = 0 to (1 << n) - 1 do
    // mask encodes one subset in binary
    processMask(mask)
end for
      </code></pre>
    </li>

    <li>
      <strong>Be Careful with Recursion Depth &amp; Stack Usage:</strong>  
      Recursive calls can reach depth \(n\) (for subsets) or \(N\) (for N-Queens), which may overflow the call stack when \(n\) or \(N\) is large. If \(n\) might exceed a few thousand, convert to an iterative approach (e.g., bitmask loops or explicit stack) or increase your language's recursion limit.
    </li>

    <li>
      <strong>Avoid Recomputing From Scratch:</strong>  
      Whenever possible, maintain incremental state instead of recomputing at each leaf:
      <ul>
        <li>In Subset-Sum, keep a running sum as you add or remove elements&mdash;then each candidate's sum is \(O(1)\) to update, not \(O(n)\) to recompute.</li>
        <li>In N-Queens, maintain auxiliary arrays (or bitmasks) for columns and diagonals so that checking whether placing a queen conflicts with existing queens is \(O(1)\). For example:
        <pre><code>
columns[col] = true if column col is occupied
diag1[row+col] = true if one diagonal is occupied
diag2[row-col + (N-1)] = true if the other diagonal is occupied
        </code></pre>
        </li>
      </ul>
    </li>

    <li>
      <strong>Test on Small Inputs First:</strong>  
      Before running on large parameters, verify correctness on minimal cases (e.g., a set of size 3 for subset enumeration or \(N = 4\) for N-Queens). Print intermediate candidates to ensure that every combination is visited exactly once and that conflict checks are correct.
    </li>

    <li>
      <strong>Consider Early Termination When Only One Solution Is Required:</strong>  
      If the problem only asks for "some valid solution" (not "all" solutions), you can stop as soon as you find a match. However, if you need to enumerate every solution, do not terminate early&mdash;otherwise you risk missing additional valid candidates.
    </li>

    <li>
      <strong>Mind Data Types &amp; Overflow:</strong>  
      When summing values or using bitmasks, watch for integer overflow:
      <ul>
        <li>For Subset-Sum with large element values, use 64-bit integers (e.g., <code>long long</code> in C++ or <code>int64_t</code>).</li>
        <li>For bitmask enumeration, if \(n > 31\), a 32-bit integer may overflow; use a 64-bit mask or arbitrary-precision type.</li>
      </ul>
    </li>

    <li>
      <strong>Prepare for Large Memory Use:</strong>  
      Storing all valid candidates can exhaust available RAM. If you only need to count solutions or write them to an output stream, avoid accumulating everything in memory. For example, print each valid subset as soon as you generate it, rather than storing it in a list.
    </li>

    <li>
      <strong>Poor Exploitation of Problem Structure:</strong>  
      Pure Exhaustive Search does not leverage domain-specific constraints. Even a small amount of pruning&mdash;checking partial feasibility before recursing&mdash;can reduce the search space dramatically. For instance:
      <ul>
        <li>In Subset-Sum, if the current partial sum already exceeds \(T\), skip further recursion down that branch.</li>
        <li>In N-Queens, reject any partial assignment where two queens share a column or diagonal before placing all \(N\) queens. This pruned version is no longer "pure" Exhaustive Search but remains a brute-force method with much lower constant factors.</li>
      </ul>
    </li>

    <li>
      <strong>Watch Loop Bounds in Iterative Enumeration:</strong>  
      When simulating an \(n\)-digit base-\(b\) counter (e.g., base-\(N\) for N-Queens), be sure to initialize and terminate correctly:
      <pre><code>
for mask = 0 to (b^n) - 1 do
    // compute digits by repeated division
end for
      </code></pre>
      Off-by-one errors in loop limits or digit extraction can lead to missing the first or last candidate.
    </li>

    <li>
      <strong>Use Deterministic Ordering When Needed:</strong>  
      If you must compare outputs across different runs (e.g., for debugging or automated testing), choose a consistent enumeration order&mdash;such as lexicographic bitmask order for subsets or sorted permutations for N-Queens. This ensures reproducible results.
    </li>

    <li>
      <strong>Benchmark and Profile for Bottlenecks:</strong>  
      Even with small \(n\), high per-candidate overhead can dominate runtime. Use a profiler to identify which part of your code&mdash;conflict checking, summation, or array manipulation&mdash;is the hot spot, then optimize that routine (e.g., replace array scans with bitwise operations).
    </li>
  </ul>
</section>


  <!-- Implementation Tips & Common Pitfalls -->
  <section id="tips">
    <h2>Implementation Tips &amp; Common Pitfalls</h2>
    <ul>
      <li>
        <strong>Use a General Recursive or Iterative Pattern:</strong>  
        For "all subsets," write a single recursion with parameter \(i\) (include/exclude) 
        instead of hard-coding loops for each subset size. The same pattern applies to "all 
        assignments" (choose each variable's value).
      </li>
      <li>
        <strong>Be Careful with Recursion Depth:</strong>  
        If \(n\) is large, recursion to depth \(n\) may cause stack overflow. Consider converting 
        to a bitmask loop (for subsets or assignments) or manage your own explicit stack.
      </li>
      <li>
        <strong>Avoid Recomputing from Scratch:</strong>  
        In subset enumeration, maintain a running sum instead of summing the subset from 
        scratch at each leaf. In N-Queens, maintain auxiliary arrays (or bitmasks) for columns 
        and diagonals so conflict checks can be \(O(1)\) per placement.
      </li>
      <li>
        <strong>Test on Small Inputs First:</strong>  
        Verify correctness by running on minimal cases (e.g.\ set of size 3 for subsets, 
        \(N=4\) for N-Queens) and print partial results to ensure you are visiting every 
        candidate.
      </li>
      <li>
        <strong>Consider Early Termination if You Only Need One Solution:</strong>  
        If you only need to find "some valid solution," you can stop once you encounter it. 
        But if you need "all" solutions, do not terminate prematurely.
      </li>
      <li>
        <strong>Mind Data Types &amp; Overflow:</strong>  
        Summing subset elements or indexing large arrays can overflow standard integers if 
        numbers get large. Use 64-bit types or big-integer libraries when needed.
      </li>
      <li>
        <strong>Prepare for Large Memory Use:</strong>  
        If you store every valid subset or every queen placement in a list, memory can blow up 
        quickly. Consider streaming results or writing them to disk if necessary.
      </li>
    </ul>
  </section>

  <!-- Canonical Algorithms -->
  <section id="algorithms">
    <h2>Algorithms Using This Technique</h2>
    <ul>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/Subset%20Sum">
          Subset-Sum (Enumeration)
        </a>
        – Enumerate all subsets of a set \(S\) and check each subset's sum against the target \(T\).
      </li>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/N-Queens">
          N-Queens (Column-Assignment)
        </a>
        – Try every assignment of queen positions (one column per row) then filter out conflicts.
      </li>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/3-SAT">
          3-SAT (Truth-Assignment)
        </a>
        – Enumerate all \(2^n\) truth assignments for \(n\) variables and test each against 
        the set of clauses.
      </li>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/Graph-Coloring">
          Graph-Coloring (k-Coloring)
        </a>
        – Assign each of \(n\) vertices one of \(k\) colors (total \(k^n\) assignments) 
        and test for adjacent conflicts.
      </li>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/Magic-Square">
          Magic Square Generation
        </a>
        – Generate all permutations of \(\{1,\dots,9\}\) (9! candidates) and test sums of 
        rows/columns/diagonals for 3×3 magic squares.
      </li>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/All-Strings">
          All Strings of Length \(L\)
        </a>
        – Enumerate all \(K^L\) strings over an alphabet of size \(K\), then test for desired 
        property (e.g.\ containing a substring).
      </li>
      <li>
        <a class="problem" href="?path=Algorithms/Exhaustive%20Search/Integer-Ro
ots">
          Integer Roots (Exhaustive Check)
        </a>
        – Test each integer \(x\) in a fixed range (e.g.\ \(0\le x<p\)) to see if \(p(x)\equiv0\pmod{p}\).
      </li>
    </ul>
  </section>

<section id="applications">
  <h2>Real-World Applications</h2>
  <ul>
    <li>
      <strong>Cryptanalysis and Password Cracking:</strong>
      For short keys or simple password schemes, attackers can literally generate every possible key or password string until a match is found.  Even though modern systems enforce complex policies, brute-force remains the fallback for recovering lost credentials (e.g., “try all 8-character combinations of letters, digits, and symbols”).  In cryptographic research, exhaustive key search helps verify the effective key length of ciphers by demonstrating the practical limits of brute-force.
    </li>
    <li>
      <strong>Formal Verification &amp; Model Checking:</strong>
      In hardware design and safety-critical software, model checkers exhaustively explore all possible states of a finite state machine or protocol up to a given bound, looking for counterexamples to a specification.  Although state-space explosion is a concern, exhaustive enumeration on a reduced or bounded model is often the only way to guarantee that every possible scenario has been checked.
    </li>
    <li>
      <strong>Configuration &amp; Regression Testing:</strong>
      Software projects with multiple Boolean flags, compiler options, or environment variables sometimes use exhaustive testing on small subsets of flags to detect interaction bugs.  For example, if a program has four binary configuration switches, exhaustive search of all \(2^4 = 16\) combinations can reveal corner-case failures before release.  Similar techniques apply in hardware driver validation and embedded systems.
    </li>
    <li>
      <strong>Hyperparameter Tuning in Machine Learning (Grid Search):</strong>
      When the search space of hyperparameters is small (e.g., learning rate ? \{0.01, 0.1\}, tree depth ? \{4, 8\}), a grid search exhaustively evaluates every combination on a validation set.  Although more sophisticated methods (random search, Bayesian optimization) scale better, exhaustive grid search remains widely used for low-dimensional hyperparameter spaces to guarantee that the global optimum is not missed.
    </li>
    <li>
      <strong>Combinatorial Puzzle Solving:</strong>
      Many classic puzzles—such as the \(3\times3\) magic square, \(4\times4\) sliding puzzle, or small versions of Sudoku—are solved by generating all candidate configurations and filtering out invalid ones.  For a \(3\times3\) magic square, there are \(9! = 362{,}880\) permutations of \(\{1,\dots,9\}\); checking each is straightforward at this scale and provides a complete list of solutions.
    </li>
    <li>
      <strong>Small-Scale Bioinformatics &amp; Chemistry:</strong>
      In peptide-sequencing or ligand-docking on a short peptide (e.g., \(\le6\) amino acids), tools sometimes exhaustively generate every candidate sequence (or every 3D conformation in a coarse grid) and score each one.  Although this becomes impractical for large proteins, brute-force enumeration on a limited alphabet or small molecule set can identify promising leads in drug discovery or motif finding.
    </li>
    <li>
      <strong>Benchmarking &amp; Pedagogical Demos:</strong>
      In algorithm design courses, instructors often implement exhaustive search as a “correctness baseline” to compare against optimized or heuristic methods.  Demonstrations—such as visualizing all subsets in \(\{1,2,3,4\}\) or stepping through all \(8^8\) assignments in \(8\)-Queens—help students appreciate why pruning, dynamic programming, or backtracking drastically reduce work.
    </li>
    <li>
      <strong>Exhaustive Enumeration in Combinatorial Design:</strong>
      For small combinatorial objects—like all non-isomorphic graphs on \(n\le 6\) vertices, all set partitions of a 5-element set, or all Latin squares of order 4—researchers can generate every candidate and filter out isomorphic or invalid ones.  This exhaustive cataloging underpins database creation for combinatorial designs and helps conjecture enumeration formulas.
    </li>
  </ul>
</section>

  <!-- Real-World Applications -->
  <section id="applications">
    <h2>Real-World Applications</h2>
    <ul>
      <li>
        <strong>Password &amp; Key Cracking:</strong> For short keys, exhaustively generate 
        every possible key or password string until you find a match. 
      </li>
      <li>
        <strong>Small CSP Solvers:</strong> When only a few variables remain, enumerating 
        all assignments (e.g.\ 3-SAT or Sudoku on a few empty cells) can be done quickly.
      </li>
      <li>
        <strong>Benchmarking &amp; Educational Demos:</strong> Use exhaustive search to 
        verify correctness of more advanced algorithms. It is often used as a teaching 
        tool to illustrate how pruning or dynamic programming provides speedups.
      </li>
      <li>
        <strong>Exhaustive Hyperparameter Tuning:</strong> For a very small set of discrete 
        hyperparameter values (e.g.\ learning rate ? {0.01, 0.1}, depth ? {4,8}), generate 
        all combinations and test each configuration.
      </li>
      <li>
        <strong>Small-Scale Puzzle Solvers:</strong> For puzzles like the 3×3 Magic Square or 
        4×4 sliding-tile, "generate all candidate boards" (or partial assignments) and test 
        validity.
      </li>
    </ul>
  </section>
  
  
  <!-- Reading Comprehension Questions -->
  <section id="reading-questions">
    <h2>Summary &amp; Key Takeaways</h2>
    </section>
  
  
  <!-- Reading Comprehension Questions -->
  <section id="reading-questions">
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li>
        In your own words, what differentiates Exhaustive Search from a more general Brute Force 
        method? Why does Exhaustive Search often run in \(O(2^n)\), \(O(N^N)\), or \(O(k^n)\)?
      </li>
      <li>
        According to the Subset-Sum example, why does enumeration of all subsets cost \(O(n \cdot 2^n)\) 
        time? Explain how the recursion tree has \(2^n\) leaves and why each leaf requires \(O(n)\) work.
      </li>
      <li>
        In the N-Queens example, why does the naive enumeration produce \(N^N\) candidates? How would 
        enforcing "one queen per column" reduce the candidate space?
      </li>
      <li>
        Describe two situations from the "When to Use" section where Exhaustive Search is appropriate; 
        explain why you would choose it over a more optimized algorithm.
      </li>
      <li>
        The "Limitations" section lists "Deep Recursion Risks." Provide a concrete scenario in Subset-Sum 
        or N-Queens that illustrates how recursion depth can cause a stack overflow.
      </li>
      <li>
        Choose one canonical algorithm under "Algorithms Using This Technique" and briefly summarize 
        how its enumeration works (e.g.\ "Graph-Coloring enumerates \(k^n\) color assignments").
      </li>
    </ol>
  </section>

  <!-- In-Class Activities -->
  <section id="activities">
    <h2>In-Class Activities</h2>
    <ol>
      <li>
        <strong>Subset-Sum Recursion Tree:</strong> 
        For \(n=4\) and a small set (e.g.\ \(\{2,5,7,9\}\)), draw the full recursion tree of 
        include/exclude decisions. Count how many leaves there are and highlight which subsets 
        sum to a given \(T\).
      </li>
      <li>
        <strong>Compare Bitmask vs. Recursion:</strong> 
        Implement both the recursive and bitmask versions of Subset-Sum for \(n=5\). Count how 
        many times you enter the "process a subset" step. Confirm both methods enumerate \(2^5 = 32\) subsets.
      </li>
      <li>
        <strong>N-Queens Candidate Count:</strong> 
        Write code that, for \(N=6\), enumerates all \(6^6\) assignments (without conflict checks). 
        Then measure how many survive after filtering (i.e.\ valid placements). Compare that 
        against the count of valid 6-queen solutions.
      </li>
      <li>
        <strong>Early Stopping vs. Full Enumeration:</strong> 
        Modify the Subset-Sum code to stop once it finds any subset summing to \(T\). Compare 
        average work done (number of candidates tested) vs. the full enumeration for random sets.
      </li>
      <li>
        <strong>Binary Hypercube Visualization:</strong> 
        Visualize all vertices of an \(n\)-dimensional hypercube (bitstrings of length \(n\)) 
        and label which bitstrings correspond    </li>
        <li>Think of an N! version of the algorithm.</li>
  </ol>
</section>


<section id="problems">
  <h2>Problems</h2>

  <h3>Basic</h3>
  <ol>
  </ol>
 <h3>Advanced</h3>
  <ol>
  </ol>
</section>


</body>
</html>
