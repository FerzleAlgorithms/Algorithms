<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Breadth-First Search</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}    
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
</head>
<body>
  <h1>Breadth-First Search</h1>

  <section id="problem-solved">
    <h2>Problem Solved</h2>
    <p>
      Breadth-First Search solves the 
      <a class="problem" href="?path=Problems%2FGraphs%2FGraph%20Traversal">Graph Traversal</a>
      problem.
    </p>
  </section>

  <section id="design">
    <h2>Design and Strategy</h2>
	<p>
	  Breadth-First Search (BFS) is a fundamental graph traversal algorithm whose goal is to explore every vertex reachable from a given <em>source</em> vertex in the most systematic way possible. Specifically, it discovers each reachable node and determines a shortest path to it—measured in the fewest number of edges—in an unweighted graph. BFS is especially useful when we want to answer questions like: “Which vertices can be reached from here?” or “What is the shortest path to each one?”
	</p>
	<p>
	  The key idea behind BFS is to explore the graph in <em>layers</em>. It begins at the source and visits all neighboring vertices (distance 1), then all vertices that are two edges away (distance 2), and so on. This ensures that the first time a vertex is discovered, it is along a path with the fewest possible edges from the source.
	</p>
	<p>
	  To manage this layer-by-layer process, BFS uses a <em>queue</em> to hold vertices that have been discovered but not yet fully explored. At each step, the algorithm dequeues a vertex, examines its neighbors, and enqueues any that haven’t been visited yet. To prevent revisiting the same vertex (which is especially important in graphs with cycles), BFS marks each vertex as visited the moment it is enqueued.
	</p>
	<p>
	  As a result, BFS explores every node reachable from the source exactly once, and computes the shortest-path distance from the source to each of them. If desired, it can also be extended to record the full path taken to reach each vertex.
	</p>

<div class="example-box">
  <strong class="example-title">Example 1: BFS on an Acyclic Graph</strong>

  <div style="display: flex; align-items: flex-start; gap: 1.5em; margin-top: 0.5em;">
    <div style="flex: 1;">
      <p>
        On the graph below, a BFS from source \( A \) visits nodes in the order: \( A \) (distance 0), then \( B \), \( C \) (distance 1), and finally \( D \), \( E \) (distance 2).
      </p>
    </div>

    <svg viewBox="40 10 160 150" width="240" height="160" xmlns="http://www.w3.org/2000/svg">
      <!-- Edges -->
      <line x1="120" y1="30"  x2="60"  y2="80"  stroke="#333"/>
      <line x1="120" y1="30"  x2="180" y2="80"  stroke="#333"/>
      <line x1="60"  y1="80"  x2="60"  y2="140" stroke="#333"/>
      <line x1="180" y1="80"  x2="180" y2="140" stroke="#333"/>

      <!-- Nodes -->
      <circle cx="120" cy="30"  r="16" fill="#eef" stroke="#333"/>
      <text   x="120" y="35"  font-size="14" text-anchor="middle">A</text>

      <circle cx="60"  cy="80"  r="16" fill="#eef" stroke="#333"/>
      <text   x="60"  y="85"  font-size="14" text-anchor="middle">B</text>

      <circle cx="180" cy="80"  r="16" fill="#eef" stroke="#333"/>
      <text   x="180" y="85"  font-size="14" text-anchor="middle">C</text>

      <circle cx="60"  cy="140" r="16" fill="#eef" stroke="#333"/>
      <text   x="60"  y="145" font-size="14" text-anchor="middle">D</text>

      <circle cx="180" cy="140" r="16" fill="#eef" stroke="#333"/>
      <text   x="180" y="145" font-size="14" text-anchor="middle">E</text>
    </svg>
  </div>
</div>

<div class="example-box">
  <strong class="example-title">Example 2: BFS on a Cyclic Graph</strong>

  <div style="display: flex; align-items: flex-start; gap: 1.5em; margin-top: 0.5em;">
    <div style="flex: 1;">
      <p>
        In this graph, BFS from \( A \) visits \( A \) (distance 0), then \( B \) and \( C \) (distance 1), followed by \( D \) and \( E \) (distance 2).
        When visiting \( B \), the algorithm examines neighbors \( A \), \( C \), and \( E \). Since \( A \) and \( C \) have already been discovered, only \( E \) is enqueued.
        Similarly, when visiting \( C \), it checks \( A \), \( B \), and \( D \), and enqueues only \( D \).
        This behavior—skipping neighbors that were already visited—ensures that each vertex is discovered exactly once and at the earliest possible moment,
        which guarantees that its recorded distance from the source is correct.
      </p>
    </div>

    <svg viewBox="80 20 200 180" width="300" height="180" xmlns="http://www.w3.org/2000/svg">
      <!-- Edges -->
      <line x1="180" y1="40"  x2="100" y2="100" stroke="#333"/>
      <line x1="180" y1="40"  x2="260" y2="100" stroke="#333"/>
      <line x1="100" y1="100" x2="260" y2="100" stroke="#333"/>
      <line x1="260" y1="100" x2="260" y2="180" stroke="#333"/>
      <line x1="100" y1="100" x2="180" y2="180" stroke="#333"/>
      <line x1="180" y1="180" x2="260" y2="180" stroke="#333"/>

      <!-- Nodes -->
      <circle cx="180" cy="40"  r="18" fill="#eef" stroke="#333"/>
      <text   x="180" y="45"  font-size="14" text-anchor="middle">A</text>

      <circle cx="100" cy="100" r="18" fill="#eef" stroke="#333"/>
      <text   x="100" y="105" font-size="14" text-anchor="middle">B</text>

      <circle cx="260" cy="100" r="18" fill="#eef" stroke="#333"/>
      <text   x="260" y="105" font-size="14" text-anchor="middle">C</text>

      <circle cx="260" cy="180" r="18" fill="#eef" stroke="#333"/>
      <text   x="260" y="185" font-size="14" text-anchor="middle">D</text>

      <circle cx="180" cy="180" r="18" fill="#eef" stroke="#333"/>
      <text   x="180" y="185" font-size="14" text-anchor="middle">E</text>
    </svg>
  </div>
</div>

<div class="example-box">
  <strong class="example-title">Example 3: BFS on a Disconnected Graph</strong>

  <div style="display: flex; align-items: flex-start; gap: 1.5em; margin-top: 0.5em;">
    <div style="flex: 1;">
      <p>
        In this graph, a BFS starting at \( A \) explores only the left component:
        \( A \) (distance 0), \( B \), \( C \) (distance 1), \( D \), \( E \) (distance 2).
        Nodes \( F \) and \( G \) are not reachable from \( A \), so they are not discovered.
      </p>
    </div>

   <svg viewBox="40 30 300 170" width="340" height="180" xmlns="http://www.w3.org/2000/svg">
  <!-- Edges first (left component) -->
  <line x1="120" y1="50"  x2="60"  y2="110" stroke="#333"/>
  <line x1="120" y1="50"  x2="180" y2="110" stroke="#333"/>
  <line x1="60"  y1="110" x2="60"  y2="180" stroke="#333"/>
  <line x1="180" y1="110" x2="180" y2="180" stroke="#333"/>

  <!-- Edges (right component, moved closer) -->
  <line x1="260" y1="100" x2="300" y2="160" stroke="#333"/>

  <!-- Left component nodes -->
  <circle cx="120" cy="50"  r="18" fill="#eef" stroke="#333"/>
  <text   x="120" y="55"  font-size="14" text-anchor="middle">A</text>

  <circle cx="60"  cy="110" r="18" fill="#eef" stroke="#333"/>
  <text   x="60"  y="115" font-size="14" text-anchor="middle">B</text>

  <circle cx="180" cy="110" r="18" fill="#eef" stroke="#333"/>
  <text   x="180" y="115" font-size="14" text-anchor="middle">C</text>

  <circle cx="60"  cy="180" r="18" fill="#eef" stroke="#333"/>
  <text   x="60"  y="185" font-size="14" text-anchor="middle">D</text>

  <circle cx="180" cy="180" r="18" fill="#eef" stroke="#333"/>
  <text   x="180" y="185" font-size="14" text-anchor="middle">E</text>

  <!-- Right component nodes (closer) -->
  <circle cx="260" cy="100" r="18" fill="#eef" stroke="#333"/>
  <text   x="260" y="105" font-size="14" text-anchor="middle">F</text>

  <circle cx="300" cy="160" r="18" fill="#eef" stroke="#333"/>
  <text   x="300" y="165" font-size="14" text-anchor="middle">G</text>
</svg>
  </div>
</div>


<p>
  Breadth-First Search not only explores all vertices reachable from a source vertex \( s \), but also computes the shortest distance (in number of edges) from \( s \) to every other reachable vertex.
  To support this, the algorithm maintains a <code>dist</code> array (or map), where <code>dist[v]</code> records the number of edges from \( s \) to vertex \( v \).
  Optionally, BFS can also maintain a <code>pred</code> array (or map), where <code>pred[v]</code> stores the predecessor of \( v \) on the shortest path from \( s \), which allows reconstructing the full path later.
</p>

<p>Given a source vertex <code>s</code>, BFS proceeds as follows:</p>
<ol class="spaced">
  <li>Initialize all vertices as unvisited.</li>
  <li>Initialize arrays <code>dist[]</code> and <code>pred[]</code> with default values.</li>
  <li>Mark <code>s</code> as visited, set <code>dist[s] = 0</code>, <code>pred[s] = null</code>, and enqueue <code>s</code>.</li>
  <li>While the queue is not empty:
    <ol>
      <li>Dequeue vertex <code>u</code>.</li>
      <li>For each neighbor <code>v</code> of <code>u</code>:
        <ol>
          <li>If <code>v</code> is unvisited:
            <ol>
              <li>Mark <code>v</code> as visited.</li>
              <li>Set <code>dist[v] = dist[u] + 1</code>.</li>
              <li>Set <code>pred[v] = u</code>.</li>
              <li>Enqueue <code>v</code>.</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
<p>
  This procedure visits vertices in increasing order of their distance from <code>s</code>.
  The interactive demo below illustrates BFS on a sample graph, showing the layer-by-layer exploration.
  In the demo, vertex color indicates visit status: <span style="color:blue;">blue</span> nodes are unvisited, <span style="color:orange;">orange</span> nodes have been discovered but not fully processed, and <span style="color:green;">green</span> nodes have had all their neighbors explored.
  While the pseudocode uses a simple boolean <code>visited</code> array, implementations like the demo may use multiple states to track the progress of each vertex more precisely.
  The actual code implementations below show how this distinction can be made in practice.
</p>
  </section>

  <section id="demo">
    <div class="embeddedDemoContainer">
      <iframe class="embeddedDemo"
              src="/Algorithms/Content/Demos/Exhaustive Search/BFS Demo.html"
              allow="fullscreen"
              name="Breadth-First-Search-demo">
      </iframe>
    </div>
  </section>
  <p>
  This three-color model (unvisited, discovered, processed) is not only helpful for visualization — it plays an essential role in many algorithms built on top of BFS.
  For example, detecting whether a graph is bipartite involves assigning alternating colors to layers and checking for cross-layer conflicts,
  and certain cycle detection algorithms rely on distinguishing whether a neighbor has been fully processed or is still in the queue.
  While these ideas can be implemented using additional logic with a boolean <code>visited</code> array, the color/state distinction provides a more expressive and modular framework for reasoning about vertex status during traversal.
</p>
<p>
  To implement BFS effectively, you need several supporting data structures:
  a <code>visited[]</code> array (or equivalent state labels) to track which vertices have been discovered,
  a <code>queue</code> to manage the frontier of the search,
  a <code>dist[]</code> array to record the shortest distance from the source to each vertex,
  and optionally a <code>pred[]</code> array to store the predecessor of each vertex on its shortest path.
  The <code>dist</code> array is updated as soon as a vertex is first discovered, guaranteeing that it reflects the correct shortest-path length,
  and the <code>pred</code> array can be used after traversal to reconstruct the shortest path by walking backward from any vertex to the source.
</p>



  <section id="code">
    <h2>Implementation in Java, C++, Python</h2>
    <p>All implementations assume the graph is represented by an adjacency list. Each version computes the shortest distance <code>dist[v]</code> from the source <code>s</code>.</p>
    <div class="tab-group">
      <div class="tabs" role="tablist">
        <button id="tab-java" class="tablink active" data-lang="java" role="tab" aria-controls="java" aria-selected="true">Java</button>
        <button id="tab-cpp" class="tablink" data-lang="cpp" role="tab" aria-controls="cpp" aria-selected="false">C++</button>
        <button id="tab-python" class="tablink" data-lang="python" role="tab" aria-controls="python" aria-selected="false">Python</button>
      </div>
      <div id="java" class="code-container active" role="tabpanel" aria-labelledby="tab-java">
        <pre><code class="language-java">void bfs(List<Integer>[] graph, int s, int[] dist) {
    int n = graph.length;
    boolean[] visited = new boolean[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    Queue<Integer> q = new LinkedList<>();

    visited[s] = true;
    dist[s] = 0;
    q.add(s);

    while (!q.isEmpty()) {
        int u = q.poll();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                dist[v] = dist[u] + 1;
                q.add(v);
            }
        }
    }
}</code></pre>
      </div>
      <div id="cpp" class="code-container" role="tabpanel" aria-labelledby="tab-cpp">
        <pre><code class="language-cpp">void bfs(const vector<vector<int>>& graph, int s, vector<int>& dist) {
    int n = graph.size();
    vector<bool> visited(n, false);
    dist.assign(n, INT_MAX);
    queue<int> q;

    visited[s] = true;
    dist[s] = 0;
    q.push(s);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}</code></pre>
      </div>
      <div id="python" class="code-container" role="tabpanel" aria-labelledby="tab-python">
        <pre><code class="language-python">from collections import deque

def bfs(graph, s):
    n = len(graph)
    visited = [False] * n
    dist = [float('inf')] * n
    q = deque()

    visited[s] = True
    dist[s] = 0
    q.append(s)

    while q:
        u = q.popleft()
        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                dist[v] = dist[u] + 1
                q.append(v)
    return dist</code></pre>
      </div>
    </div>
  </section>

  <section id="analysis">
    <h2>Time/Space Analysis</h2>
    <p><strong>Time Complexity:</strong> BFS runs in <strong>\(O(V + E)\)</strong> time, where <em>V</em> is the number of vertices and <em>E</em> the number of edges. Each vertex is enqueued and dequeued at most once, and each edge is examined exactly once.</p>
    <p><strong>Space Complexity:</strong> BFS requires <strong>\(O(V)\)</strong> auxiliary space for the <code>visited</code> array and the queue. In the worst case, the queue may hold all vertices of a layer simultaneously.</p>

    <h2>Variations/Improvements</h2>
    <ul>
      <li><strong>Directed Graphs:</strong> BFS works on directed graphs by following outgoing edges in place of undirected ones.</li>
      <li><strong>Early Termination:</strong> Stop the search when a target vertex is found to save time.</li>
      <li><strong>Multiple Sources:</strong> Enqueue multiple starting vertices initially for problems like computing distance to the nearest of several goals.</li>
      <li><strong>Layer Tracking:</strong> Maintain a distance array <code>dist[]</code> (as shown) to capture the shortest-path distance from the source to every vertex.</li>
    </ul>
  </section>

  <section id="links">
    <h2>Links to Resources</h2>
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank">Wikipedia – Breadth-First Search</a></li>
      <li><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/" target="_blank">GeeksforGeeks – Breadth First Search for a Graph</a></li>
      <li><a href="https://visualgo.net/en/dfsbfs" target="_blank">VisuAlgo – Graph Traversal (BFS/DFS)</a></li>
      <li><a href="https://cp-algorithms.com/graph/breadth-first-search.html" target="_blank">CP-Algorithms – Breadth-First Search</a></li>
    </ul>
  </section>

  <section id="reading-questions">
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li><strong>Traversal Order:</strong> How does BFS determine the order in which vertices are visited?</li>
      <li><strong>Role of the Queue:</strong> Why does BFS use a queue and how does it ensure correct exploration order?</li>
      <li><strong>Shortest Path:</strong What guarantees that the first time BFS discovers a vertex it is via the shortest path?</li>
      <li><strong>Visited Set Purpose:</strong> What is the purpose of marking vertices as visited?</li>
      <li><strong>Time Complexity:</strong> What is the time complexity of BFS in terms of <em>V</em> and <em>E</em>?</li>
      <li><strong>Distance Tracking:</strong> How can BFS be modified to record the distance from the source to each vertex?</li>
    </ol>
    <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
    <div id="answers" class="answer" hidden>
      <ol>
        <li><strong>Answer:</strong> By exploring all vertices at distance <em>d</em> from the source before any at distance <em>d+1</em>.</li>
        <li><strong>Answer:</strong> A queue implements FIFO order, ensuring that vertices are processed in the sequence they were discovered (layer by layer).</li>
        <li><strong>Answer:</strong> Because vertices are enqueued in order of increasing distance, the first time a vertex is dequeued corresponds to the shortest path.</li>
        <li><strong>Answer:</strong> To prevent revisiting vertices and avoid infinite loops; each vertex is enqueued only once.</li>
        <li><strong>Answer:</strong> <em>O</em>(V + E), since each vertex and edge is processed at most once.</li>
        <li><strong>Answer:</strong> Maintain a distance array <code>dist[]</code>, setting <code>dist[v] = dist[u] + 1</code> when a neighbor <code>v</code> is discovered from <code>u</code>.</li>
      </ol>
    </div>
  </section>

  <section id="activities">
    <h2>In-Class Activities</h2>
    <ol>
      <li><strong>Manual BFS Trace:</strong> Hand-trace BFS on a small graph, recording the order of discovery and queue contents at each step.</li>
      <li><strong>Layer Identification:</strong> Given a graph and start vertex, label vertices by their distance (layer) from the source.</li>
      <li><strong>Explore the Demo:</strong> Use the embedded BFS visualization on different graphs and discuss how it illustrates the frontier expansion.</li>
      <li><strong>BFS vs. DFS:</strong> Perform both BFS and DFS on the same graph, compare visit orders, and discuss scenarios favoring each.</li>
      <li><strong>Bipartiteness Test:</strong> Apply BFS-based 2-coloring to determine if a given graph is bipartite by assigning alternating colors per layer.</li>
      <li><strong>Connected Components:</strong> Use repeated BFS runs starting from unvisited vertices to identify all components of a disconnected graph.</li>
      <li><strong>Shortest Path Maze:</strong> Model a maze as a grid graph and use BFS on paper to find the shortest path from entrance to exit.</li>
    </ol>
  </section>

  <section id="problems">
    <h2>Homework Problems</h2>
    <ol>
      <li><strong>BFS Traversal Tree:</strong> Given an adjacency list, run BFS from vertex <code>0</code> and record the parent of each vertex in the BFS tree.</li>
      <li><strong>Distance Discovery:</strong> For the graph in Problem 1, compute and list the discovery layer for each vertex.</li>
      <li><strong>Disconnected Graph Coverage:</strong> Develop a strategy using BFS from multiple start vertices to traverse all components of a disconnected graph.</li>
      <li><strong>Compare BFS and DFS:</strong> For a given graph, list the order of vertex discovery for both BFS and DFS and explain the differences.</li>
      <li><strong>Shortest Path:</strong> Use BFS to find the shortest path between two specified vertices in an unweighted graph and write out the path sequence.</li>
      <li><strong>Bipartiteness Check:</strong> Implement a BFS-based algorithm to test if a graph is bipartite and explain the coloring result.</li>
      <li><strong>Cycle Detection:</strong> Modify BFS to detect cycles in an undirected graph and apply it to a sample graph to determine if a cycle exists.</li>
      <li><strong>Multi-Source BFS:</strong> Explain how to initialize and run BFS from multiple source vertices to find the nearest of several goal nodes.</li>
    </ol>
  </section>

</body>
</html>
