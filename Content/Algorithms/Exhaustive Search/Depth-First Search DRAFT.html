<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Depth-First Search</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
</head>
<body>
<h1>Depth-First Search</h1>

<section id="problem-solved">
  <h2>Problem Solved</h2>
  <p>
    Depth-First Search (DFS) solves the
    <a class="problem" href="?path=Problems%2FGraphs%2FGraph%20Traversal">Graph Traversal</a>
    problem.
  </p>
</section>

<section id="design">
  <h2>Design and Strategy</h2>
  <p>
    DFS explores a graph by diving as deep as possible along each branch before backtracking. It builds a traversal tree that reveals the structure of the graph, including which vertices are reachable from a given starting point and the order in which they are visited. This depth-first approach often uncovers recursive or hierarchical structures in the graph, making it well-suited for applications such as detecting cycles, exploring connected components, and performing topological sorts (in directed acyclic graphs).
  </p>
  <p>
    The algorithm is typically implemented recursively using a helper function, though an iterative version using an explicit stack is also possible. As each vertex is visited, we record the time it was first discovered (called the <em>discovery time</em>) and the time it was fully explored (called the <em>finish time</em>). These timestamps provide valuable insight into the traversal's structure and are used to classify edges and analyze graph properties.
  </p>
  <p>
    The overall DFS process consists of two parts. The main function iterates through all vertices in the graph, starting a DFS traversal at each unexplored vertex. This ensures that the algorithm fully explores every component, even in disconnected graphs. The recursive helper function, when called on a vertex, explores all of its neighbors that have not yet been visited—diving deeper into the graph until it reaches a dead end, at which point it backtracks.
  </p>
<p>
  To understand the process more concretely, imagine starting at some vertex \( v \). We mark \( v \) as visited and record its discovery time. Then, for each of its neighbors \( u \), if \( u \) has not yet been visited, we record that \( u \)'s parent is \( v \) and recursively explore \( u \) in the same way. This exploration continues down a single path as far as possible. Once we reach a vertex whose neighbors are all visited, we record its finish time and backtrack to continue exploring other unexplored neighbors of its parent. These recursive calls naturally form a DFS tree (or forest, if the graph is disconnected), where each tree edge corresponds to a discovery of a new vertex. The timestamps allow us to reason about the order of visits and the relationship between vertices, and help classify edges into categories like tree and back edges.
</p>
<p>Here is a more formal description of the algorithm in pseudocode:</p>
  <ol class="spaced">
  <li><code>dfs()</code>
    <ol>
      <li>Let <code>n</code> be the number of vertices in the graph.</li>
      <li>Create arrays of size <code>n</code>:
        <ul>
          <li><code>visited[0..n−1] = false</code></li>
          <li><code>parent[0..n−1] = −1</code></li>
          <li><code>discovery[0..n−1] = −1</code></li>
          <li><code>finish[0..n−1] = −1</code></li>
        </ul>
      </li>
      <li>Set <code>time = 0</code></li>
      <li>For each vertex <code>v</code> from <code>0</code> to <code>n−1</code>:
        <ul>
          <li>If <code>visited[v] = false</code>, call <code>dfsVisit(v)</code></li>
        </ul>
      </li>
    </ol>
  </li>
  <li><code>dfsVisit(v)</code>
    <ol>
      <li>Set <code>visited[v] = true</code></li>
      <li>Increment <code>time</code>; set <code>discovery[v] = time</code></li>
      <li>For each neighbor <code>u</code> of <code>v</code>:
        <ul>
          <li>If <code>visited[u] = false</code>:
            <ul>
              <li>Set <code>parent[u] = v</code></li>
              <li>Call <code>dfsVisit(u)</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Increment <code>time</code>; set <code>finish[v] = time</code></li>
    </ol>
  </li>
</ol>

<p>Here is a demonstration of the algorithm that should help see what is happening.</p>

<section id="demo">
  <div class="embeddedDemoContainer">
    <iframe class="embeddedDemo"
            src="/Algorithms/Content/Demos/Exhaustive%20Search/DFS%20Demo.html"
            allow="fullscreen"
            name="depth-first-search-demo">
    </iframe>
  </div>
</section>

<h3>Timestamps</h3>
<p>
  As previously mentioned, during a DFS traversal, each vertex is assigned two timestamps using a single global counter:
</p>
<ul>
  <li><strong>Discovery time:</strong> the moment a vertex is first encountered and marked as visited.</li>
  <li><strong>Finish time:</strong> the moment all descendants of a vertex have been fully explored and the recursive call is about to return.</li>
</ul>
<p>
  These timestamps reflect the structure of the DFS traversal and help characterize the relationships between vertices—for example, whether one vertex is a descendant of another in the DFS tree. In directed graphs, they are especially useful for identifying structural relationships like ancestry and edge directionality, which are key in classifying edges and analyzing connectivity.
</p>



<h3>Edge Classification in Undirected Graphs</h3>
<p>
  Once the traversal is complete, we can classify each edge \((u, v)\) based on the relationship between \(u\) and \(v\) in the DFS forest. The classification depends on whether the graph is undirected or directed.
</p>
<ul>
  <li><strong>Tree edge:</strong> \(v\) was undiscovered when \(u\) visited it. These edges form the DFS tree (or forest in disconnected graphs). Tree edges cannot be identified by timestamps alone—they must be recorded during DFS using a <code>parent</code> array.</li>
  <li><strong>Back edge:</strong> \(v\) was already discovered but not yet finished when encountered from \(u\), and \(v\) is <em>not</em> the parent of \(u\). After the traversal, a back edge can be identified by checking that neither \(v = \text{parent}[u]\) nor \(u = \text{parent}[v]\). These edges indicate a cycle in the graph.</li>
</ul>

<h2>DFS on Directed Graphs</h2>

<p>
Let's see how the algorithm is different (and not) for directed graphs.
</p>

<section id="demo">
  <div class="embeddedDemoContainer">
    <iframe class="embeddedDemo"
            src="/Algorithms/Content/Demos/Exhaustive%20Search/DFS (Directed) Demo.html"
            allow="fullscreen"
            name="depth-first-search-demo">
    </iframe>
  </div>
</section>


<h3>Edge Classification in Directed Graphs</h3>
<ul>
  <li><strong>Tree edge:</strong> Same as in the undirected case—\(v\) was first discovered via \((u, v)\). Must use <code>parent</code> array to identify.</li>
  <li><strong>Back edge:</strong> \(v\) is an ancestor of \(u\). These always indicate a cycle. Satisfies:<br>
    \[
      d[v] < d[u] < f[u] < f[v]
    \]</li>
  <li><strong>Forward edge:</strong> \(v\) is a descendant of \(u\) and has already been fully explored. Satisfies:<br>
    \[
      d[u] < d[v] < f[v] < f[u]
    \]<br>
    but unlike tree edges, \(v\) is not a child of \(u\) in the DFS tree.</li>
  <li><strong>Cross edge:</strong> \(v\) has already been fully explored and is not a descendant of \(u\). Typically connects separate DFS trees or unrelated branches. Satisfies:<br>
    \[
      f[v] < d[u]
    \]</li>
</ul>

<p>
  Note that only back, forward, and cross edges can be identified from timestamps alone. Tree edges require structural information—specifically, whether \(u\) was recorded as the parent of \(v\) during the DFS.
</p>

<p>
  These edge relationships play a central role in many graph algorithms:
</p>
<ul>
  <li><strong>Back edges</strong> reveal cycles (especially in directed graphs)</li>
  <li><strong>Tree edges</strong> define the DFS forest used in structure-sensitive algorithms</li>
  <li><strong>Timestamps</strong> support efficient identification of:
    <ul>
      <li>Articulation points and bridges (undirected)</li>
      <li>Strongly connected components (Tarjan’s or Kosaraju’s algorithm)</li>
      <li>Topological sorts (in DAGs)</li>
    </ul>
  </li>
</ul>

<p>
  In short, discovery and finish times provide a timestamped record of the traversal that reveals the structural and temporal relationships between vertices—information that is crucial to many graph-based algorithms and analyses.
</p>

<p>
  The following table summarizes how DFS classifies edges based on the relationship between two vertices \( u \) and \( v \), where the edge \((u, v)\) is explored during the traversal of vertex \( u \). It compares the structural meaning of each edge type and explains how they are identified in both undirected and directed graphs, including the relevant timestamp conditions (where applicable).
</p>

<table class="example-table left-align">
  <thead>
    <tr>
      <th>Edge Type</th>
      <th>Structural Meaning</th>
      <th>Undirected Graph</th>
      <th>Directed Graph</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Tree</strong></td>
      <td>\(v\) was first discovered via edge \((u, v)\); becomes child of \(u\)</td>
      <td>
        <ul>
          <li>\(v\) was undiscovered when visited from \(u\)</li>
          <li>Must track <code>parent[v] = u</code></li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Same as undirected</li>
          <li>Timestamps satisfy:<br>\(d[u] < d[v] < f[v] < f[u]\)</li>
          <li>But same condition may also describe a forward edge</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Back</strong></td>
      <td>\(v\) is an ancestor of \(u\) in DFS tree</td>
      <td>
        <ul>
		  <li>\(v\) was already discovered when visited from \(u\)</li>
		  <li>\((u, v)\) is <em>not</em> a tree edge:
			neither \(v = \text{parent}[u]\) nor \(u = \text{parent}[v]\)
		  </li>
		  <li>Back edges indicate the presence of a cycle</li>
		</ul>
      </td>
      <td>
        <ul>
          <li>Timestamps:<br>\(d[v] < d[u] < f[u] < f[v]\)</li>
          <li>Indicates a cycle</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Forward</strong></td>
      <td>\(v\) is a descendant of \(u\), but already finished</td>
      <td><em>Not applicable</em></td>
      <td>
        <ul>
          <li>Timestamps:<br>\(d[u] < d[v] < f[v] < f[u]\)</li>
          <li>\(v\) is not a direct child of \(u\)</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>Cross</strong></td>
      <td>\(v\) is in another subtree or component (no DFS tree relationship)</td>
      <td><em>Not applicable</em></td>
      <td>
        <ul>
          <li>Timestamps:<br>\(f[v] < d[u]\)</li>
          <li>No ancestor/descendant relationship</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

FOOOO


<p>
  As previously mentioned, during a DFS traversal, each vertex is assigned two timestamps using a single global counter:
</p>
<ul>
  <li><strong>Discovery time:</strong> the moment a vertex is first encountered and marked as visited.</li>
  <li><strong>Finish time:</strong> the moment all descendants of a vertex have been fully explored and the recursive call is about to return.</li>
</ul>
<p>
  These timestamps reflect the structure of the DFS traversal and help characterize the relationships between vertices—for example, whether one vertex is a descendant of another in the DFS tree. In directed graphs, they are especially useful for identifying structural relationships like ancestry and edge directionality, which are key in classifying edges and analyzing connectivity.
</p>

<p>
  Once the traversal is complete, we can classify each edge \( (u, v) \) based on the state of vertex \( v \) at the time it is explored from vertex \( u \):
</p>
<ul>
  <li><strong>Tree edge:</strong> \( v \) was undiscovered when \( u \) visited it. 
  These edges form the DFS tree (or forest for unconnected graphs).</li>
  <li><strong>Back edge:</strong> \( v \) was discovered but not yet finished—i.e., it is an ancestor of \( u \) in the DFS tree.</li>
</ul>
<p>
  These are the only two types of edges that can appear in an undirected graph.
</p>

<p>
  In a directed graph, two additional types of edges may occur:
</p>
<ul>
  <li><strong>Forward edge:</strong> \( v \) was already fully explored and is a descendant of \( u \) in the DFS tree.</li>
  <li><strong>Cross edge:</strong> \( v \) was already fully explored and is not a descendant of \( u \); the edge connects two unrelated subtrees or components.</li>
</ul>

<p>
  Timestamps are critical for determining these relationships. For example, a back edge from \( u \) to \( v \) in a directed graph will satisfy the condition:
  \[
    \text{discovery}[v] < \text{discovery}[u] < \text{finish}[u] < \text{finish}[v]
  \]
  indicating that \( v \) was discovered before \( u \) and not yet finished when \( u \) encountered it.
</p>

<p>
  These relationships play a central role in many algorithms, including:
</p>
<ul>
  <li>Detecting cycles (via back edges)</li>
  <li>Identifying articulation points and bridges in undirected graphs</li>
  <li>Finding strongly connected components (e.g., Tarjan’s or Kosaraju’s algorithm)</li>
  <li>Producing topological sorts of directed acyclic graphs</li>
</ul>
<p>
  In short, the discovery and finish times provide a timestamped record of the traversal, revealing hierarchical and structural relationships in the graph that are not immediately visible from the adjacency lists alone.
</p>


</section>


<section id="code">
  <h2>Implementation in Java, C++, Python</h2>
  <p>Each implementation uses an adjacency list representation. Arrays track discovery and finish times.</p>
  <div class="tab-group">
    <div class="tabs" role="tablist">
      <button id="tab-java" class="tablink active" data-lang="java" role="tab" aria-controls="java" aria-selected="true">Java</button>
      <button id="tab-cpp" class="tablink" data-lang="cpp" role="tab" aria-controls="cpp" aria-selected="false">C++</button>
      <button id="tab-python" class="tablink" data-lang="python" role="tab" aria-controls="python" aria-selected="false">Python</button>
    </div>
    <div id="java" class="code-container active" role="tabpanel" aria-labelledby="tab-java">
      <pre><code class="language-java">void dfs(List&lt;Integer&gt;[] adj, int n) {
    boolean[] visited = new boolean[n];
    int[] discovery = new int[n];
    int[] finish = new int[n];
    int[] parent = new int[n];
    Arrays.fill(parent, -1);
    time = 0;
    for (int v = 0; v &lt; n; v++) {
        if (!visited[v]) {
            dfsVisit(v, adj, visited, discovery, finish, parent);
        }
    }
}

int time = 0;

void dfsVisit(int v, List&lt;Integer&gt;[] adj, boolean[] visited,
              int[] discovery, int[] finish, int[] parent) {
    visited[v] = true;
    discovery[v] = ++time;
    for (int u : adj[v]) {
        if (!visited[u]) {
            parent[u] = v;
            dfsVisit(u, adj, visited, discovery, finish, parent);
        }
    }
    finish[v] = ++time;
}</code></pre>
    </div>
    <div id="cpp" class="code-container" role="tabpanel" aria-labelledby="tab-cpp">
      <pre><code class="language-cpp">void dfs(vector&lt;int&gt; adj[], int n) {
    vector&lt;bool&gt; visited(n, false);
    vector&lt;int&gt; discovery(n), finish(n), parent(n, -1);
    time = 0;
    for (int v = 0; v &lt; n; v++) {
        if (!visited[v]) {
            dfsVisit(v, adj, visited, discovery, finish, parent);
        }
    }
}

int time = 0;

void dfsVisit(int v, vector&lt;int&gt; adj[], vector&lt;bool&gt;& visited,
              vector&lt;int&gt;& discovery, vector&lt;int&gt;& finish, vector&lt;int&gt;& parent) {
    visited[v] = true;
    discovery[v] = ++time;
    for (int u : adj[v]) {
        if (!visited[u]) {
            parent[u] = v;
            dfsVisit(u, adj, visited, discovery, finish, parent);
        }
    }
    finish[v] = ++time;
}</code></pre>
    </div>
    <div id="python" class="code-container" role="tabpanel" aria-labelledby="tab-python">
      <pre><code class="language-python">def dfs(adj, n):
    visited = [False] * n
    discovery = [0] * n
    finish = [0] * n
    parent = [-1] * n
    
    def dfsVisit(v):
        nonlocal time
        visited[v] = True
        time += 1
        discovery[v] = time
        for u in adj[v]:
            if not visited[u]:
                parent[u] = v
                dfsVisit(u)
        time += 1
        finish[v] = time

    time = 0
    for v in range(n):
        if not visited[v]:
            dfsVisit(v)</code></pre>
    </div>
  </div>
</section>

<section id="analysis">
  <h2>Time/Space Analysis</h2>
  <p><strong>Time Complexity:</strong> \(O(V + E)\). Each vertex is visited once, and each edge is examined once (undirected) or twice (directed).</p>
  <p><strong>Space Complexity:</strong> \(O(V)\) for visited, discovery, finish, and parent arrays.</p>
</section>

<section id="variations">
  <h2>Variations/Improvements</h2>
  <ul>
    <li>DFS can be used for cycle detection, topological sort (for DAGs), and connected component detection.</li>
    <li>An iterative version using an explicit stack can avoid recursion.</li>
    <li>In directed graphs, DFS classifies edges into tree, back, forward, and cross edges, which aids in algorithms like finding strongly connected components.</li>
  </ul>
</section>

<section id="links">
  <h2>Links to Resources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank">Wikipedia: Depth-First Search</a></li>
    <li><a href="https://visualgo.net/en/dfsbfs" target="_blank">VisuAlgo: DFS & BFS Visualizations</a></li>
    <li><a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" target="_blank">GeeksforGeeks: DFS for Graph</a></li>
  </ul>
</section>

<section id="reading-questions">
  <h2>Reading Comprehension Questions</h2>
  <ol>
    <li><strong>Discovery and Finish:</strong> What do the discovery and finish times of a vertex represent in DFS?</li>
    <li><strong>Recursion Mechanics:</strong> Why do we set the finish time <em>after</em> visiting all neighbors?</li>
    <li><strong>Edge Types:</strong> What are tree and back edges in undirected DFS?</li>
    <li><strong>Edge Order:</strong> How does DFS differ from BFS in terms of the order vertices are explored?</li>
    <li><strong>Component Coverage:</strong> How does DFS handle disconnected graphs?</li>
  </ol>
  <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
  <div id="answers" class="answer" hidden>
    <ol>
      <li><strong>Answer:</strong> Discovery time is when the vertex is first visited; finish time is when all its descendants have been fully explored.</li>
      <li><strong>Answer:</strong> To ensure all paths through that vertex are explored before marking it finished.</li>
      <li><strong>Answer:</strong> A tree edge leads to an undiscovered vertex; a back edge connects to an ancestor.</li>
      <li><strong>Answer:</strong> DFS explores as deep as possible before backtracking; BFS explores all neighbors before going deeper.</li>
      <li><strong>Answer:</strong> The outer loop ensures DFSVisit is called for every unvisited vertex, covering all components.</li>
    </ol>
  </div>
</section>

<section id="activities">
  <h2>In-Class Activities</h2>
  <ol>
    <li><strong>Manual Trace:</strong> Trace DFS by hand on an undirected graph and record discovery/finish times.</li>
    <li><strong>Tree vs Back Edges:</strong> Classify edges as tree or back after a DFS run.</li>
    <li><strong>Cycle Detection:</strong> Modify DFS to detect cycles in an undirected graph.</li>
    <li><strong>Compare to BFS:</strong> Run DFS and BFS on the same graph and compare orderings and structures.</li>
    <li><strong>Edge Classification in Directed Graph:</strong> Extend DFS to classify all edge types in a directed graph.</li>
    <li><strong>Disconnected Graphs:</strong> Use DFS to identify connected components in a graph with multiple parts.</li>
  </ol>
</section>

<section id="problems">
  <h2>Homework Problems</h2>
  <ol>
    <li><strong>DFS Trace:</strong> Given a graph, simulate DFS and report discovery and finish times for each vertex.</li>
    <li><strong>Edge Types:</strong> Classify edges into tree/back (undirected) or tree/back/forward/cross (directed).</li>
    <li><strong>DFS Tree:</strong> Construct the DFS tree based on parent pointers.</li>
    <li><strong>Iterative DFS:</strong> Implement DFS using a stack instead of recursion.</li>
    <li><strong>Cycle Detection:</strong> Write an algorithm using DFS to detect if a cycle exists in an undirected graph.</li>
    <li><strong>DFS Application:</strong> Use DFS to count the number of connected components.</li>
  </ol>
</section>

</body>
</html>
