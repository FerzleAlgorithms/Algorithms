<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Subset Sum (Exhaustive Search)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
</head>
<body>
  <h1>Subset Sum (Exhaustive Search)</h1>

  <section id="problem-solved">
    <h2>Problem Solved</h2>
    <p>
      Here we will describe the exhaustive search algorithm to solve the 
      <a class="problem" href="?path=Problems%2FOther%2FSubset%20Sum">Subset Sum</a>
      problem.
    </p>
  </section>

<section id="design">
  <h2>Design and Strategy</h2>
  <p>
    The exhaustive search algorithm for the Subset Sum problem generates and checks all possible subsets of the input set to determine whether any of them sum to a given target value \( T \). Since a set of size \( n \) has \( 2^n \) subsets, the algorithm examines each one in turn.
  </p>
  <p>
  There are many ways of generating all subsets. 
  Here we will describe an algorithm that involves using binary masks. 
    The subsets are generated by iterating over all binary masks of length \( n \), where each bit indicates whether the corresponding element is included (1) or excluded (0) from the subset. For each mask, the algorithm constructs the corresponding subset, computes its sum, and checks whether the sum equals \( T \).
  </p>
 <div class="example-box">
  <strong class="example-title">Example</strong><br><br>
  Let the input set be \( S = \{2, 5, 8\} \) and the target sum \( T = 10 \).<br><br>

  There are \( 2^3 = 8 \) subsets, corresponding to binary masks from \( 000 \) to \( 111 \). Each bitmask selects a subset by indicating inclusion (1) or exclusion (0) for each element in <em>low-to-high order</em>, where:
  <ul>
    <li>Bit 0 (rightmost) corresponds to 2,</li>
    <li>Bit 1 to 5,</li>
    <li>Bit 2 to 8.</li>
  </ul>

  <table class="example-table">
    <thead>
      <tr>
        <th>Index</th>
        <th>Bitmask</th>
        <th>Subset</th>
        <th>Sum</th>
        <th>Matches Target?</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>0</td><td>000</td><td>\(\{\}\)</td><td>0</td><td>No</td></tr>
      <tr><td>1</td><td>001</td><td>\(\{2\}\)</td><td>2</td><td>No</td></tr>
      <tr><td>2</td><td>010</td><td>\(\{5\}\)</td><td>5</td><td>No</td></tr>
      <tr><td>3</td><td>011</td><td>\(\{2, 5\}\)</td><td>7</td><td>No</td></tr>
      <tr><td>4</td><td>100</td><td>\(\{8\}\)</td><td>8</td><td>No</td></tr>
      <tr><td>5</td><td>101</td><td>\(\{2, 8\}\)</td><td>10</td><td><strong>Yes</strong></td></tr>
      <tr><td>6</td><td>110</td><td>\(\{5, 8\}\)</td><td>13</td><td>No</td></tr>
      <tr><td>7</td><td>111</td><td>\(\{2, 5, 8\}\)</td><td>15</td><td>No</td></tr>
    </tbody>
  </table>

  <br>
  The subset \(\{2, 8\}\) has sum 10, which matches the target.
</div>

  <p>In general, the algorithm proceeds as follows:</p>
  <ol class="spaced">
    <li>For each integer \( m \) from \( 0 \) to \( 2^n - 1 \): 
      <ol>
        <li>Interpret the binary representation of \( m \) as a subset mask over the \( n \) elements.</li>
        <li>Construct the subset by including each element whose corresponding bit is 1.</li>
        <li>Compute the sum of the elements in the subset.</li>
        <li>If the sum equals the target \( T \), record the subset as a solution.</li>
      </ol>
    </li>
    <li>After generating all subsets, return the full list of solutions or determine that none exist.</li>
  </ol>
</section>

  <section id="demo">
  <p>The following demo shows the algorithm in action.</p>
    <div class="embeddedDemoContainer">
      <iframe class="embeddedDemo"
              src="/Algorithms/Content/Demos/Exhaustive%20Search/Subset%20Sum%20Demo.html"
              allow="fullscreen"
              name="Subset_Sum_demo">
      </iframe>
    </div>
  </section>

<section id="code">
  <h2>Implementation in Java, C++, Python</h2>
  <p>
    These implementations generate all \( 2^n \) subsets using bitmasks and print any subset whose elements sum to the target value.
  </p>
  <div class="tab-group">
    <div class="tabs" role="tablist">
      <button id="tab-java" class="tablink active" data-lang="java" role="tab" aria-controls="java" aria-selected="true">Java</button>
      <button id="tab-cpp" class="tablink" data-lang="cpp" role="tab" aria-controls="cpp" aria-selected="false">C++</button>
      <button id="tab-python" class="tablink" data-lang="python" role="tab" aria-controls="python" aria-selected="false">Python</button>
    </div>
    <div id="java" class="code-container active" role="tabpanel" aria-labelledby="tab-java">
      <pre><code class="language-java">void subsetSum(int[] S, int T) {
    int n = S.length;
    int total = 1 &lt;&lt; n; // 2^n
    for (int mask = 0; mask &lt; total; mask++) {
        int sum = 0;
        List&lt;Integer&gt; subset = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            if ((mask &amp; (1 &lt;&lt; i)) != 0) {
                subset.add(S[i]);
                sum += S[i];
            }
        }
        if (sum == T) {
            System.out.println(subset);
        }
    }
}</code></pre>
    </div>
    <div id="cpp" class="code-container" role="tabpanel" aria-labelledby="tab-cpp">
      <pre><code class="language-cpp">
void subsetSum(int S[], int n, int T) {
    int total = 1 &lt;&lt; n; // 2^n
    int* subset = new int[n]; 
    for (int mask = 0; mask &lt; total; mask++) {
        int sum = 0, k = 0;
        for (int i = 0; i &lt; n; i++) {
            if (mask &amp; (1 &lt;&lt; i)) {
                subset[k++] = S[i];
                sum += S[i];
            }
        }
        if (sum == T) {
            cout &lt;&lt; "{ ";
            for (int j = 0; j &lt; k; j++) {
                cout &lt;&lt; subset[j] &lt;&lt; " ";
            }
            cout &lt;&lt; "}" &lt;&lt; endl;
        }
    }
}</code></pre>
    </div>
    <div id="python" class="code-container" role="tabpanel" aria-labelledby="tab-python">
      <pre><code class="language-python">def subset_sum(S, T):
    n = len(S)
    for mask in range(1 &lt;&lt; n):
        subset = []
        total = 0
        for i in range(n):
            if mask &amp; (1 &lt;&lt; i):
                subset.append(S[i])
                total += S[i]
        if total == T:
            print(subset)</code></pre>
    </div>
  </div>
</section>
<section id="analysis">
  <h2>Time/Space Analysis</h2>
  <p>
    <strong>Time Complexity:</strong> An input set of size \( n \) has \( 2^n \) subsets. The algorithm loops through all bitmasks from \( 0 \) to \( 2^n - 1 \), and for each mask, it checks which elements are included and computes the sum of the corresponding subset. The inner loop runs in \( O(n) \) time per subset, so the total time complexity is
    \(O(n \cdot 2^n).\)
    This is optimal for exhaustive enumeration, since there are \( 2^n \) subsets and each one may contain up to \( n \) elements.
  </p>

  <p>
    <strong>Space Complexity:</strong> The algorithm uses \( O(n) \) extra space to store the current subset being considered. No recursion is used, and only a few additional local variables. 
	The total space used is \(O(n)\). 
    If the algorithm also stores all matching subsets, then the output space could be as large as \( O(k \cdot n) \), where \( k \) is the number of solutions.
  </p>
</section>
  
  <section id="variations">
  <h2>Variations/Improvements</h2>
  <ul>
    <li><strong>Dynamic Programming:</strong> A pseudo-polynomial solution runs in \(O(n \times T)\) time and \(O(T)\) space by building a table of reachable sums. Efficient when the target \(T\) is not too large.</li>
    <li><strong>Meet-in-the-Middle:</strong> Split the input into two halves, generate all subset sums of each half, and look for complementary pairs. This reduces time complexity to \(O(2^{n/2})\) with additional sorting or hashing.</li>
    <li><strong>Backtracking and Pruning:</strong> Use recursion with early exits: stop exploring a subset if its sum exceeds \(T\), or if the remaining elements cannot bridge the gap. Helps in practice but does not improve worst-case complexity.</li>
    <li><strong>Special Cases:</strong> Subset Sum is a special case of the 0-1 Knapsack problem (with equal weights and values), and also relates to the Partition problem. Techniques for these problems may apply.</li>
  </ul>
</section>

<section id="links">
  <h2>Links to Resources</h2>
  <ul class="resource-list">
    <li><a href="https://en.wikipedia.org/wiki/Subset_sum_problem" target="_blank">Subset Sum Problem (Wikipedia)</a></li>
    <li><a href="https://www.geeksforgeeks.org/dsa/subset-sum-problem/" target="_blank">Subset Sum Problem (GeeksforGeeks)</a></li>
    <li><a href="https://www.numberanalytics.com/blog/ultimate-guide-subset-sum-problem-dynamic-programming" target="_blank">Subset Sum Tutorial (NumberAnalytics)</a></li>
    <li><a href="https://www.geeksforgeeks.org/dsa/meet-in-the-middle/" target="_blank">Meet‑in‑the‑Middle Technique (GeeksforGeeks)</a> Describes the meet-in-the-middle algorithm for the variation where the largest sum \(\leq T\) is sought.</li>
  </ul>
</section>


 <section id="reading-questions">
  <h2>Reading Comprehension Questions</h2>
  <ol>
    <li>How many subsets are there of a set with \( n \) elements? How is this related to bitmasks?</li>
    <li>What does each bit in the binary representation of a number represent in this algorithm?</li>
    <li>Why does the algorithm need to examine every subset in the worst case?</li>
    <li>What does the inner loop do for each bitmask?</li>
    <li>How is a subset’s sum computed, and how is it compared to the target?</li>
    <li>What is the overall time complexity of the algorithm, and where does each part come from?</li>
    <li>What is the space complexity of the algorithm if we only store the current subset?</li>
    <li>What would happen if the input list had duplicate numbers? Would the algorithm still work correctly?</li>
  </ol>
  <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
  <div id="answers" class="answer" hidden>
    <ol>
      <li><strong>Answer:</strong> A set of size \( n \) has \( 2^n \) subsets. Each subset corresponds to a bitmask of length \( n \), where each bit encodes inclusion or exclusion of an element.</li>
      <li><strong>Answer:</strong> Each bit in the bitmask indicates whether to include the corresponding element from the input set: 1 means included, 0 means excluded.</li>
      <li><strong>Answer:</strong> Because any subset could be the one that sums to the target, and there is no structure to prune the search, we must examine all subsets to be sure.</li>
      <li><strong>Answer:</strong> For each bitmask, the inner loop checks which bits are 1 and uses that to build the subset and compute its sum.</li>
      <li><strong>Answer:</strong> The sum is computed by adding the values of all elements selected by the bitmask. If the sum equals the target, the subset is recorded or printed.</li>
      <li><strong>Answer:</strong> The total time is \( O(n \cdot 2^n) \): there are \( 2^n \) subsets, and each one can take up to \( n \) steps to evaluate.</li>
      <li><strong>Answer:</strong> The space complexity is \( O(n) \), which accounts for storing the current subset being examined.</li>
      <li><strong>Answer:</strong> Yes, the algorithm still works correctly with duplicate numbers. Each bitmask uniquely defines a subset by position, even if values repeat.</li>
    </ol>
  </div>
</section>

<section id="activities">
  <h2>In-Class Activities</h2>
  <ol>
  <li>
  <strong>Bitmask Mechanics:</strong> Let \( S = \{4, 7, 9\} \), so \( n = 3 \). There are 8 bitmasks from 000 to 111.
  For each value of <code>mask</code> from 0 to 7:
  <ul>
    <li>Write its 3-bit binary representation.</li>
    <li>For each index \( i \) from 0 to 2, evaluate <code>(mask &amp; (1 &lt;&lt; i))</code> and explain whether element \( S[i] \) is included.</li>
    <li>List the resulting subset.</li>
  </ul>
  What pattern do you notice? How does the expression <code>(mask &amp; (1 &lt;&lt; i))</code> relate to inclusion of each element?
</li>
    <li>
      <strong>Manual Tracing:</strong> Manually trace the bitmask algorithm on the input set \( S = \{1, 3, 4, 7\} \) with target \( T = 8 \). List all 16 subsets and mark which ones are solutions.
    </li>
    <li>
      <strong>Demo Exploration:</strong> Use the interactive demo to find all solutions for \( S = \{2, 5, 8, 11\} \) and target \( T = 16 \). Are there a lot or a few solutions, relative to 
	  the total number of subsets?
    </li>
    <li>
      <strong>Empty and Oversized Sets:</strong> Try running the algorithm when all elements are larger than the target (e.g., \( S = \{10, 12, 15\} \), \( T = 5 \)). What happens and why?
    </li>
    <li>
      <strong>Fixed-Size Subsets:</strong> Modify the algorithm or tracing process to only consider subsets of size 3. How many such subsets are there? Do any sum to your chosen target?
	  What are the advantages and disadvantages to an approach like this?
    </li>
    <li>
      <strong>Product-Based Search:</strong> Design a brute-force algorithm similar to Subset Sum to find if any subset of numbers has product exactly \( P \). What changes must be made?
    </li>
    <li>
      <strong>Count Instead of Print:</strong> Modify the bitmask-based code so that it counts how many subsets sum to the target, rather than printing them.
    </li>
    <li>
  <strong>Scalability Calculation:</strong> Suppose the algorithm runs in \( 5n 2^n \) steps for input size \( n \), and assume a computer can process 100 million steps per second. 
  <ul>
    <li>About how long (in seconds, hours, or days) would it take to solve the problem for \( n = 25 \)? What about \( n = 30 \)?</li>
    <li>What is the largest value of \( n \) that could reasonably be solved in:
      <ul>
        <li>1 second?</li>
        <li>1 hour?</li>
        <li>1 day?</li>
        <li>1 year?</li>
      </ul>
    </li>
    <li>What does this tell you about the feasibility of brute-force approaches for large input sizes?</li>
  </ul>
</li>

    <li>
      <strong>Compare Variants:</strong> Compare the bitmask-based algorithm to a recursive inclusion–exclusion version. What are the tradeoffs in clarity, performance, and memory usage?
	  What other ideas can you come up with to enumerate all of the subsets?
    </li>
  </ol>
</section>

<section id="problems">
  <h2>Homework Problems</h2>
  <ol>
    <li>
      <strong>Empirical Runtime Study:</strong> Implement the bitmask-based subset sum algorithm and measure how long it takes to run for increasing values of \( n \). Try inputs from \( n = 3 \) up to the largest size that completes in under 2 hours on your computer. Plot your results on a graph and describe the growth rate.
    </li>
    <li>
      <strong>Count Matches:</strong> Modify your implementation so that it counts how many subsets match the target sum, instead of printing them. Test it on several small inputs and compare your counts with expectations.
    </li>
    <li>
      <strong>Subset Product:</strong> Adapt the subset sum algorithm to decide whether any subset multiplies to a target product \( T \). Handle edge cases like 0 and 1 carefully. Test with small sets and analyze any difficulties.
    </li>
    <li>
      <strong>Fixed-Size Subsets:</strong> Modify the bitmask algorithm to only consider subsets of size exactly \( k \). Use this to determine whether any \( k \)-element subset sums to a given target. Try different values of \( k \). Give the computational complexity of your algorithm.
    </li>
    <li>
      <strong>Subset of Size 3:</strong> Write a brute-force algorithm to find whether any 3-element subset sums to the target value. How is this simpler than the general case? Give the computational complexity of your algorithm.
    </li>
    <li>
      <strong>Weight-Constrained Subsets:</strong> Suppose each item has a weight and a value. Given a weight limit \( W \), check whether any subset has total weight at most \( W \) and value at least \( V \). Use a brute-force approach. Give the computational complexity of your algorithm.
    </li>
    <li>
      <strong>Max Solvable Input Size:</strong> Assume your algorithm runs in \( 5n \cdot 2^n \) steps and your machine processes 100 million steps/second. Estimate the largest value of \( n \) solvable in 1 second, 1 hour, and 1 day. Show your work.
    </li>
	<li>
  <strong>Subset Closest to Target:</strong> Write an exhaustive search algorithm to find the subset of a given set whose sum is closest to, but does not exceed, a target value \( T \). If multiple subsets tie, return any one. Explain how your approach is similar to the subset sum algorithm. Give the computational complexity of your algorithm.
</li>
<li>
  <strong>Subsets with Bounded Range:</strong> Design an exhaustive search algorithm that finds <em>all non-empty subsets</em> of a given set \( S \) whose range (maximum minus minimum value) is less than or equal to a given threshold \( d \). For each valid subset, print the elements and their range. Give the computational complexity of your algorithm.
</li>
  </ol>
</section>


</body>
</html>
