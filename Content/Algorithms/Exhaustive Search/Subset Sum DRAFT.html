<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Subset Sum (Exhaustive Search)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
</head>
<body>
  <h1>Subset Sum (Exhaustive Search)</h1>

  <section id="problem-solved">
    <h2>Problem Solved</h2>
    <p>
      Here we will describe the exhaustive search algorithm to solve the 
      <a class="problem" href="?path=Problems%2FOther%2FSubset%20Sum">Subset Sum</a>
      problem.
    </p>
  </section>

  <section id="design">
    <h2>Design and Strategy</h2>
    <p>
      The exhaustive search strategy for Subset Sum is to <strong>generate all possible subsets</strong> of the input set and check each subset's sum. Since each element can either be <em>included</em> or <em>excluded</em>, there are \(2^n\) possible subsets for \(n\) elements.
    </p>
    <p>
      One convenient implementation is via recursion (the <em>inclusion--exclusion</em> approach). At each step, we choose whether to include the next element in our subset or not, forming a binary recursion tree of depth \(n\).
    </p>
    <p>Here is the pseudocode outline:</p>
    <ol class="spaced">
      <li><strong>Base Case:</strong> If the remaining target \(T = 0\), return <code>true</code>. If no elements remain and \(T \neq 0\), return <code>false</code>.</li>
      <li><strong>Recursive Case:</strong> Otherwise, let \(x\) be the next element:
        <ul>
          <li><strong>Include \(x\):</strong> Recurse on the rest with target \(T - x\).</li>
          <li><strong>Exclude \(x\):</strong> Recurse on the rest with the same target \(T\).</li>
        </ul>
      </li>
      <li><strong>Result:</strong> Return <code>true</code> if either recursive call returns <code>true</code>; otherwise <code>false</code>.</li>
    </ol>
  </section>

  <section id="demo">
    <div class="embeddedDemoContainer">
      <iframe class="embeddedDemo"
              src="/Algorithms/Content/Demos/Exhaustive%20Search/Subset%20Sum%20Demo.html"
              allow="fullscreen"
              name="Subset_Sum_demo">
      </iframe>
    </div>
  </section>

  <section id="code">
    <h2>Implementation in Java, C++, Python</h2>
    <p>These implementations use a recursive exhaustive search to decide if any subset sums to the target.</p>
    <div class="tab-group">
      <div class="tabs" role="tablist">
        <button id="tab-java" class="tablink active" data-lang="java" role="tab" aria-controls="java" aria-selected="true">Java</button>
        <button id="tab-cpp" class="tablink" data-lang="cpp" role="tab" aria-controls="cpp" aria-selected="false">C++</button>
        <button id="tab-python" class="tablink" data-lang="python" role="tab" aria-controls="python" aria-selected="false">Python</button>
      </div>
      <div id="java" class="code-container active" role="tabpanel" aria-labelledby="tab-java">
        <pre><code class="language-java">boolean subsetSum(int[] S, int n, int T) {
    if (T == 0) return true;
    if (n == 0) return false;
    return subsetSum(S, n - 1, T) || subsetSum(S, n - 1, T - S[n - 1]);
}</code></pre>
      </div>
      <div id="cpp" class="code-container" role="tabpanel" aria-labelledby="tab-cpp">
        <pre><code class="language-cpp">bool subsetSum(int S[], int n, int T) {
    if (T == 0) return true;
    if (n == 0) return false;
    return subsetSum(S, n - 1, T) || subsetSum(S, n - 1, T - S[n - 1]);
}</code></pre>
      </div>
      <div id="python" class="code-container" role="tabpanel" aria-labelledby="tab-python">
        <pre><code class="language-python">def subset_sum(S, n, T):
    if T == 0:
        return True
    if n == 0:
        return False
    return subset_sum(S, n - 1, T) or subset_sum(S, n - 1, T - S[n - 1])</code></pre>
      </div>
    </div>
  </section>

  <section id="analysis">
    <h2>Time/Space Analysis</h2>
    <p><strong>Time Complexity:</strong> There are \(2^n\) subsets of an \(n\)-element set. Each recursive step does constant work beyond the two recursive calls, so the total time is \(O(2^n)\).</p>
    <p><strong>Space Complexity:</strong> The recursion stack can grow to depth \(n\), so the extra space is \(O(n)\).</p>
    <h2>Variations/Improvements</h2>
    <ul>
      <li><strong>Dynamic Programming:</strong> A pseudo-polynomial DP solution runs in \(O(n \times T)\) time when the target \(T\) is not too large.</li>
      <li><strong>Meet-in-the-Middle:</strong> Split the set into two halves, enumerate sums of each, and match to the target in \(O(2^{n/2})\) time.</li>
      <li><strong>Backtracking and Pruning:</strong> Skip branches when the partial sum exceeds the target or cannot possibly reach it.</li>
      <li><strong>Special Cases:</strong> Subset Sum is a special case of 0/1 Knapsack and Partition; knapsack techniques apply.</li>
    </ul>
  </section>

  <section id="links">
    <h2>Links to Resources</h2>
    <ul class="resource-list">
      <li><a href="https://en.wikipedia.org/wiki/Subset_sum_problem" target="_blank">Subset Sum Problem – Wikipedia</a></li>
      <li><a href="https://www.geeksforgeeks.org/subset-sum-problem-dp-25/" target="_blank">Subset Sum Problem – GeeksforGeeks</a></li>
      <li><a href="https://www.finalround.ai/lessons/subset-sum" target="_blank">Subset Sum Tutorial – FinalRound AI</a></li>
    </ul>
  </section>

  <section id="reading-questions">
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li>How many subsets does a set of size \(n\) have?</li>
      <li>What are the two recursive calls made in the brute-force algorithm?</li>
      <li>Why must we consider all subsets in the worst case?</li>
      <li>How does the base case <code>T == 0</code> help solve the problem?</li>
      <li>What is the time complexity of the brute-force approach?</li>
    </ol>
    <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
    <div id="answers" class="answer" hidden>
      <ol>
        <li><strong>Answer:</strong> There are \(2^n\) subsets of an \(n\)-element set.</li>
        <li><strong>Answer:</strong> One call includes the current element (subtracting its value from \(T\)), and the other excludes it.</li>
        <li><strong>Answer:</strong> Because any subset might sum to the target, so all must be checked.</li>
        <li><strong>Answer:</strong> It detects when a valid subset has been found and stops further search along that branch.</li>
        <li><strong>Answer:</strong> \(O(2^n)\) time.</li>
      </ol>
    </div>
  </section>

  <section id="activities">
    <h2>In-Class Activities</h2>
    <ol>
      <li>Trace the algorithm on the input set \{1, 3, 4, 7\} with target 8.</li>
      <li>Explain what happens when all elements are larger than the target.</li>
      <li>Use the demo to find multiple solutions for \{2, 5, 8, 11\} and target 16.</li>
      <li>Design a brute-force algorithm to check if any subset has product exactly 24.</li>
      <li>Propose how to count how many subsets match the target instead of just checking existence.</li>
      <li>Modify the approach to only consider subsets of size 3.</li>
      <li>Brainstorm why this approach fails when \(n\) is large (e.g., \(n > 30\)).</li>
    </ol>
  </section>

  <section id="problems">
    <h2>Homework Problems</h2>
    <ol>
      <li><strong>All Subsets:</strong> Write a program that prints all subsets that sum to the target value.</li>
      <li><strong>Subset Product:</strong> Decide if any subset of the input has product equal to a given target.</li>
      <li><strong>Count Solutions:</strong> Modify the recursive algorithm to return the number of subsets that match the target.</li>
      <li><strong>Permutation Sum:</strong> Design an exhaustive search to find if any permutation of the numbers adds to the target (order matters).</li>
      <li><strong>k-Subset Sum:</strong> Modify the algorithm to only consider subsets of size exactly \(k\).</li>
      <li><strong>3-Element Target:</strong> Determine if any 3-element subset adds to a specified target.</li>
      <li><strong>Subset Difference:</strong> Find a subset whose elements’ absolute differences sum to the target value.</li>
      <li><strong>Weight Limit:</strong> Given item weights and a weight limit, check if any subset stays under the limit and meets a second goal.</li>
    </ol>
  </section>

</body>
</html>
