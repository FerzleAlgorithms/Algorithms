<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>QuickHull</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
</head>

<body>
  <h1>QuickHull</h1>

  <section id="problem-solved" section-title="Problem Solved">
    <h2>Problem Solved</h2>
    <p>
      QuickHull is a divide-and-conquer algorithm that solves the
      <a class="problem" href="?path=Problems%2FGeometry%2FConvex%20Hull">Convex Hull</a>
      problem.
    </p>
  </section>


  <section id="design" section-title="Design and Strategy">
    <h2>Design and Strategy</h2>

    <p>
      QuickHull is a divide-and-conquer algorithm for computing the convex hull of a set of points in the plane.
      Its overall strategy resembles <strong>Quicksort</strong>: just as Quicksort chooses a pivot and recursively
      processes subarrays, QuickHull picks extreme points to split the problem and recursively finds hull segments.
    </p>

    <p>
      The intuition is that the convex hull is like a "rubber band" stretched around the outside points.
      QuickHull repeatedly identifies the outermost points that must belong to the hull, then
      divides the remaining problem into smaller subproblems defined by lines and half-planes.
    </p>
    <p>Before we get into the description of the algorithm, we first need to understand what it means
      for a point to be the left (or right) of a line segment. Imagine you are walking from point
      \(A\) to point \(B\). If you have to turn your head to the right to see point \(C\), then \(C\) is to
      the right of the line \(AB\). Likewise, if you have to turn your head to the left to see point \(C\),
      then \(C\) is to the left of the line \(AB\).
      Notice that the order of the points \(A\) and \(B\) matters here! For instance,
      if \(C\) is to the right of \(AB\), then it is to the left of \(BA\).
    </p>

    <section id="outline" section-title="Outline">
      <h3>Outline</h3>
      <p>Here is a step-by-step outline of QuickHull:</p>
      <ol>
        <li><strong>Find the extreme endpoints:</strong>
          Identify the leftmost and rightmost points in the set, call them \(A\) and \(B\).
          These two points are guaranteed hull points.</li>
        <li><strong>Partition into two halves:</strong>
          Consider the directed segments \(AB\) and \(BA\).
          <ul>
            <li>Points to the left of \(AB\) form the candidate set for the <em>upper hull</em>.</li>
            <li>Points to the left of \(BA\) form the candidate set for the <em>lower hull</em>.</li>
            <li>Points on the segment \(AB\) can be ignored.</li>
          </ul>
        </li>
        <li><strong>Recursive hull building:</strong>
          For each of these two halves (upper and lower), run the following recursive procedure on segment \(XY\) with a
          set of points \(S\) to its left:
          <ol type="a">
            <li><em>Base case:</em> If \(S\) is empty, then segment \(XY\) is part of the convex hull.</li>
            <li>Otherwise, find the point \(P \in S\) that is farthest from line \(XY\).</li>
            <li>Add \(P\) to the hull, splitting \(XY\) into two edges \(XP\) and \(PY\).</li>
            <li>Form two new subsets:
              <ul>
                <li>Points of \(S\) lying to the left of line \(XP\).</li>
                <li>Points of \(S\) lying to the left of line \(PY\).</li>
              </ul>
            </li>
            <li>Recurse on \((X,P)\) with the first subset, and on \((P,Y)\) with the second subset.</li>
          </ol>
        </li>
        <li><strong>Combine results:</strong>
          First run the recursive procedure on \(AB\) with the upper set.
          Then run it again on \(BA\) with the lower set.
          The union of all segments returned from these two independent recursive calls forms the complete convex hull.
        </li>
      </ol>
    </section>
    <section id="minidemo" section-title="Mini Demo">
      <h3>Mini Demo</h3>
      <p>Here is a simple demo of the algorithm in action on a small data set.
        You will see a more detailed version if you keep reading.</p>
      <div class="embeddedDemoContainer">
        <iframe class="embeddedDemo" src="/Algorithms/Content/Demos/Divide-and-Conquer/QuickHull Mini.html"
          allow="fullscreen" name="CONVEX_HULL-demo-mini">
        </iframe>
      </div>
    </section>

    <section id="pseudo1" section-title="Basic Pseudocode">
      <h3>Basic Pseudocode</h3>
      <p>Here is basic pseudocode for QuickHull. In this pseudocode, we return the convex hull
        as a collection of edges. Later when we get to the implementations, they will return the
        convex hull as a list of points instead. We do this to demonstrate that there is often
        more than one way to represent solutions to problems.
      </p>

      <pre><code class="language-cpp">QUICKHULL(points S) {
    if (S.size() &le; 1) 
        return S;
    A = leftmost point in S
    B = rightmost point in S
    U = points in S to the left of AB  // above the line AB 
    L = points in S to the right of AB // below the line AB
    H = []  // hull edges or vertices
    BUILDHULL(A, B, U, H)  // upper hull (left of AB)
    BUILDHULL(B, A, L, H)  // lower hull (right of AB)
    return H
}

BUILDHULL(X, Y, S, H) {
    if (S is empty) {
        add edge (X,Y) to H
        return
    }
    P = point in S farthest from XY
    S1 = points in S to the left of XP
    S2 = points in S to the left of PY 
    BUILDHULL(X, P, S1, H)
    BUILDHULL(P, Y, S2, H)
}
</code></pre>
      <p>We have still left out details from this pseudocode. For instance, how do we determine if a point is
        to the left or right of a line? How do we determine how far a point is from a line?
        We will tackle those details next.
      </p>
    </section>

    <section id="primitives" section-title="Geometric Primitives">
      <h3>Geometric Primitives</h3>
      <p>Consider three points \(A=(x_A,y_A)\), \(B=(x_B,y_B)\), and \(C=(x_C,y_C)\).</p>

      <p><strong>Cross product of three points:</strong> We define
        \[
        \operatorname{cross}(A,B,C)
        = (x_B-x_A)(y_C-y_A) - (y_B-y_A)(x_C-x_A).
        \]
        This is the 2D "signed area": it equals twice the signed area of triangle \(ABC\).
        It is also proportional to the perpendicular distance of \(C\) from line \(AB\).
        Thus, if \(|\operatorname{cross}(A,B,C)| &lt; |\operatorname{cross}(A,B,D)|\),
        then point \(C\) is closer to the line \(AB\) than point \(D\).

      <p><strong>Side test (left/right/collinear):</strong>
        Using \(\operatorname{cross}(A,B,C)\) we can determine which side of line \(AB\) point \(C\) lies on:
      <ul>
        <li>If \(\operatorname{cross}(A,B,C) &gt; 0\), then \(C\) is to the <em>left</em> of directed line \(AB\).</li>
        <li>If \(\operatorname{cross}(A,B,C) &lt; 0\), then \(C\) is to the <em>right</em> of directed line \(AB\).</li>
        <li>If \(\operatorname{cross}(A,B,C) = 0\), then \(C\) lies <em>on</em> line \(AB\); the three points are
          collinear.</li>
      </ul>
      This "side test" is the basic orientation check used throughout QuickHull to decide which subset of points
      belongs to a given recursive call.</p>
    </section>



    <section id="pseudo2" section-title="Detailed Pseudocode">
      <h3>Detailed Pseudocode</h3>
      <p>
        Before diving in, a few notes about the syntax:
      </p>
      <ul class="spaced">
        <li><code>S</code> is treated like an array (or list). Writing <code>S[i]</code> means the <em>i</em>-th point
          in the set.</li>
        <li>Each point <code>p</code> has two coordinates, which we access with <code>p.x</code> and <code>p.y</code>.
        </li>
        <li><code>S.size()</code> gives the number of points in the set, <code>S.isEmpty()</code> tests if it has no
          points,
          and <code>S.add(p)</code> appends a point.</li>
      </ul>
      <p>
        With that in mind, here is the full pseudocode for QuickHull:
      </p>
      <pre><code class="language-cpp">QUICKHULL(points S) {
    if (S.size() &lt;= 1) { // Handle tiny cases
        return S;
    }

    // 1) Find extreme endpoints A (leftmost) and B (rightmost)
    A = S[0];
    B = S[0];
    for (i = 1; i &lt; S.size(); i++) {
        p = S[i];
        if (p.x &lt; A.x || (p.x == A.x && p.y &lt; A.y)) { A = p; }
        if (p.x &gt; B.x || (p.x == B.x && p.y &gt; B.y)) { B = p; }
    }

    // 2) Split once into upper and lower candidate sets
    S_upper = [];
    S_lower = [];
    
    for (i = 0; i &lt; S.size(); i++) {
        p=S[i];
        if (p == A || p == B) { continue; }
        s = side(A, B, p);   // +1 left of AB, -1 right of AB, 0 collinear
        if (s == +1) {
            S_upper.add(p);
        } else if (s == -1) {
            S_lower.add(p);
        }
        // collinear points can be ignored or handled separately
    }

    H = [];  // list of edges (or vertices)

    // 3) Two outer recursive builds
    BUILDHULL(A, B, S_upper, H);  // constructs the upper hull (left of AB)
    BUILDHULL(B, A, S_lower, H);  // constructs the lower hull (left of BA)

    return H;
}

BUILDHULL(X, Y, S_side, H) {
    // Base case: if no point lies to the left of XY, XY is on the hull
    if (S_side.isEmpty()) {
        H.add(edge(X, Y));
        return;
    }

    // 1) Find farthest point P from line XY by maximizing |cross(X,Y,p)|
    P = S_side[0];
    bestVal = abs(cross(X, Y, P));
    for (i = 1; i &lt; S_side.size(); i++) {
        val = abs(cross(X, Y, S_side[i]));
        if (val &gt; bestVal) {
            bestVal = val;
            P = S_side[i];
        }
    }

    // 2) Partition into two new "left-of" subsets relative to XP and PY
    S1 = [];
    S2 = [];
    for (i = 0; i &lt; S_side.size(); i++) {
        q = S_side[i];
        if (q == P) { continue; }
        if (side(X, P, q) == +1) {
            S1.add(q);
        } else if (side(P, Y, q) == +1) {
            S2.add(q);
        }
        // points not left of either are inside/collinear and discarded
    }

    // 3) Recurse on the two subproblems
    BUILDHULL(X, P, S1, H);
    BUILDHULL(P, Y, S2, H);
}


cross(A, B, C) {
    return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
}

side(A, B, C) {
    v = cross(A, B, C);
    if (v &gt; 0) {
        return +1;   // left of AB
    } else if (v &lt; 0) {
        return -1;   // right of AB
    } else {
        return 0;    // collinear
    }
}</code></pre>
    </section>
  </section>

  <section id="demo" section-title="Interactive Demo">
    <div class="embeddedDemoContainer">
      <iframe class="embeddedDemo" src="/Algorithms/Content/Demos/Divide-and-Conquer/QuickHull.html" allow="fullscreen"
        name="CONVEX_HULL-demo">
      </iframe>
    </div>
  </section>

  <section id="code" section-title="Implementation in Java, C++, Python">
    <h2>Implementation in Java, C++, Python</h2>
    <p>
      Each implementation below produces the convex hull as a sequence of points.
      The details of what exactly is returned are slightly different in each language:
    </p>
    <ul>
      <li><strong>Java:</strong> Returns a <code>List&lt;Point&gt;</code> containing the hull vertices in order,
        tracing first along the upper hull from the leftmost to the rightmost point,
        then along the lower hull back to the leftmost point.</li>
      <li><strong>C++:</strong> Returns a <code>std::vector&lt;Point&gt;</code> with the same ordering:
        upper chain \(A \rightarrow B\) followed by lower chain \(B \rightarrow A\).</li>
      <li><strong>Python:</strong> Returns a <code>list</code> of <code>Point</code> objects in that same order
        (upper then lower), suitable for printing or plotting directly.</li>
    </ul>
    <p>
      In all cases, the hull is returned as an <em>open cycle</em> of vertices: the final point does not
      repeat the starting point. If a closed polygon is needed, simply add the first vertex again at the end.
    </p>

    <div class="tab-group">
      <div class="tabs" role="tablist">
        <button id="tab-java" class="tablink active" data-lang="java" role="tab" aria-controls="java"
          aria-selected="true">Java</button>
        <button id="tab-cpp" class="tablink" data-lang="cpp" role="tab" aria-controls="cpp"
          aria-selected="false">C++</button>
        <button id="tab-python" class="tablink" data-lang="python" role="tab" aria-controls="python"
          aria-selected="false">Python</button>
      </div>
      <div id="java" class="code-container active" role="tabpanel" aria-labelledby="tab-java">
        <pre><code class="language-java">import java.util.*;

class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}

public class ConvexHullQuickHull {
    private static long cross(Point O, Point A, Point B) {
        return (long)(A.x - O.x) * (B.y - O.y) - (long)(A.y - O.y) * (B.x - O.x);
    }

    // Absolute twice-area of triangle OAB (no sqrt); proportional to distance to line OA
    private static long triArea2(Point O, Point A, Point B) {
        return Math.abs(cross(O, A, B));
    }

    public static List&lt;Point&gt; convexHull(Point[] pts) {
        if (pts.length &lt;= 1) return Arrays.asList(pts);
        Arrays.sort(pts, (a, b) -&gt; a.x != b.x ? Integer.compare(a.x, b.x) : Integer.compare(a.y, b.y));
        Point A = pts[0], B = pts[pts.length - 1];
        List&lt;Point&gt; upper = new ArrayList&lt;&gt;();
        List&lt;Point&gt; lower = new ArrayList&lt;&gt;();
        for (Point p : pts) {
            long c1 = cross(A, B, p);
            if (c1 &gt; 0) upper.add(p);
            else if (c1 &lt; 0) lower.add(p);
        }
        List&lt;Point&gt; hull = new ArrayList&lt;&gt;();
        buildHull(A, B, upper, hull); // builds A..B along upper
        buildHull(B, A, lower, hull); // builds B..A along lower
        return hull;
    }

    private static void buildHull(Point A, Point B, List&lt;Point&gt; S, List&lt;Point&gt; out) {
        if (S.isEmpty()) { out.add(A); return; }
        Point far = null; long best = -1;
        for (Point p : S) {
            long a2 = triArea2(A, B, p);
            if (a2 &gt; best) { best = a2; far = p; }
        }
        List&lt;Point&gt; S1 = new ArrayList&lt;&gt;();
        List&lt;Point&gt; S2 = new ArrayList&lt;&gt;();
        for (Point p : S) {
            if (cross(A, far, p) &gt; 0) S1.add(p);
            else if (cross(far, B, p) &gt; 0) S2.add(p);
        }
        buildHull(A, far, S1, out);
        buildHull(far, B, S2, out);
    }
}</code></pre>
      </div>
      <div id="cpp" class="code-container" role="tabpanel" aria-labelledby="tab-cpp">
        <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct Point { long long x, y; };

static long long cross(const Point& O, const Point& A, const Point& B) {
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
}

static long long triArea2(const Point& O, const Point& A, const Point& B) {
    long long v = cross(O, A, B);
    return v &gt;= 0 ? v : -v;
}

static void buildHull(const Point& A, const Point& B,
                          const std::vector&lt;Point&gt;& S,
                          std::vector&lt;Point&gt;& out) {
    if (S.empty()) { out.push_back(A); return; }
    // farthest by area (no sqrt)
    const Point* far = nullptr; long long best = -1;
    for (const auto& p : S) {
        long long a2 = triArea2(A, B, p);
        if (a2 &gt; best) { best = a2; far = &p; }
    }
    std::vector&lt;Point&gt; S1, S2;
    for (const auto& p : S) {
        if (cross(A, *far, p) &gt; 0) S1.push_back(p);
        else if (cross(*far, B, p) &gt; 0) S2.push_back(p);
    }
    buildHull(A, *far, S1, out);
    buildHull(*far, B, S2, out);
}

std::vector&lt;Point&gt; convexHullQuickHull(std::vector&lt;Point&gt; pts) {
    if (pts.size() &lt;= 1) return pts;
    std::sort(pts.begin(), pts.end(), [](const Point& a, const Point& b){
        return a.x &lt; b.x || (a.x == b.x && a.y &lt; b.y);
    });
    Point A = pts.front(), B = pts.back();
    std::vector&lt;Point&gt; upper, lower;
    for (const auto& p : pts) {
        long long c = cross(A, B, p);
        if (c &gt; 0) upper.push_back(p);
        else if (c &lt; 0) lower.push_back(p);
    }
    std::vector&lt;Point&gt; hull; hull.reserve(pts.size());
    buildHull(A, B, upper, hull);
    buildHull(B, A, lower, hull);
    return hull;
}</code></pre>
      </div>
      <div id="python" class="code-container" role="tabpanel" aria-labelledby="tab-python">
        <pre><code class="language-python">from typing import List, Tuple

class Point:
    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y
    def __repr__(self):
        return f"Point({self.x},{self.y})"

def cross(o: Point, a: Point, b: Point) -> int:
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)

def tri_area2(o: Point, a: Point, b: Point) -> int:
    return abs(cross(o, a, b))

def quickhull(points: List[Point]) -> List[Point]:
    if len(points) <= 1:
        return points[:]
    pts = sorted(points, key=lambda p: (p.x, p.y))
    A, B = pts[0], pts[-1]
    upper = [p for p in pts if cross(A, B, p) > 0]
    lower = [p for p in pts if cross(B, A, p) > 0]
    hull: List[Point] = []
    _build_hull(A, B, upper, hull)
    _build_hull(B, A, lower, hull)
    return hull

def _build_hull(A: Point, B: Point, S: List[Point], out: List[Point]) -> None:
    if not S:
        out.append(A)
        return
    far = max(S, key=lambda p: tri_area2(A, B, p))
    S1 = [p for p in S if cross(A, far, p) > 0]
    S2 = [p for p in S if cross(far, B, p) > 0]
    _build_hull(A, far, S1, out)
    _build_hull(far, B, S2, out)

if __name__ == "__main__":
    pts = [Point(0,3), Point(1,1), Point(2,2), Point(4,4),
           Point(0,0), Point(1,2), Point(3,1), Point(3,3)]
    h = quickhull(pts)
    print("Convex Hull:", h)</code></pre>
      </div>
    </div>
    <p>
      A few subtle implementation details are worth noting:
    </p>
    <ul>
      <li><strong>Collinear points:</strong> The code above ignores points that lie exactly on the line through the
        current edge.
        Handling collinear cases (whether to include all such points or only the extremes) is often left as an extension
        or homework exercise.</li>
      <li><strong>All-collinear sets:</strong> If all input points happen to be collinear, QuickHull as written will
        return only the two extreme endpoints.
        A more complete version might return the entire line segment or all boundary points.</li>
      <li><strong>Duplicates:</strong> If duplicate points are included in the input, they may appear in the hull.
        In practice, inputs are usually preprocessed to remove duplicates.</li>
      <li><strong>Numeric safety:</strong> The C++ and Java versions use 64-bit integer arithmetic in the cross product
        to avoid overflow for typical coordinate ranges.
        For very large coordinates or floating-point inputs, additional care may be needed.</li>
      <li><strong>Output order:</strong> The hull vertices are produced in sequence along the upper chain from leftmost
        to rightmost, then back along the lower chain to the leftmost.
        The starting point is not repeated at the end, so if a closed cycle is needed, append the first vertex again.
      </li>
    </ul>

  </section>

  <section id="analysis" section-title="Time/Space Analysis">
    <h2>Time/Space Analysis</h2>

    <p><strong>Time Complexity:</strong></p>
    <p>There are three main parts of QuickHull:
    <ul>
      <li>Sorting the list of \(n\) points in \(O(n\log n)\) time.</li>
      <li>Partitioning the points into the upper and lower parts in \(O(n)\) time.</li>
      <li>Making two calls to <code>buildHull</code>, the time of which can vary.</li>
    </ul>
    </p>
    <p>Analyzing <code>buildHull</code> takes a bit more effort.
      Let \(T(n)\) be the time it takes to call <code>buildHull</code> on a list of size \(n\).
      Each call:
    </p>
    <ul>
      <li>Scans the current subset to find the farthest point from the current line in \(O(n)\) time.</li>
      <li>Partitions the subset into two new subsets, putting
        \(k\geq 0\) points in one set, ignoring \(a\geq 1\) points that are in the interior
        (\(a\geq 1\) since at least the farthest point \(P\) is removed),
        and putting the remaining \(n-k-a\) points in the second set.
        This also takes \(O(n)\) time.
      </li>
      <li>Recurses on those two subsets.
    </ul>
    Thus, \(T(n)=T(k)+T(n-k-a)+O(n)\), and the overall complexity of QuickHull is \(O(n\log n + T(n))\).
    What \(T(n)\) solves to depends heavily on the input.
    <ul>
      <li><em>Best case:</em> If the farthest point tends to split each set roughly in half,
        then each call does two subcalls of size about \(n/2\), leading to
        \(T(n) = 2T(n/2) + O(n) = O(n \log n)\)
        (the same as Mergesort or Quicksort in the best case), leading
        to an overall complexity of \(O(n\log n+n\log n)=O(n\log n)\).</li>
      <li><em>Worst case:</em> If many or all of the points lie on the convex hull
        (e.g., points evenly spaced on a circle), then every recursive split leaves almost all points
        for the next level. The recurrence is closer to
        \(T(n) = T(n-1) + O(n)=O(n^2)\), analogous to Quicksort's worst case.
        Then the total complexity is \(O(n\log n + n^2)=O(n^2)\).</li>
      <li><em>Average case:</em> For random or "typical" data, many points fall in the interior and are
        discarded quickly, so the value of \(a\) is often large. At each level of recursion,
        only the boundary points tend to survive into deeper subcalls. This makes the effective recurrence
        much closer to the balanced case than the skewed case, and the expected work is about \(O(n \log n)\).
        In practice, QuickHull is often quite
        fast because interior points vanish early and never appear in deeper recursive calls.</li>
    </ul>

    <p><strong>Space Complexity:</strong></p>
    <ul>
      <li>Storing the input and the resulting hull requires \(O(n)\).</li>
      <li>Each recursive call builds temporary subsets, but across the recursion tree the total number of point copies
        is proportional to \(n\) at each level. Recursion depth is \(O(\log n)\) on average, but can reach \(O(n)\) in
        the worst case, leading to a deep stack.</li>
      <li>Overall, the additional space usage is \(O(n)\).</li>
    </ul>
  </section>

  <section id="variations" section-title="Variations/Improvements">
    <h2>Variations/Improvements</h2>

    <h3>Policy Choices (correctness & output)</h3>
    <ul>
      <li><strong>Collinear handling:</strong> Decide whether to keep only extreme endpoints on each edge or include all
        boundary collinear points.
        For "minimal hull," discard collinear interior points (keep farthest only); for "full boundary," keep all with
        <code>cross == 0</code>. Be consistent across both halves.
      </li>
      <li><strong>Tie-breaking (determinism):</strong> When multiple points are equally far (same <code>|cross|</code>),
        break ties by distance to <code>X</code> or <code>Y</code>, then by <code>(x,y)</code>. Deterministic ties make
        grading and testing saner.</li>
      <li><strong>Return format:</strong> Return vertices (open cycle) or edges. If returning vertices, emit
        <code>A..B</code> from the upper call and <code>B..A</code> from the lower without duplicating endpoints; close
        the cycle in drawing code if needed.
      </li>
    </ul>

    <h3>Robustness (numeric & degeneracy)</h3>
    <ul>
      <li><strong>Numeric tolerance:</strong> With floating point, replace <code>|cross|=0</code> with
        <code>|cross| ≤ ε</code> to determine
        if points are collinear; choose \(\epsilon\) relative to coordinate scale (e.g., \(\epsilon = 1^{-9} *
        \max(|x|,|y|)\).
      </li>
      <li><strong>Wide integers:</strong> For integer inputs, compute <code>cross</code> in 64-bit (or wider) to avoid
        overflow;
        in Java use <code>long</code>, in C++ use <code>long long</code> or <code>__int128</code> if needed.</li>
      <li><strong>All-collinear guard:</strong> Detect if all points are collinear and return the two extremes (or the
        entire segment) per your policy. This prevents deep, pointless recursion.</li>
    </ul>

    <h3>Performance Tweaks (asymptotics unchanged, constants better)</h3>
    <ul>
      <li><strong>Akl-Toussaint heuristic (pre-prune):</strong> First find extreme points in 4-8 directions (min/max x,
        y, and optionally diagonals) to form a small convex polygon; discard points strictly inside. This often shrinks
        input dramatically before QuickHull.</li>
      <li><strong>Reuse buffers:</strong> Avoid allocating new lists at every recursion. Partition by writing indices
        into two preallocated scratch arrays (or reuse vectors with <code>clear()</code> + <code>reserve()</code> in
        C++).</li>
      <li><strong>Iterative stack:</strong> Replace recursion with an explicit stack to control memory and set a max
        depth; tail-recursion elimination is straightforward in this routine.</li>
      <li><strong>Early exit on tiny sets:</strong> For \(n \leq 3\) in a subcall, emit the appropriate edge(s) without
        further scans.</li>
      <li><strong>Avoid sqrt/div:</strong> When selecting the farthest point, compare <code>|cross|</code> as we are
        doing;
        don't compute true distances (as the algorithm is often presented).
        That involves an unnecessary computation of an expensive square root along with a division.</li>
    </ul>

    <h3>Parallel/Batch Variants</h3>
    <p>These variants use parallel computing termonology, so if they do not make sense to you, you can probably not
      worry about them.</p>
    <ul>
      <li><strong>Parallel farthest search:</strong> The "pick farthest from line XY" scan is embarrassingly parallel;
        reduce with a max over <code>|cross|</code>.</li>
      <li><strong>Parallel partition:</strong> Partition into "left of XP" and "left of PY" can be done with parallel
        stable partition / scatter into two buffers, then recurse (often depth-limited to avoid oversubscription).</li>
    </ul>

    <h3>Hybrids & Strategy Tweaks</h3>
    <ul>
      <li><strong>Hybrid cutoff:</strong> For small subsets (e.g., \(n &lt; 32\)), switch to a simple method (gift
        wrapping on the subset or a local scan) to reduce overhead.</li>
      <li><strong>Randomized tie-breaking / pivoting:</strong> Randomly break ties or choose among equal farthest points
        to reduce worst-case patterns on adversarial inputs (similar spirit to randomized Quicksort).</li>
      <li><strong>Initial hull seeding:</strong> Start with a quick rectangle (min/max x/y) or octagon and discard
        interior points before the main two calls-this pairs nicely with Akl-Toussaint.</li>
    </ul>

    <h3>Extensions & Post-processing</h3>
    <ul>
      <li><strong>3D QuickHull:</strong> The idea generalizes to higher dimensions (facets instead of edges);
        implementation complexity rises (conflict graphs, horizon detection).</li>
      <li><strong>Rotating calipers on the hull:</strong> Once you have the hull, compute diameter, width, minimum
        bounding rectangle, etc., in linear time on <code>h</code> (number of hull vertices).</li>
    </ul>
    <h3>Alternative Convex Hull Algorithms</h3>
    <p>These aren't tweaks to QuickHull, but full alternatives with different trade-offs:</p>
    <ul>
      <li><strong>Graham Scan</strong> Sort points by polar angle around an anchor, then scan with a stack of left
        turns.
        <ul>
          <li><em>Time:</em> \(O(n \log n)\) (sorting dominates).</li>
          <li><em>Pros:</em> Simple, deterministic \(O(n \log n)\); classical algorithm with well-studied analysis.</li>
          <li><em>Cons:</em> Requires polar-angle sort and careful tie-breaking; slightly tricky with collinear points.
          </li>
          <li><em>Use when:</em> You want a clean, predictable \(O(n \log n)\) hull with straightforward correctness
            proofs.</li>
        </ul>
      </li>

      <li><strong>Andrew's Monotone Chain</strong> Sort by \(x\), then build lower and upper hulls directly.
        <ul>
          <li><em>Time:</em> \(O(n \log n)\).</li>
          <li><em>Pros:</em> Very concise; numerically stable; easy collinear policy (include or exclude).</li>
          <li><em>Cons:</em> Still requires sorting; less "visual intuition" than Graham Scan.</li>
          <li><em>Use when:</em> You want the simplest robust \(O(n \log n)\) code (often a favorite in programming
            contests).</li>
        </ul>
      </li>

      <li><strong>Jarvis March (Gift Wrapping)</strong> Repeatedly "wrap" the hull by picking the next point with
        smallest turn.
        <ul>
          <li><em>Time:</em> \(O(nh)\), where \(h\) is hull size (worst case \(O(n^2)\)).</li>
          <li><em>Pros:</em> Output-sensitive; elegant and intuitive; finds hull directly without global sorting.</li>
          <li><em>Cons:</em> Can be very slow if many points are on the hull; angle computations can be costly.</li>
          <li><em>Use when:</em> \(h \ll n\), so the hull is tiny compared to the dataset, and you want minimal code.
          </li>
        </ul>
      </li>

      <li><strong>Chan's Algorithm</strong> Hybrid: split into groups, build sub-hulls (e.g., with Monotone Chain), then
        wrap across them.
        <ul>
          <li><em>Time:</em> \(O(n \log h)\), where \(h\) is hull size.</li>
          <li><em>Pros:</em> Near-optimal for small hulls; combines the best of Graham/Andrew and Jarvis March.</li>
          <li><em>Cons:</em> Trickier to implement; requires careful choice of group sizes and iteration strategy.</li>
          <li><em>Use when:</em> You want top performance on inputs where \(h\) is small but \(n\) is large.</li>
        </ul>
      </li>

      <li><strong>Divide-and-Conquer (Preparata-Hong "tangent merge")</strong> Build hulls on halves, then merge them
        via upper and lower tangents.
        <ul>
          <li><em>Time:</em> \(O(n \log n)\).</li>
          <li><em>Pros:</em> Guaranteed \(O(n \log n)\); elegant recursive structure; amenable to parallelism.</li>
          <li><em>Cons:</em> Tangent-finding step is subtle; more complicated to implement than QuickHull or Monotone
            Chain.</li>
          <li><em>Use when:</em> You want a theoretically solid divide-and-conquer algorithm with clean asymptotics and
            good parallel potential.</li>
        </ul>
      </li>
    </ul>

    <p><em>Rule of thumb:</em> If you want simple worst-case guarantees, Monotone Chain or Graham are best.
      If hulls are small, Jarvis March or Chan's algorithm can be faster.
      QuickHull is often very fast in practice on scattered inputs but lacks worst-case \(O(n \log n)\) guarantees.</p>
  </section>

  <section id="links" section-title="Links to Resources">
    <h2>Links to Resources</h2>
    <strong>QuickHull</strong>
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Quickhull" target="_blank">
          Wikipedia: QuickHull</a> Overview of the QuickHull algorithm, its divide-and-conquer structure, complexity,
        and higher-dimensional extensions.</li>
      <li><a href="https://ics.uci.edu/~goodrich/teach/geom/notes/QuickHull.pdf" target="_blank">Michael Goodrich:
          QuickHull Algorithms (UCI)</a> concise lecture-style PDF covering algorithm steps and analysis.</li>
      <li><a
          href="https://www.csd.uwo.ca/~cmukher/assets/documents/Talk/The_Quickhull_Algorithm_for_Higher_Dimensional_Convex_Hulls_beamer.pdf"
          target="_blank">Chirantan Mukherjee: QuickHull in Higher Dimensions</a> slides that extend the idea beyond 2D.
      </li>
      <li><a href="https://arxiv.org/abs/2409.19784" target="_blank">Goodrich & Kitagawa: Ray-shooting Quickhull
          (2024)</a> a randomized, output-sensitive variation of QuickHull with \(O(n \log h)\) expected performance.
      </li>
      <li><a href="https://arxiv.org/abs/1501.04706" target="_blank">Zhang et al.: GPU-accelerated QuickHull</a> a
        version optimized for massive data on GPUs.</li>
    </ul>
    <strong>Other Convex Hull Algorithms</strong>
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/Convex_hull_algorithms" target="_blank">
          Wikipedia: Convex Hull Algorithms</a> Survey of major convex hull algorithms and their complexities.</li>
      <li><a href="https://cp-algorithms.com/geometry/convex-hull.html" target="_blank">
          CP-Algorithms: Convex Hull</a> Implementation-focused guide with multiple algorithms and code snippets.</li>
      <li><a href="https://jeffe.cs.illinois.edu/teaching/compgeom/notes/14-convexhull.pdf" target="_blank">
          Jeff Erickson's Lecture Notes on Convex Hulls</a> A clear theoretical treatment from a leading computational
        geometry text.</li>
      <li><a href="https://www.geeksforgeeks.org/dsa/convex-hull-algorithm/" target="_blank">
          GeeksforGeeks: Convex Hull Algorithms</a> Step-by-step tutorials and example implementations (Jarvis, Graham,
        QuickHull).</li>
      <li><a href="https://en.wikipedia.org/wiki/Chan%27s_algorithm" target="_blank">
          Wikipedia: Chan's Algorithm</a> Explanation of the near-optimal output-sensitive convex hull algorithm.</li>
      <li><a href="https://en.wikipedia.org/wiki/Kirkpatrick%E2%80%93Seidel_algorithm" target="_blank">
          Wikipedia: Kirkpatrick-Seidel Algorithm</a> Divide-and-conquer "ultimate planar convex hull" with optimal
        complexity.</li>
    </ul>
  </section>

  <section id="reading-questions" section-title="Reading Comprehension Questions">
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li><strong>Orientation:</strong> How does the cross product of three points tell us whether a point lies to the
        left, right, or on a line segment?</li>
      <li><strong>Pruning:</strong> Why does QuickHull select the farthest point from the current edge, and what happens
        to the points inside the triangle it defines?</li>
      <li><strong>Recurrence:</strong> In the recurrence
        \(T(n) = T(k) + T(n-k-a) + O(n)\), what does the parameter \(a\) represent, and why does it matter for the
        algorithm’s performance?</li>
      <li><strong>Complexity:</strong> Explain why QuickHull can be \(O(n \log n)\) on average but degrade to \(O(n^2)\)
        in the worst case. Compare this to Quicksort.</li>
      <li><strong>Design detail:</strong> Why does QuickHull make two outer recursive calls (once for the upper hull and
        once for the lower hull), instead of just one?</li>
      <li><strong>Collinearity:</strong> How should QuickHull handle points that are collinear with the current edge?
        What are the trade-offs of including or excluding them?</li>
      <li><strong>Variations:</strong> QuickHull is one of several convex hull algorithms. In what scenario might you
        prefer Jarvis March or Chan’s Algorithm instead?</li>
    </ol>

    <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
    <div id="answers" class="answer" hidden>
      <ol>
        <li><strong>Answer:</strong> The cross product
          \(\operatorname{cross}(A,B,C) = (x_B-x_A)(y_C-y_A) - (y_B-y_A)(x_C-x_A)\)
          is positive if \(C\) is to the left of \(AB\), negative if to the right, and zero if collinear.</li>
        <li><strong>Answer:</strong> The farthest point defines a triangle with the edge's endpoints; all points inside
          that triangle are interior and cannot be on the hull, so they can be discarded immediately. This pruning makes
          QuickHull efficient on scattered data.</li>
        <li><strong>Answer:</strong> The parameter \(a\) is the number of interior points discarded in a recursive step.
          When \(a\) is large, many points disappear quickly and the algorithm runs close to \(O(n \log n).\) When \(a\)
          is small (e.g., all points lie on the hull), pruning is weak and the recursion can become quadratic.</li>
        <li><strong>Answer:</strong> On typical random data, points are well distributed, many get pruned (\(a\) is
          large), and the recursion is balanced, so the runtime is about \(O(n \log n)\). In adversarial cases (like all
          points on a circle), pruning is minimal and recursion depth approaches \(n\), yielding \(O(n^2)\). This
          mirrors Quicksort: fast on average, quadratic if pivots are bad.</li>
        <li><strong>Answer:</strong> Because the convex hull has two "sides," one above \(AB\) and one below, QuickHull
          explicitly builds each with its own recursive process. This is different from Quicksort, which recurses once
          per partition but naturally covers the whole set.</li>
        <li><strong>Answer:</strong> One option is to ignore collinear points and include only the extreme endpoints,
          yielding the minimal hull. Another is to include all collinear boundary points for applications that care
          about every boundary vertex. The choice affects both correctness for certain problems and output size.</li>
        <li><strong>Answer:</strong> Jarvis March (gift wrapping) is preferable when the hull size \(h\) is small
          compared to \(n\), since its runtime is \(O(nh)\). Chan's Algorithm achieves \(O(n \log h)\), so it's ideal
          when \(h \ll n\) and you want guaranteed efficiency with output sensitivity.</li>
      </ol>
    </div>
  </section>

  <section id="activities" section-title="In-Class Activities">
  <h2>In-Class Activities</h2>

  <!-- Dataset A: 9 points (for 1-3) -->
  <figure>
    <figcaption><strong>Dataset A</strong> (use for Activities 1-3)</figcaption>
    <svg width="500" height="280" viewBox="0 0 500 280" xmlns="http://www.w3.org/2000/svg" 
    style="border:1px solid #ddd;background:#fff">
      <!-- points -->
      <!-- id : (x,y) -->
      <g fill="#222" stroke="#333" stroke-width="0.5">
        <circle cx="40" cy="220" r="4"/><text x="48" y="216" font-size="12">A(40,60)</text>
        <circle cx="80" cy="100" r="4"/><text x="88" y="96" font-size="12">B(80,180)</text>
        <circle cx="140" cy="180" r="4"/><text x="148" y="176" font-size="12">C(140,100)</text>
        <circle cx="160" cy="130" r="4"/><text x="168" y="126" font-size="12">D(160,150)</text>
        <circle cx="220" cy="70" r="4"/><text x="228" y="66" font-size="12">E(220,210)</text>
        <circle cx="260" cy="210" r="4"/><text x="268" y="206" font-size="12">F(260,70)</text>
        <circle cx="300" cy="120" r="4"/><text x="308" y="116" font-size="12">G(300,160)</text>
        <circle cx="360" cy="200" r="4"/><text x="368" y="196" font-size="12">H(360,80)</text>
        <circle cx="380" cy="90" r="4"/><text x="388" y="86" font-size="12">I(380,190)</text>
      </g>
    </svg>
  </figure>

  <ol>
    <li><strong>Upper/Lower Split (Dataset A):</strong>
      Identify the extreme endpoints \(A_L\) (leftmost) and \(A_R\) (rightmost). 
      Using the cross-product side test, partition all nine points into the sets
      <em>left of \(A_LA_R\)</em> (upper) and <em>left of \(A_RA_L\)</em> (lower). 
      Write the two lists of labels in order you found them.
      <div class="hint">Hint: "left of \(AB\)" means \(\operatorname{cross}(A,B,P) &gt; 0\).</div>
    </li>

    <li><strong>Manual Farthest-Point Step (Dataset A):</strong>
      With the edge \(A_L \to A_R\) from Activity 1, compute \(|\operatorname{cross}(A_L,A_R,P)|\) 
      for each point in the <em>upper</em> set. Identify the farthest point \(P^*\).
      Draw triangle \(A_L P^* A_R\) on the figure (by hand is fine) and mark the points that can be pruned as interior.
    </li>

    <li><strong>Trace a Mini-Recursion (Dataset A):</strong>
      Using the \(P^*\) from Activity 2, form the two subproblems
      "left of \(A_LP^*\)" and "left of \(P^*A_R\)". 
      For each subproblem: list its candidate points, pick the farthest, and note any points pruned. 
      Stop when a subproblem has no candidates (base case adds the segment). 
      Record the hull edges you would add in order.
    </li>
    <li><strong>Recurrence Exploration (Dataset A):</strong>
      Using the general recurrence \(T(n) = T(k) + T(n-k-a) + O(n)\), pick the farthest point on the first step and estimate \(k\) and \(a\) from your pruning in Activity 2. 
      Sketch the first two levels of the recursion tree with your \(k\) and \(a\) values. 
      Discuss how a larger \(a\) changes the shape of the tree.
    </li>
    <li><strong>Jarvis March (Gift Wrapping) Trace (Dataset B):</strong>
      Using Dataset B, run one full iteration of Jarvis March by hand:
      <ol>
        <li>Start at the leftmost point (break ties by smaller y).</li>
        <li>At each step, pick the next vertex by choosing the point that makes the most counterclockwise turn w.r.t. the current edge.</li>
        <li>Continue until you return to the start.</li>
      </ol>
      Record the order of hull vertices. 
      <div class="hint">You can implement the "most CCW" choice with the same cross-product orientation test used in QuickHull; pick the candidate with the largest positive turn, breaking ties by farthest.</div>
      Then run QuickHull on the same dataset and compare the amount of work for each.
      <figure>
    <figcaption><strong>Dataset B</strong></figcaption>
    <svg width="450" height="280" viewBox="0 0 450 280" xmlns="http://www.w3.org/2000/svg" style="border:1px solid #ddd;background:#fff">
      <g fill="#222" stroke="#333" stroke-width="0.5">
        <!-- hull-ish outer ring -->
        <circle cx="60" cy="220" r="4"/><text x="68" y="216" font-size="12">A(60,60)</text>
        <circle cx="110" cy="60" r="4"/><text x="118" y="56" font-size="12">B(110,220)</text>
        <circle cx="330" cy="70" r="4"/><text x="338" y="66" font-size="12">C(330,210)</text>
        <circle cx="370" cy="210" r="4"/><text x="378" y="206" font-size="12">D(370,70)</text>
        <!-- interior-ish -->
        <circle cx="190" cy="140" r="4"/><text x="198" y="136" font-size="12">E(190,140)</text>
        <circle cx="240" cy="120" r="4"/><text x="248" y="116" font-size="12">F(240,160)</text>
        <circle cx="210" cy="190" r="4"/><text x="218" y="186" font-size="12">G(210,90)</text>
      </g>
    </svg>
  </figure>
    </li>

    <li><strong>Four Collinear Stress Test (Dataset C):</strong>
      Apply the provided QuickHull pseudocode (which ignores special collinearity handling) to Dataset D. 
      Trace the steps carefully: what does the algorithm return? 
      Does it add redundant edges or miss vertices? 
      Based on your findings, propose a minimal change to the pseudocode to handle this case cleanly, if necessary.
       <figure>
    <figcaption><strong>Dataset C</strong></figcaption>
    <svg width="420" height="220" viewBox="0 0 420 220" xmlns="http://www.w3.org/2000/svg" 
    style="border:1px solid #ddd;background:#fff">
      <g fill="#222" stroke="#333" stroke-width="0.5">
        <!-- four points along a slanted line y = -0.5x + 230 -->
        <circle cx="60" cy="200" r="4"/><text x="68" y="196" font-size="12">P(60,20)</text>
        <circle cx="150" cy="155" r="4"/><text x="158" y="151" font-size="12">Q(150,65)</text>
        <circle cx="240" cy="110" r="4"/><text x="248" y="106" font-size="12">R(240,110)</text>
        <circle cx="330" cy="65" r="4"/><text x="338" y="61" font-size="12">S(330,155)</text>
      </g>
    </svg>
  </figure>
    </li>
      <li><strong>Apply Orientation Test Elsewhere:</strong> Consider the problem of checking whether a polygon is
        convex. How could you adapt the same "cross product side test" used in QuickHull to solve this problem?</li>
  </ol>
</section>

<section id="problems" section-title="Homework Problems">
  <h2>Homework Problems</h2>
  <ol>
    <!-- P1 -->
    <li><strong>Trace QuickHull on Dataset D (by hand):</strong>
      Using the basic algorithm described in this chapter (ignore special handling of collinearity),
      trace QuickHull on the dataset below.
      <ul>
        <li>List the upper-hull edges added in order, then the lower-hull edges.</li>
        <li>Show the farthest-point choice at each recursive step (report the maximizing \(|\operatorname{cross}|\)).</li>
      </ul>
      <figure>
        <figcaption><em>Dataset E</em></figcaption>
        <svg width="480" height="300" viewBox="0 0 480 300" xmlns="http://www.w3.org/2000/svg" style="border:1px solid #ddd;background:#fff">
          <g fill="#222" stroke="#333" stroke-width="0.5" font-size="12">
            <circle cx="50" cy="240" r="4"/><text x="58" y="236">A(50,60)</text>
            <circle cx="90" cy="80" r="4"/><text x="98" y="76">B(90,220)</text>
            <circle cx="140" cy="200" r="4"/><text x="148" y="196">C(140,100)</text>
            <circle cx="170" cy="140" r="4"/><text x="178" y="136">D(170,160)</text>
            <circle cx="230" cy="60" r="4"/><text x="238" y="56">E(230,240)</text>
            <circle cx="260" cy="220" r="4"/><text x="268" y="216">F(260,80)</text>
            <circle cx="305" cy="130" r="4"/><text x="313" y="126">G(305,170)</text>
            <circle cx="360" cy="210" r="4"/><text x="368" y="206">H(360,90)</text>
            <circle cx="385" cy="95" r="4"/><text x="393" y="91">I(385,205)</text>
            <circle cx="210" cy="165" r="4"/><text x="218" y="161">J(210,135)</text>
          </g>
        </svg>
      </figure>
    </li>

    <!-- P2 -->
    <li><strong>Farthest-point tie-breaking:</strong>
      Construct a small set of 6-8 points (or modify Dataset E) so that, for some edge \(XY\),
      there are <em>two</em> distinct points \(P,Q\) with equal \(|\operatorname{cross}(X,Y,\cdot)|\).
      <ul>
        <li>State a deterministic tie-break rule that makes sense.</li>
        <li>Apply your rule and show how the recursion changes compared to the other tie choice.</li>
      </ul>
    </li>

    <!-- P3 -->
    <li><strong>"Many on the hull" stress case:</strong>
      Create a dataset of 16 points roughly on a circle (you can eyeball coordinates). 
      Run QuickHull conceptually and estimate:
      <ul>
        <li>How often is \(a\) (the number of points pruned at a step) close to 1?</li>
        <li>How many orientation checks do you perform overall (order-of-magnitude)?</li>
      </ul>
      Briefly argue why this tends toward \(O(n^2)\) work.
    </li>

    <li><strong>All-collinear detection (slanted line):</strong>
      Given the four collinear points below, run the provided pseudocode (which does not handle this case specially).
      <ul>
        <li>What edges or vertices does it output?</li>
        <li>Propose a single, minimal guard (pseudocode) to detect "all points collinear" and return the two extremes.</li>
      </ul>
      <figure>
        <figcaption><em>Dataset F</em></figcaption>
        <svg width="440" height="220" viewBox="0 0 440 220" xmlns="http://www.w3.org/2000/svg" style="border:1px solid #ddd;background:#fff">
          <g fill="#222" stroke="#333" stroke-width="0.5" font-size="12">
            <circle cx="70"  cy="190" r="4"/><text x="78"  y="186">P(70,30)</text>
            <circle cx="160" cy="145" r="4"/><text x="168" y="141">Q(160,75)</text>
            <circle cx="250" cy="100" r="4"/><text x="258" y="96">R(250,120)</text>
            <circle cx="340" cy="55"  r="4"/><text x="348" y="51">S(340,165)</text>
          </g>
        </svg>
      </figure>
    </li>

    <li><strong>Compare QuickHull vs. Monotone Chain on the same input:</strong>
      Implement both (or simulate carefully) on a 20-point random set you generate.
      <ul>
        <li>Report the hull vertex count \(h\).</li>
        <li>Count (or estimate) the number of orientation tests each method performs.</li>
        <li>Which was faster and why? (Consider pruning vs. guaranteed \(O(n\log n)\).)</li>
      </ul>
    </li>

    <li><strong>Jarvis March (gift wrapping) on a tiny hull:</strong>
      Using the dataset below (small hull, more interior points), run Jarvis March by hand:
      start at the leftmost point, pick the most counterclockwise next vertex each step (break ties by farthest).
      List the hull in order and compare with QuickHull's result.
      <figure>
        <figcaption><em>Dataset G (Jarvis-friendly)</em></figcaption>
        <svg width="460" height="280" viewBox="0 0 460 280" xmlns="http://www.w3.org/2000/svg" style="border:1px solid #ddd;background:#fff">
          <g fill="#222" stroke="#333" stroke-width="0.5" font-size="12">
            <!-- outer-ish -->
            <circle cx="70" cy="230" r="4"/><text x="78" y="226">A(70,50)</text>
            <circle cx="120" cy="70" r="4"/><text x="128" y="66">B(120,210)</text>
            <circle cx="330" cy="80" r="4"/><text x="338" y="76">C(330,200)</text>
            <circle cx="380" cy="220" r="4"/><text x="388" y="216">D(380,60)</text>
            <!-- interior -->
            <circle cx="190" cy="150" r="4"/><text x="198" y="146">E(190,130)</text>
            <circle cx="240" cy="130" r="4"/><text x="248" y="126">F(240,150)</text>
            <circle cx="210" cy="200" r="4"/><text x="218" y="196">G(210,80)</text>
            <circle cx="310" cy="160" r="4"/><text x="318" y="156">H(310,120)</text>
          </g>
        </svg>
      </figure>
    </li>

    <li><strong>Output format sanity check:</strong>
      Modify the provided QuickHull implementation to return a <em>closed</em> vertex cycle (repeat the first vertex at the end).
      Show the output on any one of Datasets E-H and verify that drawing straight segments in order yields a closed polygon without crossing.
    </li>

    <li><strong>Pre-pruning with Akl-Toussaint (experiment):</strong>
      Implement the Akl-Toussaint heuristic: find the 4 (or 8) extreme points (min/max \(x\), \(y\), and optionally diagonals),
      form that convex polygon, and discard points strictly inside it before running QuickHull.
      Measure the fraction of points discarded on three random datasets of size \(n=500\), and report the speedup (if any).
    </li>

    <li><strong>Related geometric problem: Point-in-convex-polygon test:</strong>
      Once you have a hull \(H\) (vertices in CCW order), design an \(O(\log h)\) test to decide if a point \(Q\) lies inside \(H\).
      <ul>
        <li><em>Algorithm sketch:</em> Treat \(H\) as a "fan" around \(H[0]\); binary search over angle (or wedge index) to locate the triangle \(\triangle H[0]\,H[i]\,H[i+1]\) that could contain \(Q\), then use a constant number of orientation tests.</li>
        <li><em>Deliverables:</em> (i) brief pseudocode, (ii) a drawn example on one of the hulls from this homework with 3 test points (inside, on-edge, outside), and (iii) a short note on why the runtime is \(O(\log h)\).</li>
      </ul>
    </li>
    <li><strong>3D Extension:</strong> Research and describe how the convex hull problem extends to three dimensions.
        What are the main algorithmic differences, and what is the time complexity of 3D convex hull algorithms?</li>

  </ol>
</section>
</body>

</html>