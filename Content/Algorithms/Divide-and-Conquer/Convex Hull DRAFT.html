<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Convex Hull (Divide-and-Conquer)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="/Algorithms/scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="/Algorithms/css/style.css">
  <link rel="stylesheet" href="/Algorithms/css/chapter.css">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-DQ5LVZVFDC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-DQ5LVZVFDC');
  </script>
</head>
<body>
  <h1>Convex Hull (Divide-and-Conquer)</h1>

  <section id="problem-solved" section-title="Problem Solved">
  <h2>Problem Solved</h2>
  <p>
    The divide-and-conquer convex hull algorithm solves the
    <a class="problem" href="?path=Problems%2FGeometry%2FConvex%20Hull">Convex Hull</a>
    problem by recursively finding convex hulls of smaller point sets and merging them together.
  </p>
  </section>

  <section id="design" section-title="Design and Strategy">
  <h2>Design and Strategy</h2>
  <p>
    The divide-and-conquer approach to convex hull construction follows the classic paradigm: divide the point set into smaller subsets, recursively compute their convex hulls, then merge the results. The key geometric insight is that when merging two convex hulls, we only need to find the upper and lower tangent lines between them.
  </p>
  
  <p>
    <strong>Core Geometric Computations:</strong>
  </p>
  <ul>
    <li><strong>Orientation Test:</strong> Determines if three points make a left turn, right turn, or are collinear using the cross product</li>
    <li><strong>Tangent Finding:</strong> Locates the upper and lower tangent lines between two convex polygons</li>
    <li><strong>Hull Merging:</strong> Combines two convex hulls by removing interior points and connecting via tangents</li>
  </ul>

  <p><strong>Algorithm Steps:</strong></p>
  <ol>
    <li>Sort points by x-coordinate (preprocessing step)</li>
    <li><strong>Base Case:</strong> If â‰¤ 3 points, compute hull directly</li>
    <li><strong>Divide:</strong> Split points into left and right halves</li>
    <li><strong>Conquer:</strong> Recursively compute convex hulls of both halves</li>
    <li><strong>Merge:</strong> Find upper and lower tangent lines between the two hulls</li>
    <li>Remove points that are now interior and connect the hulls via the tangents</li>
  </ol>

  <p>The geometric challenge lies in efficiently finding the tangent lines and handling degenerate cases like collinear points.</p>
  </section>

  <section id="demo" section-title="Interactive Demo">
  <div class="embeddedDemoContainer">
    <iframe class="embeddedDemo"
            src="/Algorithms/Content/Demos/Divide-and-Conquer/Convex Hull Demo.html"
            allow="fullscreen"
            name="CONVEX_HULL-demo">
    </iframe>
  </div>
  </section>

  <section id="code" section-title="Implementation in Java, C++, Python">
  <h2>Implementation in Java, C++, Python</h2>
  <p>The implementations use a Point class with x,y coordinates and include the essential geometric primitives for orientation testing and tangent finding.</p>
  <div class="tab-group">
    <div class="tabs" role="tablist">
      <button id="tab-java" class="tablink active" data-lang="java" role="tab" aria-controls="java" aria-selected="true">Java</button>
      <button id="tab-cpp" class="tablink" data-lang="cpp" role="tab" aria-controls="cpp" aria-selected="false">C++</button>
      <button id="tab-python" class="tablink" data-lang="python" role="tab" aria-controls="python" aria-selected="false">Python</button>
    </div>
    <div id="java" class="code-container active" role="tabpanel" aria-labelledby="tab-java">
      <pre><code class="language-java">import java.util.*;

class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}

public class ConvexHullDC {
    // Returns positive if counter-clockwise, negative if clockwise, 0 if collinear
    private static long cross(Point O, Point A, Point B) {
        return (long)(A.x - O.x) * (B.y - O.y) - (long)(A.y - O.y) * (B.x - O.x);
    }
    
    public static List<Point> convexHull(Point[] points) {
        if (points.length <= 1) return Arrays.asList(points);
        
        // Sort by x-coordinate
        Arrays.sort(points, (a, b) -> a.x != b.x ? a.x - b.x : a.y - b.y);
        
        return divideConquer(points, 0, points.length - 1);
    }
    
    private static List<Point> divideConquer(Point[] points, int left, int right) {
        if (right - left + 1 <= 3) {
            return bruteForceHull(points, left, right);
        }
        
        int mid = left + (right - left) / 2;
        List<Point> leftHull = divideConquer(points, left, mid);
        List<Point> rightHull = divideConquer(points, mid + 1, right);
        
        return mergeHulls(leftHull, rightHull);
    }
    
    private static List<Point> bruteForceHull(Point[] points, int left, int right) {
        List<Point> hull = new ArrayList<>();
        for (int i = left; i <= right; i++) {
            hull.add(points[i]);
        }
        
        if (hull.size() <= 2) return hull;
        
        // Find convex hull of 3 points
        if (cross(hull.get(0), hull.get(1), hull.get(2)) < 0) {
            Collections.swap(hull, 1, 2);
        }
        return hull;
    }
    
    private static List<Point> mergeHulls(List<Point> left, List<Point> right) {
        // Find rightmost point of left hull and leftmost point of right hull
        int leftMax = 0, rightMin = 0;
        for (int i = 0; i < left.size(); i++) {
            if (left.get(i).x > left.get(leftMax).x) leftMax = i;
        }
        for (int i = 0; i < right.size(); i++) {
            if (right.get(i).x < right.get(rightMin).x) rightMin = i;
        }
        
        // Find upper tangent
        int[] upperTangent = findUpperTangent(left, right, leftMax, rightMin);
        // Find lower tangent  
        int[] lowerTangent = findLowerTangent(left, right, leftMax, rightMin);
        
        return constructMergedHull(left, right, upperTangent, lowerTangent);
    }
    
    private static int[] findUpperTangent(List<Point> left, List<Point> right, 
                                         int leftIdx, int rightIdx) {
        while (true) {
            boolean changed = false;
            
            // Check if we can move right index clockwise
            int rightNext = (rightIdx + 1) % right.size();
            if (cross(left.get(leftIdx), right.get(rightIdx), right.get(rightNext)) > 0) {
                rightIdx = rightNext;
                changed = true;
            }
            
            // Check if we can move left index counter-clockwise
            int leftPrev = (leftIdx - 1 + left.size()) % left.size();
            if (cross(right.get(rightIdx), left.get(leftIdx), left.get(leftPrev)) > 0) {
                leftIdx = leftPrev;
                changed = true;
            }
            
            if (!changed) break;
        }
        return new int[]{leftIdx, rightIdx};
    }
    
    private static int[] findLowerTangent(List<Point> left, List<Point> right,
                                         int leftIdx, int rightIdx) {
        while (true) {
            boolean changed = false;
            
            // Check if we can move right index counter-clockwise
            int rightPrev = (rightIdx - 1 + right.size()) % right.size();
            if (cross(left.get(leftIdx), right.get(rightIdx), right.get(rightPrev)) < 0) {
                rightIdx = rightPrev;
                changed = true;
            }
            
            // Check if we can move left index clockwise
            int leftNext = (leftIdx + 1) % left.size();
            if (cross(right.get(rightIdx), left.get(leftIdx), left.get(leftNext)) < 0) {
                leftIdx = leftNext;
                changed = true;
            }
            
            if (!changed) break;
        }
        return new int[]{leftIdx, rightIdx};
    }
    
    private static List<Point> constructMergedHull(List<Point> left, List<Point> right,
                                                  int[] upper, int[] lower) {
        List<Point> merged = new ArrayList<>();
        
        // Add points from left hull (from upper to lower tangent)
        int i = upper[0];
        while (i != lower[0]) {
            merged.add(left.get(i));
            i = (i + 1) % left.size();
        }
        merged.add(left.get(lower[0]));
        
        // Add points from right hull (from lower to upper tangent)
        i = lower[1];
        while (i != upper[1]) {
            merged.add(right.get(i));
            i = (i + 1) % right.size();
        }
        merged.add(right.get(upper[1]));
        
        return merged;
    }
}</code></pre>
    </div>
    <div id="cpp" class="code-container" role="tabpanel" aria-labelledby="tab-cpp">
      <pre><code class="language-cpp">#include <vector>
#include <algorithm>
#include <iostream>

struct Point {
    long long x, y;
    Point(long long x = 0, long long y = 0) : x(x), y(y) {}
};

class ConvexHullDC {
private:
    // Cross product: returns positive for counter-clockwise, negative for clockwise
    static long long cross(const Point& O, const Point& A, const Point& B) {
        return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
    }
    
    static std::vector<Point> bruteForceHull(std::vector<Point>& points, int left, int right) {
        std::vector<Point> hull;
        for (int i = left; i <= right; i++) {
            hull.push_back(points[i]);
        }
        
        if (hull.size() <= 2) return hull;
        
        // Ensure counter-clockwise order for 3 points
        if (cross(hull[0], hull[1], hull[2]) < 0) {
            std::swap(hull[1], hull[2]);
        }
        return hull;
    }
    
    static std::pair<int, int> findUpperTangent(const std::vector<Point>& left,
                                                const std::vector<Point>& right,
                                                int leftIdx, int rightIdx) {
        bool changed = true;
        while (changed) {
            changed = false;
            
            // Try moving right index clockwise
            int rightNext = (rightIdx + 1) % right.size();
            if (cross(left[leftIdx], right[rightIdx], right[rightNext]) > 0) {
                rightIdx = rightNext;
                changed = true;
            }
            
            // Try moving left index counter-clockwise  
            int leftPrev = (leftIdx - 1 + left.size()) % left.size();
            if (cross(right[rightIdx], left[leftIdx], left[leftPrev]) > 0) {
                leftIdx = leftPrev;
                changed = true;
            }
        }
        return {leftIdx, rightIdx};
    }
    
    static std::pair<int, int> findLowerTangent(const std::vector<Point>& left,
                                                const std::vector<Point>& right,
                                                int leftIdx, int rightIdx) {
        bool changed = true;
        while (changed) {
            changed = false;
            
            // Try moving right index counter-clockwise
            int rightPrev = (rightIdx - 1 + right.size()) % right.size();
            if (cross(left[leftIdx], right[rightIdx], right[rightPrev]) < 0) {
                rightIdx = rightPrev;
                changed = true;
            }
            
            // Try moving left index clockwise
            int leftNext = (leftIdx + 1) % left.size();
            if (cross(right[rightIdx], left[leftIdx], left[leftNext]) < 0) {
                leftIdx = leftNext;
                changed = true;
            }
        }
        return {leftIdx, rightIdx};
    }
    
    static std::vector<Point> mergeHulls(const std::vector<Point>& left,
                                        const std::vector<Point>& right) {
        // Find extreme points
        int leftMax = 0, rightMin = 0;
        for (int i = 0; i < left.size(); i++) {
            if (left[i].x > left[leftMax].x) leftMax = i;
        }
        for (int i = 0; i < right.size(); i++) {
            if (right[i].x < right[rightMin].x) rightMin = i;
        }
        
        auto [upperL, upperR] = findUpperTangent(left, right, leftMax, rightMin);
        auto [lowerL, lowerR] = findLowerTangent(left, right, leftMax, rightMin);
        
        std::vector<Point> merged;
        
        // Add left hull points from upper to lower tangent
        int i = upperL;
        while (i != lowerL) {
            merged.push_back(left[i]);
            i = (i + 1) % left.size();
        }
        merged.push_back(left[lowerL]);
        
        // Add right hull points from lower to upper tangent
        i = lowerR;
        while (i != upperR) {
            merged.push_back(right[i]);
            i = (i + 1) % right.size();
        }
        merged.push_back(right[upperR]);
        
        return merged;
    }
    
    static std::vector<Point> divideConquer(std::vector<Point>& points, int left, int right) {
        if (right - left + 1 <= 3) {
            return bruteForceHull(points, left, right);
        }
        
        int mid = left + (right - left) / 2;
        auto leftHull = divideConquer(points, left, mid);
        auto rightHull = divideConquer(points, mid + 1, right);
        
        return mergeHulls(leftHull, rightHull);
    }
    
public:
    static std::vector<Point> convexHull(std::vector<Point> points) {
        if (points.size() <= 1) return points;
        
        std::sort(points.begin(), points.end(), 
                 [](const Point& a, const Point& b) {
                     return a.x < b.x || (a.x == b.x && a.y < b.y);
                 });
        
        return divideConquer(points, 0, points.size() - 1);
    }
};</code></pre>
    </div>
    <div id="python" class="code-container" role="tabpanel" aria-labelledby="tab-python">
      <pre><code class="language-python">class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

def cross_product(O, A, B):
    """Cross product of vectors OA and OB. Positive = counter-clockwise."""
    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x)

def convex_hull_dc(points):
    """Divide-and-conquer convex hull algorithm."""
    if len(points) <= 1:
        return points
    
    # Sort points by x-coordinate
    points.sort(key=lambda p: (p.x, p.y))
    
    return divide_conquer(points, 0, len(points) - 1)

def divide_conquer(points, left, right):
    """Recursive divide-and-conquer function."""
    if right - left + 1 <= 3:
        return brute_force_hull(points[left:right+1])
    
    mid = left + (right - left) // 2
    left_hull = divide_conquer(points, left, mid)
    right_hull = divide_conquer(points, mid + 1, right)
    
    return merge_hulls(left_hull, right_hull)

def brute_force_hull(points):
    """Base case: compute hull of â‰¤3 points."""
    if len(points) <= 2:
        return points
    
    # For 3 points, ensure counter-clockwise order
    if cross_product(points[0], points[1], points[2]) < 0:
        points[1], points[2] = points[2], points[1]
    
    return points

def find_upper_tangent(left_hull, right_hull, left_idx, right_idx):
    """Find upper tangent between two convex hulls."""
    while True:
        changed = False
        
        # Try moving right index clockwise
        right_next = (right_idx + 1) % len(right_hull)
        if cross_product(left_hull[left_idx], right_hull[right_idx], 
                        right_hull[right_next]) > 0:
            right_idx = right_next
            changed = True
        
        # Try moving left index counter-clockwise
        left_prev = (left_idx - 1) % len(left_hull)
        if cross_product(right_hull[right_idx], left_hull[left_idx], 
                        left_hull[left_prev]) > 0:
            left_idx = left_prev
            changed = True
        
        if not changed:
            break
    
    return left_idx, right_idx

def find_lower_tangent(left_hull, right_hull, left_idx, right_idx):
    """Find lower tangent between two convex hulls."""
    while True:
        changed = False
        
        # Try moving right index counter-clockwise
        right_prev = (right_idx - 1) % len(right_hull)
        if cross_product(left_hull[left_idx], right_hull[right_idx], 
                        right_hull[right_prev]) < 0:
            right_idx = right_prev
            changed = True
        
        # Try moving left index clockwise
        left_next = (left_idx + 1) % len(left_hull)
        if cross_product(right_hull[right_idx], left_hull[left_idx], 
                        left_hull[left_next]) < 0:
            left_idx = left_next
            changed = True
        
        if not changed:
            break
    
    return left_idx, right_idx

def merge_hulls(left_hull, right_hull):
    """Merge two convex hulls."""
    # Find extreme points for starting tangent search
    left_max_idx = max(range(len(left_hull)), key=lambda i: left_hull[i].x)
    right_min_idx = min(range(len(right_hull)), key=lambda i: right_hull[i].x)
    
    # Find tangents
    upper_left, upper_right = find_upper_tangent(left_hull, right_hull, 
                                                left_max_idx, right_min_idx)
    lower_left, lower_right = find_lower_tangent(left_hull, right_hull, 
                                                left_max_idx, right_min_idx)
    
    # Construct merged hull
    merged = []
    
    # Add points from left hull (upper to lower tangent)
    i = upper_left
    while i != lower_left:
        merged.append(left_hull[i])
        i = (i + 1) % len(left_hull)
    merged.append(left_hull[lower_left])
    
    # Add points from right hull (lower to upper tangent)
    i = lower_right
    while i != upper_right:
        merged.append(right_hull[i])
        i = (i + 1) % len(right_hull)
    merged.append(right_hull[upper_right])
    
    return merged

# Example usage:
if __name__ == "__main__":
    points = [Point(0, 3), Point(1, 1), Point(2, 2), Point(4, 4), 
              Point(0, 0), Point(1, 2), Point(3, 1), Point(3, 3)]
    
    hull = convex_hull_dc(points)
    print("Convex Hull:", hull)</code></pre>
    </div>
  </div>
  </section>

  <section id="analysis" section-title="Time/Space Analysis">
  <h2>Time/Space Analysis</h2>
  <p><strong>Time Complexity:</strong> O(n log n). The algorithm follows the recurrence T(n) = 2T(n/2) + O(n), where the O(n) comes from the merging step. The initial sorting takes O(n log n), and by the Master Theorem, the divide-and-conquer portion also takes O(n log n).</p>
  <p><strong>Space Complexity:</strong> O(n) for storing the hull points, plus O(log n) for the recursion stack depth. The space complexity is dominated by the storage of points rather than the recursive calls.</p>
  </section>
  
  
  <section id="variations" section-title="Variations/Improvements">
  <h2>Variations/Improvements</h2>
  <p>
    <strong>Graham Scan:</strong> An alternative O(n log n) algorithm that sorts by polar angle and uses a stack-based approach. Often simpler to implement but may have numerical stability issues with floating-point arithmetic.
  </p>
  <p>
    <strong>Jarvis March (Gift Wrapping):</strong> O(nh) algorithm where h is the number of hull points. Better when the hull is small relative to the total points, but worst-case O(nÂ²).
  </p>
  <p>
    <strong>Chan's Algorithm:</strong> Combines divide-and-conquer with gift wrapping to achieve O(n log h) time complexity, optimal when h is small.
  </p>
  <p>
    <strong>QuickHull:</strong> Expected O(n log n) but worst-case O(nÂ²). Often faster in practice due to good average-case performance and simple implementation.
  </p>
  </section>

  <section id="links" section-title="Links to Resources">
  <h2>Links to Resources</h2>
  <ul>
    <li><a href="https://en.wikipedia.org/wiki/Convex_hull_algorithms" target="_blank">Wikipedia: Convex Hull Algorithms</a> Comprehensive overview of different approaches</li>
    <li><a href="https://www.cs.jhu.edu/~mdinitz/classes/IntroAlgorithms/Spring2014/Notes/convex_hull.pdf" target="_blank">JHU Algorithm Notes</a> Mathematical treatment with detailed proofs</li>
    <li><a href="https://cp-algorithms.com/geometry/convex-hull.html" target="_blank">CP-Algorithms: Convex Hull</a> Implementation-focused tutorial with multiple algorithms</li>
  </ul>
  </section>

  <section id="reading-questions" section-title="Reading Comprehension Questions">
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li><strong>Geometric Primitive:</strong> What does the cross product tell us about the orientation of three points, and why is this crucial for convex hull algorithms?</li>
      <li><strong>Tangent Lines:</strong> In the merge step, why do we need both upper and lower tangent lines? What would happen if we only found one?</li>
      <li><strong>Complexity Analysis:</strong> Explain why the merging step takes O(n) time even though finding tangents might seem like it could take longer.</li>
      <li><strong>Degenerate Cases:</strong> How should the algorithm handle collinear points? Should they be included on the hull boundary?</li>
    </ol>
    <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
    <div id="answers" class="answer" hidden>
      <ol>
        <li><strong>Answer:</strong> The cross product of vectors OA and OB tells us the orientation: positive means counter-clockwise (left turn), negative means clockwise (right turn), zero means collinear. This is essential because convex hull algorithms need to determine whether adding a point would create a "left turn" (convex) or "right turn" (concave).</li>
        <li><strong>Answer:</strong> Both tangent lines are needed to properly connect the two convex hulls. The upper and lower tangents define the "bridge" between the hulls - points between these tangents in each hull become interior points and must be removed from the final hull.</li>
        <li><strong>Answer:</strong> Although finding each tangent might require examining several points, the total work is bounded by O(n) because each point can be examined a constant number of times across all merge operations at any given level of recursion.</li>
        <li><strong>Answer:</strong> Collinear points on the hull boundary can be handled in two ways: either include all collinear points (useful for some applications) or exclude interior collinear points (minimal hull). The algorithm should be consistent in its choice and handle the cross product returning zero appropriately.</li>
      </ol>
    </div>
  </section>

  <section id="activities" section-title="In-Class Activities">
    <h2>In-Class Activities</h2>
    <ol>
      <li><strong>Tangent Finding Practice:</strong> Given two simple convex polygons drawn on paper, have students manually find the upper and lower tangent lines and explain their reasoning.</li>
      <li><strong>Merge Simulation:</strong> Provide students with two pre-computed convex hulls and walk through the merging process step by step, identifying which points become interior.</li>
      <li><strong>Cross Product Calculation:</strong> Practice computing cross products for triplets of points and determining orientation, including handling of edge cases like collinear points.</li>
      <li><strong>Algorithm Tracing:</strong> Trace through the complete divide-and-conquer algorithm on a small set of 6-8 points, showing the recursive calls and merge steps.</li>
    </ol>
  </section>

  <section id="problems" section-title="Homework Problems">
    <h2>Homework Problems</h2>
    <ol>
      <li><strong>Implementation Verification:</strong> Implement the divide-and-conquer convex hull algorithm and verify it produces correct results on several test cases including edge cases (collinear points, duplicate points, triangles).</li>
      <li><strong>Comparative Analysis:</strong> Implement both the divide-and-conquer and Graham scan algorithms, then compare their performance on randomly generated point sets of varying sizes. Explain any differences observed.</li>
      <li><strong>Geometric Applications:</strong> Given a set of 2D points representing locations of cell towers, write a program that finds the convex hull and calculates the area enclosed by the hull (useful for coverage area estimation).</li>
      <li><strong>3D Extension:</strong> Research and describe how the convex hull problem extends to three dimensions. What are the main algorithmic differences, and what is the time complexity of 3D convex hull algorithms?</li>
    </ol>
  </section>

</body>
</html>
