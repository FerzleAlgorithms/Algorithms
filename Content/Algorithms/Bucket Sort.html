<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
  <title>Bucket Sort</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="../../scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/chapter.css">

</head>
<body>

  <h1>Bucket Sort</h1>

  <h2>Problem Solved</h2>
  <p>Bucket Sort solves the <a class="problem" href="?path=Problems%2F1_Foundational%2FSorting">Sorting</a> problem by distributing elements into buckets and sorting each bucket individually.</p>

  <h2>Design and Strategy</h2>
  <p>
    Bucket Sort works by partitioning an array into a fixed number of <strong>buckets</strong>, 
    each covering a subrange of the input values. 
    Each element is placed into its corresponding bucket based on its value. 
    Once all elements have been distributed, each bucket is sorted individually and 
    its contents are merged back into the original array in order, producing the fully sorted sequence. 
    Bucket Sort leverages a <strong>space–time tradeoff</strong>, using extra memory for bucket 
    storage to significantly accelerate sorting time on uniformly distributed data.
   </p>
   
   <p>
    The algorithm proceeds in two main phases:
       <ul>
         <li><strong>Distribution Phase:</strong>
    A loop index <em>i</em> (<em>current position in <code>arr</code></em>) traverses the original array <code>arr</code>.  
    First, the bucket’s width is computed as  
    \(
    \mathrm{range} \;=\; \frac{\max - \min}{k} + \epsilon
    \),
    Where:
           <ul>
             <li>\(\max\) and \(\min\) are the maximum and minimum values in <code>arr</code>,</li>
             <li>\(k\) is the total number of buckets,</li>
             <li>\(\epsilon\) is a small constant (e.g. 1e-8) to avoid zero-width buckets.</li>
           </ul>
    Then for each element,
    \(
    idx = \left\lfloor \frac{arr[i] - \min}{\mathrm{range}} \right\rfloor
    \)
    is used to select its bucket—here <code>idx</code> denotes the bucket index—and the element <code>arr[i]</code> is appended accordingly.
         </li>
         <li><strong>Collection Phase:</strong>
    Each bucket is sorted in place using Selection Sort. A write-pointer <em>pos</em> tracks the next index in <code>arr</code> (starting at 0); after sorting a bucket, each value in the bucket is copied back into <code>arr[pos]</code> and <em>pos</em> is incremented.
         </li>
       </ul>
    This two-step approach—first distributing, then sorting and collecting—ensures every element reaches its final sorted position efficiently.
     </p>
  
  <div class="embeddedDemoContainer">
    <iframe class="embeddedDemo"
            src="../Demos/Bucket Sort Demo.html"
            allowfullscreen allow="fullscreen"
            style="width:100%; height:425px; border:none;">
    </iframe>
  </div>

  <h2>Implementation in Java, C++, Python</h2>
<div class="tab-group">
<div class="tabs" role="tablist">
   <button
    id="tab-java"
    class="tablink active"
    data-lang="java"
    role="tab"
    aria-controls="java"
    aria-selected="true">
    Java
  </button>
   <button
    id="tab-cpp"
    class="tablink"
    data-lang="cpp"
    role="tab"
    aria-controls="c++"
    aria-selected="true">
    C++
  </button>
   <button
    id="tab-python"
    class="tablink"
    data-lang="python"
    role="tab"
    aria-controls="python"
    aria-selected="true">
    Python
  </button>
  </div>
  <div id="java" class="code-container active" role="tabpanel"  aria-labelledby="tab-java">
<pre><code class="language-java">private static void selectionSort(List<Double> bucket) {
  for (int i = 0; i < bucket.size(); i++) {
      int minIdx = i;
      for (int j = i + 1; j < bucket.size(); j++) {
          if (bucket.get(j) < bucket.get(minIdx)) {
              minIdx = j;
          }
      }
      double temp = bucket.get(i);
      bucket.set(i, bucket.get(minIdx));
      bucket.set(minIdx, temp);
  }
}

public static void bucketSortInPlace(double[] arr, int bucketCount) {
  if (arr.length == 0) return;
  double min = arr[0], max = arr[0];
  for (double num : arr) { min = Math.min(min, num); max = Math.max(max, num); }
  double range = (max - min) / bucketCount + 1e-8;

  List<List<Double>> buckets = new ArrayList<>();
  for (int i = 0; i < bucketCount; i++) buckets.add(new ArrayList<>());
  for (double num : arr) {
      int idx = (int) ((num - min) / range);
      buckets.get(idx).add(num);
  }

  int pos = 0;
  for (List<Double> bucket : buckets) {
      selectionSort(bucket);
      for (double val : bucket) arr[pos++] = val;
  }
}</code></pre>
    </div>

  <div id="cpp" class="code-container active" role="tabpanel"  aria-labelledby="tab-cpp">
<pre><code class="language-cpp">tatic void selectionSort(std::vector<double>& bucket) {
  for (size_t i = 0; i < bucket.size(); ++i) {
      size_t minIdx = i;
      for (size_t j = i + 1; j < bucket.size(); ++j) {
          if (bucket[j] < bucket[minIdx]) minIdx = j;
      }
      std::swap(bucket[i], bucket[minIdx]);
  }
}

void bucketSortInPlace(std::vector<double>& arr, int bucketCount) {
  if (arr.empty()) return;
  double min = *std::min_element(arr.begin(), arr.end());
  double max = *std::max_element(arr.begin(), arr.end());
  double range = (max - min) / bucketCount + 1e-8;

  std::vector<std::vector<double>> buckets(bucketCount);
  for (double num : arr) {
      int idx = int((num - min) / range);
      buckets[idx].push_back(num);
  }

  int pos = 0;
  for (auto &bucket : buckets) {
      selectionSort(bucket);
      for (double num : bucket) arr[pos++] = num;
  }
}</code></pre>
    </div>

  <div id="python" class="code-container active" role="tabpanel"  aria-labelledby="tab-python">
<pre><code class="language-python">def selection_sort(bucket):
  for i in range(len(bucket)):
      min_idx = i
      for j in range(i + 1, len(bucket)):
          if bucket[j] < bucket[min_idx]:
              min_idx = j
      bucket[i], bucket[min_idx] = bucket[min_idx], bucket[i]

def bucket_sort_inplace(arr, bucket_count=10):
  if not arr:
      return arr

  # 1. Find min/max and range per bucket
  min_val, max_val = min(arr), max(arr)
  bucket_range = (max_val - min_val) / bucket_count + 1e-8

  # 2. Distribute into buckets
  buckets = [[] for _ in range(bucket_count)]
  for num in arr:
      idx = int((num - min_val) / bucket_range)
      buckets[idx].append(num)

  # 3. Sort each bucket and merge back
  idx = 0
  for bucket in buckets:
      selection_sort(bucket)
      for num in bucket:
          arr[idx] = num
          idx += 1

  return arr</code></pre>
    </div>
	</div>

    <h2>Time/Space Analysis</h2>
<p>For analysis we have an array of size <em>n</em> and <em>k</em> buckets.</p>

<p>
  <strong>Best-Case Time Complexity:</strong><br>
  When the input is exactly uniform—so each bucket ends up with only a constant number of elements—sorting each bucket takes \(O(1)\) time.  
  The distribution step is \(O(n)\).  
  The collection phase involves scanning all \(k\) buckets and placing \(n\) elements in the main array, which is \(O(k + n)\).  
  Altogether, the best-case bound is \(O(n) + O(k + n) = O(n + k)\).
</p>

<p>
  <strong>Average-Case Time Complexity:</strong><br>
  If the input is roughly uniform, each of the \(k\) buckets will receive about \(\tfrac{n}{k}\) elements.  
  Sorting one bucket of size \(\approx\frac{n}{k}\) by Selection Sort costs \(O\bigl((n/k)^{2}\bigr)\).  
  Since there are \(k\) buckets, the total cost of the collection (sorting) phase is  
  \(k \times O\bigl((n/k)^{2}\bigr) = O\bigl(n^{2}/k\bigr)\).  
  The distribution phase still takes \(O(n)\).  
  Altogether, the average-case complexity is  
  \(O\bigl(n + n^{2}/k\bigr)\),  
  which approaches \(O(n + k)\) when \(k = \Theta(n)\).
</p>

<p>
  <strong>Worst-Case Time Complexity:</strong><br>
  In the worst case, all elements fall into a single bucket—one of size <em>n</em> and <em>k − 1</em> empty buckets.  
  Sorting that bucket with Selection Sort takes \(O(n^2)\), the distribution step is \(O(n)\), and the collection step is \(O(k)\).  
  Hence the overall bound is  
  \(O(n^2) + O(n) + O(k) = O(n^2 + k)\).
</p>

<p>
  <strong>Space Complexity:</strong>  
  For the <strong>Best</strong>, <strong>Average</strong>, and <strong>Worst</strong> cases we have \(O(n+k)\) space, since we allocate <em>k</em> buckets and store all <em>n</em> elements among them.
</p>
    
    <h2>Variations/Improvements</h2>
<ul>
    <li>
        <strong>Dynamic Bucket Sizing</strong>:
        Instead of choosing a fixed <em>k</em> in advance, estimate the input’s variance or range and set
        \(k = \lceil \sqrt{n} \rceil\) (or use another heuristic). This ensures buckets are neither too large (avoiding \(O(n^2)\) sorts) nor too many (minimizing overhead).
        <p class="note">
          A common rule is choosing
          \(
            k \approx \frac{n}{\log n}
          \)
          for random data, which balances distribution cost with per-bucket sort time.
        </p>
      </li>
      
    <strong>Parallel Bucket Sort</strong>:  
    Leverage multiple cores by dividing work into independent stages:
    <ul>
      <li><strong>Distribution:</strong> one thread computes global \(\frac{min}{max}\), then all threads cooperatively place chunks of the array into shared buckets (with synchronization).</li>
      <li><strong>Bucket Sort:</strong> assign each bucket to a separate thread or task to sort in-place (e.g. Selection Sort or another small-array algorithm).</li>
      <li><strong>Collection:</strong> merge the sorted buckets back into the array in parallel or via a simple scan.</li>
    </ul>
    <p class="note">
      This approach achieves near-linear speedup when the number of buckets (and thus threads) matches available cores.
    </p>
  </li>
  <li>
    <strong>Adaptive Bucket Sort</strong>:  
    Instead of fixing <em>k</em> beforehand, monitor bucket fill levels and  
    dynamically split any bucket whose size exceeds a threshold, or merge adjacent buckets that are too small.  
    <p class="note">
      By keeping bucket sizes balanced even on skewed inputs, this variant can approach \(O(n \log n)\) worst-case while retaining linear-time regions.
    </p>
  </li>
  <li>
    <strong>Radix–Bucket Hybrid</strong>:  
    Distribute elements by each digit position (as in radix sort) into <em>b</em> buckets per pass, then collect and repeat for all digit positions.  
    <p class="note">
      Runs in \(O(d·(n + b))\), where <em>d</em> is the number of digits, often outperforming pure bucket or radix sort on large keys.
    </p>
  </li>
</ul>

    
    <h2>Helpful Links and Resources</h2>
    <ol>
      <li><a href="https://visualgo.net/en/sorting">Visualgo – Bucket Sort Visualization</a></li>
      <li><a href="https://www.geeksforgeeks.org/bucket-sort/">GeeksforGeeks – Bucket Sort Tutorial</a></li>
      <li><a href="https://en.wikipedia.org/wiki/Bucket_sort">Wikipedia – Bucket Sort</a></li>
      <li><a href="https://www.programiz.com/dsa/bucket-sort">Programiz Bucket Sort Algorithm </a></li>
    </ol>
    
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li>What assumption about the input distribution does bucket sort rely on for linear-time behavior?</li>
      <li>How does the choice of <code>k</code> (number of buckets) affect both time and space complexity?</li>
      <li>What is the purpose of the small constant ε when computing bucket width?</li>
      <li>Why is Insertion Sort used within each bucket rather than sorting algorithms such as Quicksort with faster time complexities?</li>
      <li>In what scenario does bucket sort degrade to \(O(n^2)\) time?</li>
      <li>Perform bucket sort on the array [60, 92, 16, 86, 97, 45, 98, 27, 48, 0, 11, 48] for values of k: 5,10, and 15. Avoid performing 
        Insertion sort on the buckets, just sort them how you normally would for the sake of time.
      </li>
    </ol>
    
    <button id="toggleAnswers" class="show-answer" aria-expanded="false" style="margin-top: 10px;">
      Show Answers
    </button>
    <div id="answers" class="answer" hidden style="margin-top: 10px;">
      <ol>
        <li><strong>Answer:</strong> It assumes the input values are distributed uniformly so that each bucket receives a small (constant) number of elements.</li>
        <li><strong>Answer:</strong> A larger <code>k</code> reduces bucket sizes (faster per-bucket sort) but uses more space; a smaller <code>k</code> uses less space but may increase per-bucket sort time.</li>
        <li><strong>Answer:</strong> ε prevents the bucket width from becoming zero when <code>max==min</code>, avoiding division-by-zero and empty-range issues.</li>
        <li><strong>Answer:</strong> Insertion Sort is efficient on small arrays (constant-sized), keeping overall overhead low and guaranteeing in-place behavior
            which is what we want since Bucket sort works best when its buckets are small.</li>
        <li><strong>Answer:</strong> When most or all elements fall into one bucket, that bucket’s sort dominates at \(O(n^2)\).</li>
        <li><strong>Answer:</strong> Look at demo.</li>
      </ol>
    </div>
    
    <h2>In-class Activities</h2>
    <ol>
      <li>Look at serveral examples of Bucket sort and show how different values of \(k\) affect how the perfromance of Bucket sort</li>
      <Li>Talk about Best, Average, and Worst time complexities of Bucket Sort and how data distrbution of an array (uniform vs skewed data) 
        affects these complexites.</Li>
      <li>Talk about using differnt sorting algorihtms on the Collection Phase of Bucket sort and why Insertion sort 
        is preferable in most cases.</li>
      <li>Go over the differences between Counting and Bucket sort, and one would be used over the other. For example Bucket sort 
        can work on floating point values, but Counting sort can't. 
      </li>
    </ol>
    
    <div class="section">
      <h2>Problems</h2>
      <ol>
        <li>Design a variant of Bucket sort so that it dynamically splits any bucket exceeding a threshold size during distribution. Prove its worst-case time bound.</li>
        <li>Suppose you have n integers drawn from [0, m). How would you choose <code>k</code> to minimize \(O(n + n^2/k)\)? Explain your reasoning.</li>
        <li>Explain the best and worst scenarios for Bucket Sort and Counting, then give an example of 12 elements for each scenario.</li>
        <p>
            Given the array <code>[2, 7, 4, 5, 9, 11, 8, 4, 11, 1, 5, 11]</code>, perform Bucket Sort three times using <code>k = 3</code>, <code>k = 9</code>, and <code>k = 12</code>. For each value of <code>k</code>, first compute the bucket width using  
            <code>width = (max – min) / k + ε</code>, then assign every element to its bucket according to <code>idx = ⌊(x – min) / width⌋</code>.
          </p>
          <p>
            Next, sort the contents of each bucket (you do not need to show individual swap steps) and concatenate all buckets in order to produce the final sorted array. In your write-up, include for each <code>k</code>: the numeric bucket width, the unsorted bucket contents, the sorted bucket contents, and the resulting sorted array.
          </p>
          
      </ol>
    </div>
      
</body>
</html>