<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sequential Search Tutorial &amp; Demo</title>
  <!-- GitHub-style for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="../../scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="../../style.css">

  <!-- MathJax for LaTeX rendering -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    #toggleAnswers { margin-top: 10px; padding: 5px 10px; }
  </style>
</head>
<body>

  <h1>Sequential Search</h1>
  
    <h2>Problem Solved</h2>
	Sequential Search solves the 
	<a class="problem" href="?path=Problems%2F1_Foundational%2FSearching">Searching</a>
	problem.
  
    <h2>Design and Strategy</h2>
    <p>
  Sequential Search (also called Linear Search) is a classic <strong>brute-force</strong> algorithm: it makes no assumptions about the order of the data and
  exhaustively tests every element. Starting at index <code>0</code>, it compares the value of each element to the target value; if a match is found,
  it immediately returns the index of that element. Otherwise, it moves to the next element, continuing until either the target is located or the end of the array is reached  at which point it returns -1.
  Because it “tries every possibility,” you are guaranteed to find 
  the target if it is present with no more than <code>n</code> comparisons.  </p>
  <p> 
  More formally, the algorithm works as follows:
</p>

    <ol>
      <li>Start with index <code>i = 0</code>.</li>
      <li>Compare <code>A[i]</code> with <code>target</code>.</li>
      <li>If they are equal, return <code>i</code>.</li>
      <li>Otherwise, increment <code>i</code>.</li>
      <li>If <code>i==n</code> (end of the array), return <code>-1</code>. Otherwise, repeat from step 2.</li>
    </ol>

    <div class="embeddedDemoContainer">
  <iframe class="embeddedDemo"
          src="../Demos/Sequential Search Demo.html"
          allowfullscreen 
          allow="fullscreen"
          style="width:100%; border:none;"
          name="sequential-search-demo">
  </iframe>
</div>
	
    <h2>Implementation in Java, C++, Python</h2>
<div class="tab-group">
<div class="tabs" role="tablist">
   <button
    id="tab-java"
    class="tablink active"
    data-lang="java"
    role="tab"
    aria-controls="java"
    aria-selected="true">
    Java
  </button>
   <button
    id="tab-cpp"
    class="tablink"
    data-lang="cpp"
    role="tab"
    aria-controls="c++"
    aria-selected="true">
    C++
  </button>
   <button
    id="tab-python"
    class="tablink"
    data-lang="python"
    role="tab"
    aria-controls="python"
    aria-selected="true">
    Python
  </button>
  </div>
  <div id="java" class="code-container active" role="tabpanel"  aria-labelledby="tab-java">
<pre><code class="language-java">public int sequentialSearch(int[] A, int target) {
  for (int i = 0; i < A.length; i++) {
    if (A[i] == target) {
      return i;
    }
  }
  return -1;
}</code></pre>
    </div>

  <div id="cpp" class="code-container active" role="tabpanel"  aria-labelledby="tab-cpp">
<pre><code class="language-cpp">int sequentialSearch(int A[], int n, int target) {
  for (int i = 0; i < n; i++) {
    if (A[i] == target) {
      return i;
    }
  }
  return -1;
}</code></pre>
    </div>

  <div id="python" class="code-container active" role="tabpanel"  aria-labelledby="tab-python">
<pre><code class="language-python">def sequential_search(A, target):
  for i, value in enumerate(A):
    if value == target:
      return i
  return -1</code></pre>
    </div>
	</div>

<h2>Time/Space Analysis</h2>
    
 <p><strong>Time Complexity:</strong> 
 We count the number of element-to-target comparisons as our cost metric. 
 If the target is found at position <em>k</em>, then
 <em>k</em> comparisons were executed since it compare the target with each of the first <em>k</em>
 elements until it found it. 
 If the target is not present, then it compared the target with every element of the array, so it 
did <em>m</em> comparisons.
</p>

<p>From this we can see:</p>
<ul>
  <li><strong>Best-case:</strong>  <em>O(1)</em> comparisons (e.g. target is at the first position).</li>
  <li><strong>Worst-case:</strong> <em>O(n) </em> comparisons (e.g. target is at the last position or absent).</li>
  <li><strong>Average-case:</strong> Assuming the searched value is equally likely to be present or absent:
  <ul>
    <li><strong>Value present:</strong> On average, the algorithm finds the value after checking about <em>n/2</em> elements.</li>
    <li><strong>Value absent:</strong> The algorithm always checks all <em>n</em> elements.</li>
  </ul>
  Thus, in either case, the average complexity is <em>O(n)</em>.
</li>

</ul>

 
  <p> <b>Space Complexity:</b> The iterative sequential search uses only a fixed number of additional variables:
  The loop index <code>i</code>, the space for the <code>target</code>, and the return value.
  and a few constant‐size temporaries (if any). Thus, the space complexity is <em>O(1)</em>.</p> 
  
<h2>Reading Comprehension Questions</h2>
<ol>
  <li><strong>Q1:</strong> What is the best-case time complexity for Sequential Search, and when does it occur?</li>
  <li><strong>Q2:</strong> What is the worst-case time complexity for Sequential Search, and when does it occur?</li>
  <li><strong>Q3:</strong> What algorithm technique does Sequential Search use, how do you know?</li>
  <li><strong>Q4:</strong> If the array contains multiple copies of the target, which index will this implementation return?</li>
  <li><strong>Q5:</strong> What is the space complexity of this algorithm?</li>
  <li><strong>Q6:</strong> How would you modify the algorithm to return all indices where the target occurs?</li>
</ol>
<button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
<div id="answers" class="answer" hidden>
  <ol>
    <li><strong>Answer:</strong> <code>O(1)</code>, when the target is at index 0.</li>
    <li><strong>Answer:</strong> <code>O(n)</code>, when the target is at the last position or not present.</li>
    <li><strong>Answer:</strong> Brute Force because it checks every element until it either finds the target or reaches the end.</li>
    <li><strong>Answer:</strong> It returns the index of the first matching element found.</li>
    <li><strong>Answer:</strong> <code>O(1)</code>, since it only uses a constant amount of extra space.</li>
    <li><strong>Answer:</strong> Collect matches in a list as you scan and return that list instead of stopping early.</li>
  </ol>
</div>
  

 <h2>In-Class Activities</h2>
<ol>
  <li>Walk through the algorithm on different arrays to count comparisons.</li>
  <li>Discuss how the target’s position affects performance.</li>
  <li>Compare and contrast with Binary Search on sorted data. Discuss in which cases you would use each.</li>
  <li>Explore handling of duplicate targets in various implementations.</li>
  <li>Simulate a <strong>sentinel-based</strong> Sequential Search: 
  place a copy of the target at the end to eliminate the boundary check, 
  then compare the number of comparisons and loop logic to the standard version.</li>
  </ol>

<h2>Problems</h2>
<ol>
  <li>Write code or pseudocode for a recursive version of Sequential Search.</li>
  <li>Adapt sequential search to operate on a singly linked list (with pseudocode).</li>
  <li>Write code or pseudocode for the version of the algorithm to <strong>return all indices</strong> 
  where the target occurs (not just the first). Analyze how this changes your time and space complexity.</li>
  <li>Implement a <strong>sentinel-based</strong> sequential search: 
  before scanning, append the target as a sentinel at the end of the array to remove the explicit bounds check; 
  then compare its performance (number of comparisons and code branches) against the standard implementation.
  Discuss any drawbacks of this approach.</li>
</ol>


</body>
</html>
