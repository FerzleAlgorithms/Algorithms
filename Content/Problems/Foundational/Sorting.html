<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sorting Problem</title>
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../css/problem.css">
</head>
<body>
  <h1>Sorting</h1>

  <section>
    <h2>Problem Description</h2>
    <p>
      Given a list (array) of elements, rearrange the elements into ascending (or descending) order.  </p>

    <h3>Input</h3>
    <p>
      An array of <em>n</em> elements <code>A=[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>n</sub>]</code>. Elements can be numbers, strings, or other comparable data types.
    </p>

    <h3>Output</h3>
    <p>
      A permutation of the input array such that the elements are ordered based on a specified comparison criterion (typically ascending or descending).
    </p>
  </section>

  <section>
    <h2>Motivation/Applications</h2>
    <p>
      Sorting algorithms are crucial in computing for tasks like searching efficiently, organizing databases, scheduling tasks, and improving the performance of algorithms that require sorted data. Efficient sorting impacts performance significantly in various real-world systems and applications, from database management to algorithmic trading.
    </p>
    <p>When sorting, sometimes it matters what happens to entries that are equal. This is particularly important when sorting data on multiple fields (e.g. first name and last name). A sorting algorithm that leaves equal entries in the same relative order is called <em>stable</em>. Otherwise it is called <em>unstable</em>.</p>
  </section>

  <section>
    <h2>Examples</h2>
    <div class="example-box">
      <strong class="example-title">Example 1</strong><br>
      <strong>Input:</strong> [4, 1, 3, 2]<br>
      <strong>Output:</strong> [1, 2, 3, 4]
    </div>
    <br>
    <div class="example-box">
      <strong class="example-title">Example 2</strong><br>
      <strong>Input:</strong> ["orange", "apple", "banana"]<br>
      <strong>Output:</strong> ["apple", "banana", "orange"]
    </div>
  </section>

  <section>
    <h2>Common Algorithms/Techniques</h2>
    <p>Sorting algorithms generally fall into two types: 
    Comparison-based and non-comparison-based. 
    <ul>
      <li><strong>Comparison-Based Sorting Algorithms</strong>
        <ul>
          <li>Bubble Sort</li>
          <li>Insertion Sort</li>
          <li>Selection Sort</li>
          <li>Merge Sort</li>
          <li>Quicksort</li>
          <li>Heapsort</li>
        </ul>
     </li>
     <li><strong>Non-Comparison-Based Sorting Algorithms</strong>
        <ul>
          <li>Bucket Sort</li>
          <li>Counting Sort</li>
          <li>Radix Sort</li>
        </ul>
     </li>
    <li><strong>Goofy and/or Bad Sorting Algorithms</strong>
        <ul>
      <li>Bogosort (randomly shuffle until the list is sorted)</li>
      <li>Bozosort (randomly swap two elements until the list is sorted)</li>
      <li>Stooge Sort (recursively sort overlapping two-thirds segments)</li>
      <li>Slowsort (deliberately inefficient divide-and-conquer "slow" sort)</li>
      <li>Sleep Sort (spawn a timer for each value and "print" after sleeping)</li>
      <li>Bogobogosort (repeat Bogosort multiple times for extra agony)</li>
      <li>Bead Sort (simulate gravity on beads&mdash;requires special hardware/setup)</li>
      <li>Gravity Sort (similar to Bead Sort, but with "falling" data particles)</li>
      <li>Quantum Bogosort (theoretical "quantum" version that tries all permutations at once)</li>
      <li>Gnome Sort (whimsical insertion-style sort with backtracking steps)</li>
    </ul>
   </li>
    </ul>

  </section>

  <section>
    <h2>Variants/Related Problems</h2>
    <ul>
      <li>Partial Sorting (finding top-k elements)</li>
      <li>Sorting Networks (parallel sorting)</li>
      <li>Sorting Linked Lists</li>
      <li>External Sorting (large data that doesn't fit into memory)</li>
    </ul>
  </section>
</body>
</html>
