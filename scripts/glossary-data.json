[
  {
    "variants": [
      "0-1 Knapsack Problem",
      "0-1 Knapsack",
      "Zero-One Knapsack Problem"
    ],
    "definition": "A problem of selecting items with given weights and values to maximize total value without exceeding capacity, where each item can be chosen at most once, solvable by dynamic programming in <em>O(n*W)</em> time."
  },
  {
    "variants": [
      "AVL Tree",
      "AVL Trees"
    ],
    "definition": "An AVL tree is a self-balancing binary search tree in which, for every node, the heights of its left and right subtrees differ by at most one. Guarantees the height of the BST with <em>n</em> nodes is no larger than about <em>1.44 log<sub>2</sub>n</em>."
  },
  {
    "variants": [
      "Abstract Data Type",
      "ADT",
      "Abstract Data Types",
      "ADTs"
    ],
    "definition": "A mathematical model for a data type defined by its behavior from a user's perspective, specifying possible values and operations without prescribing implementation details."
  },
  {
    "variants": [
      "Adjacency List",
      "Adjacency Lists"
    ],
    "definition": "A graph representation where for each vertex, a list of its adjacent vertices is stored. Basic operations including adding and removing edges, determining adjacency of vertices, and traversing neighbors can all be performed in time proportional to the degree of the vertex."
  },
  {
    "variants": [
      "Adjacency Matrix",
      "Adjacency Matrices"
    ],
    "definition": "A two-dimensional matrix representation of a graph where entry <em>(i,j)</em> indicates the presence or weight of an edge between vertices <em>i</em> and <em>j</em>. Operations like checking for an edge are constant time, while iterating over neighbors takes <em>O(n)</em> time per vertex."
  },
  {
    "variants": [
      "Algorithm",
      "Algorithms"
    ],
    "definition": "A finite sequence of well-defined instructions that completes a task."
  },
  {
    "variants": [
      "Amortized Analysis"
    ],
    "definition": "A method of analyzing the average running time of an operation over a sequence of calls. It is useful in situations where the worst-case running time of an algorithm occurs infrequently and its cost can essentially be hidden over a bunch of calls. A classic example is the fact that the average case of insertion or deletion on certain resizable arrays (e.g. Java's ArrayList) if <em>O(1)</em> even though on occasion it takes <em>O(n)</em> time."
  },
  {
    "variants": [
      "Approximation Algorithm"
    ],
    "definition": "An algorithm for optimization problems that runs in polynomial time and produces solutions within a guaranteed factor of the optimal, used when exact solutions are intractable."
  },
  {
    "variants": [
      "Array",
      "Arrays"
    ],
    "definition": "A collection of elements stored in contiguous memory, allowing constant-time access by index. Common operations include indexing, traversal, insertion, and deletion (insertion/deletion may require shifting elements)."
  },
  {
    "variants": [
      "Array Partition",
      "Array Partitions",
      "Array Partitioning"
    ],
    "definition": "The process of rearranging elements in an array so that at least one element (the pivot) is put in place (based on sorted order), elements less than the pivot come before it, and elements greater come after. It is a key step in Quick Sort and Quickselect. There are slight variations of partitioning that only ensure that at some index of the array, all elements before the index are smaller than all elements after the index, and no particular element is necessarily in place."
  },
  {
    "variants": [
      "Asymptotic Notation"
    ],
    "definition": "Mathematical notation (e.g., Big-O, Theta, Omega) used to describe the limiting behavior of a function as its input grows toward infinity. It abstracts constant factors and lower-order terms to focus on growth rates."
  },
  {
    "variants": [
      "Average-Case Analysis"
    ],
    "definition": "Evaluates an algorithm's expected performance over all inputs of size <em>n</em>, assuming a specified probability distribution on those inputs. It yields the expected time (or space) complexity by taking the weighted average of the cost across every possible input."
  },
  {
    "variants": [
      "B-Tree",
      "B-Trees"
    ],
    "definition": "A self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time, optimized for systems that read and write large blocks of data."
  },
  {
    "variants": [
      "Backtracking"
    ],
    "definition": "A paradigm for solving combinatorial problems by building candidates incrementally and abandoning a candidate (backtracking) as soon as it is determined to be invalid. Commonly used for problems like N-Queens and Sudoku. Such algorithms can be visualized using rooted trees (although the algorithms do not typically construct trees)."
  },
  {
    "variants": [
      "Base Case",
      "Base Cases"
    ],
    "definition": "The simplest instance of a recursive problem that can be solved directly without further recursion. Base cases are important to prevent infinite recursion by providing a stopping condition."
  },
  {
    "variants": [
      "Bellman-Ford Algorithm"
    ],
    "definition": "An algorithm that computes shortest paths from a single source to all vertices in a weighted digraph, even when edges can have negative weights, in <em>O(V*E)</em> time."
  },
  {
    "variants": [
      "Best-Case Analysis"
    ],
    "definition": "Evaluates an algorithm's performance on the most favorable inputs of size <em>n</em>, yielding the minimum time (or space) it will ever require. It characterizes the lower bound of the algorithm's resource usage under ideal conditions."
  },
  {
    "variants": [
      "Binary Exponentiation"
    ],
    "definition": "Binary exponentiation (or exponentiation by squaring) is an algorithm that computes <em>a<sup>n</sup></em> based on the binary representation of <em>n</em> in <em>O(log n)</em> time. It can be implemented left-to-right or right-to-left."
  },
  {
    "variants": [
      "Binary Search"
    ],
    "definition": "An algorithm for finding a target value in a sorted array by repeatedly dividing the search interval in half. It runs in O(log n) time by comparing the target to the middle element and discarding half of the search space at each step."
  },
  {
    "variants": [
      "Binary Search Tree",
      "Binary Search Trees",
      "BST",
      "BSTs"
    ],
    "definition": "A binary tree in which each node has a key, and all keys in the left subtree are less than the node's key, while those in the right subtree are greater. Operations like search, insert, and delete take <em>O(h)</em> time, where <em>h</em> is the tree height. The height can be as large as <em>n</em>, or <em>O(log n)</em> on average for balanced trees."
  },
  {
    "variants": [
      "Binary Tree",
      "Binary Trees"
    ],
    "definition": "A binary tree is a tree data structure in which each node has at most two children, typically designated as the left and right child."
  },
  {
    "variants": [
      "Bipartite Graph",
      "Bipartite Graphs",
      "Bipartite"
    ],
    "definition": "A graph whose vertices can be divided into two disjoint sets such that no two vertices within the same set are adjacent."
  },
  {
    "variants": [
      "Boyer-Moore Algorithm",
      "Boyer-Moore"
    ],
    "definition": "An efficient string-search algorithm that skips portions of the text to find occurrences of a pattern using bad-character and good-suffix heuristics."
  },
  {
    "variants": [
      "Branch-and-Bound"
    ],
    "definition": "A search algorithm that systematically explores branches of a solution space, using bounds to prune subproblems that cannot yield better solutions than the current best to reduce the number of potential candidates that must be examined. Often used for optimization problems."
  },
  {
    "variants": [
      "Breadth-First Search",
      "BFS"
    ],
    "definition": "A graph traversal algorithm that explores vertices in order of increasing distance from the source, using a queue. It visits all neighbors of a vertex before moving to the next level, running in <em>O(V + E)</em> time for adjacency list representation."
  },
  {
    "variants": [
      "Brute Force"
    ],
    "definition": "A brute-force algorithm is a straightforward, unoptimized method that solves a problem by directly performing all the basic steps dictated by the problem statement. While simple to implement, it often has very high time complexity and is used mainly when no better algorithm is known."
  },
  {
  "variants": [
    "Bubble sort"
  ],
  "definition": "Bubble sort is a simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This'bubbling' continues until no more swaps are needed. It runs in <em>O(n<sup>2</sup>>)</em> time on average and in the worst case, has a best-case of <em>O(n)</em> when the list is already sorted (with an optimized flag), and is both in-place and stable."
},
  {
    "variants": [
      "Bucket Sort"
    ],
    "definition": "A sorting algorithm that distributes elements into a number of buckets, sorts each bucket (often with Insertion Sort), and then concatenates the buckets. It achieves <em>O(n + k)</em> time when input list of <em>n</em> elements is uniformly distributed over a range and <em>k</em> buckets are used."
  },
  {
    "variants": [
      "Cartesian Coordinates",
      "Cartesian Coordinate System"
    ],
    "definition": "A coordinate system that specifies each point uniquely by a pair (or triplet) of numerical coordinates based on orthogonal axes. When you see points <em>(x,y)</em> or <em>(x,y,z)</em>, they are most likely specifying coordinates in this system."
  },
  {
    "variants": [
      "Catalan Number",
      "Catalan Numbers"
    ],
    "definition": "A sequence of natural numbers with many applications in combinatorial mathematics, defined by <em>C<sub>n</sub> = (1/(n+1)) * binomial(2n, n)</em>."
  },
  {
    "variants": [
      "Chained Hashing",
      "Open Hashing",
      "Separate Chaining"
    ],
    "definition": "A collision-resolution technique for hash tables where each bucket contains a linked list of elements that hash to the same index. Common operations include insert, search, and delete in <em>O(1 + a)</em> average time, where <em>a</em> is the load factor. Not to be confused with <em>Open Addressing</em>!"
  },
  {
    "variants": [
      "Clique",
      "Cliques",
      "k-Clique"
    ],
    "definition": "A subset of vertices in an undirected graph such that every pair of distinct vertices in the subset are adjacent."
  },
  {
    "variants": [
      "Coefficient",
      "Coefficients"
    ],
    "definition": "A constant multiplier of a variable or term, often appearing in polynomial expressions. In algorithm analysis, coefficients are the constant factors hidden in asymptotic notation."
  },
  {
    "variants": [
      "Coin Change Problem"
    ],
    "definition": "A problem asking for the number of ways to make change for a given amount using specified coin denominations or the minimum number of coins needed, often solved by dynamic programming."
  },
  {
    "variants": [
      "Combination",
      "Combinations"
    ],
    "definition": "A selection of a subset of items from a set where order does not matter."
  },
  {
    "variants": [
      "Comparison-Based",
      "Comparison-Based Algorithm",
      "Comparison-Based Sorting",
      "Comparison-Based Sorting Algorithm"
    ],
    "definition": "A technique that compares element on a list with each other to determine their proper order. The most common comparison-based sorting algorithms are Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, Quicksort, and Heapsort."
  },
  {
    "variants": [
      "Complete Graph"
    ],
    "definition": "A simple undirected graph in which every pair of distinct vertices is connected by an edge. The complete graph on <em>n</em> vertices is denoted <em>K<sub>n</sub></em>."
  },
  {
    "variants": [
      "Complexity Analysis"
    ],
    "definition": "The process of determining the time and space requirements of an algorithm as functions of input size. It involves evaluating best-case, average-case, and worst-case performance."
  },
  {
    "variants": [
      "Computational Complexity"
    ],
    "definition": "The amount of computational resources (space, time) required by an algorithm, often specified using asymptotic notation. Also refers to the field of study concerned with classifying computational problems based on their inherent difficulty and the resources required to solve them. It defines complexity classes such as P, NP, NP-hard, and NP-complete."
  },
  {
    "variants": [
      "Connected Component",
      "Connected Components"
    ],
    "definition": "A maximal set of vertices in a graph such that each pair of vertices in the set is connected by a path."
  },
  {
    "variants": [
      "Constant Time"
    ],
    "definition": "An operation that takes the same amount of time to complete regardless of the input size, denoted as <em>O(1)</em>. Examples include accessing an array element by index and basic arithmetic operations."
  },
  {
    "variants": [
      "Convex Hull",
      "Convex Hulls"
    ],
    "definition": "The smallest convex polygon that contains all points in a given set. Common algorithms for computing the convex hull include Quickhull and Graham's scan, both running in O(n log n) time."
  },
  {
    "variants": [
      "Counting Sort"
    ],
    "definition": "A non-comparison sorting algorithm that counts the occurrences of each value in the input and computes positions based on prefix sums. It runs in <em>O(n + k)</em> time on an array of size <em>n</em>, where <em>k</em> is the range of input values."
  },
  {
    "variants": [
      "Cut Vertex",
      "Articulation Point"
    ],
    "definition": "A vertex in a connected graph whose removal (with its incident edges) increases the number of connected components of the graph."
  },
  {
    "variants": [
      "DAG",
      "Directed Acyclic Graph"
    ],
    "definition": "A directed graph with no directed cycles, meaning it is impossible to start at a node and follow a consistently-directed sequence of edges that eventually loops back to the starting node."
  },
  {
    "variants": [
      "Data Structure",
      "Data Structures"
    ],
    "definition": "A way to store and organize data to enable efficient access and modification. Examples include arrays, linked lists, trees, graphs, stacks, queues, and hash tables."
  },
  {
    "variants": [
      "Decrease-and-Conquer"
    ],
    "definition": "An algorithm design paradigm that solves a problem by reducing it to a smaller instance of the same problem, solving that instance, and if necessary, extending its solution to the original problem."
  },
  {
    "variants": [
      "Degree Sequence",
      "Degree Sequences"
    ],
    "definition": "A sequence of vertex degrees in a graph, often used to characterize or test properties of the graph. For a simple graph, it is specified as a non-increasing sequence of integers."
  },
  {
    "variants": [
      "Depth-First Search",
      "DFS"
    ],
    "definition": "A graph traversal algorithm that explores as far as possible along each branch before backtracking, using a stack (often via recursion). It runs in <em>O(V + E)</em> time and is used for tasks like topological sorting and cycle detection."
  },
  {
    "variants": [
      "Dequeue",
      "Dequeues"
    ],
    "definition": "As a verb, it means to remove an element from a data structure, most commonly a queue. As a noun, it means a double-ended queue allowing insertion and deletion at both the front and back in <em>O(1)</em> time. Common operations include addFirst, addLast, removeFirst, and removeLast."
  },
  {
    "variants": [
      "Deterministic Algorithm"
    ],
    "definition": "An algorithm that, given a particular input, will always produce the same output and follow the same sequence of state transitions."
  },
  {
    "variants": [
      "Digraph",
      "Digraphs",
      "Directed Graph",
      "Directed Graphs"
    ],
    "definition": "A graph with directed edges."
  },
  {
    "variants": [
      "Dijkstra's Algorithm",
      "Dijkstra's",
      "Dijkstra Algorithm"
    ],
    "definition": "An algorithm for finding shortest paths from a single source to all other vertices in a graph with non-negative edge weights, using a priority queue for <em>O(E + V log V)</em> time performance."
  },
  {
    "variants": [
      "Disjoint Set",
      "Disjoint Sets"
    ],
    "definition": "In set theory, a collection of sets that have no elements in common with each other. For how they are often represented, see Union-Find."
  },
  {
    "variants": [
      "Divide-and-Conquer"
    ],
    "definition": "A paradigm in which a problem is recursively divided into two or more subproblems of the same (or very closely related) type, each subproblem is solved independently, and finally the solutions are combined."
  },
  {
    "variants": [
      "Dynamic Programming"
    ],
    "definition": "A technique for solving problems by breaking them into overlapping subproblems, solving each subproblem once, and storing the results (memoization or tabulation). It is often used for optimization problems like the Knapsack or shortest paths."
  },
  {
    "variants": [
      "EXPTIME (Complexity Class)",
      "EXPTIME"
    ],
    "definition": "The class of decision problems that can be solved by a deterministic algorithm in exponential time, i.e., <em>O(2<sup>p(n)</sup>)</em> for some polynomial <em>p</em>."
  },
  {
    "variants": [
      "Edge Relaxation",
      "Edge Relaxations"
    ],
    "definition": "In shortest path algorithms, the process of checking and updating the shortest known distance to a vertex by comparing it with a path that goes through an adjacent edge. It is central to algorithms like Dijkstra's and Bellman-Ford."
  },
  {
    "variants": [
      "Edit Distance",
      "Levenshtein Distance"
    ],
    "definition": "The minimum number of single-character edits (insertions, deletions, substitutions) required to transform one string into another."
  },
  {
    "variants": [
      "Edmonds-Karp Algorithm",
      "Edmonds-Karp"
    ],
    "definition": "An implementation of the Ford-Fulkerson method for computing maximum network flow that uses breadth-first search to find the shortest augmenting paths, running in <em>O(V*E^2)</em> time."
  },
  {
    "variants": [
      "Empty Set",
      "null set",
      "&empty;"
    ],
    "definition": "A set containing no elements."
  },
  {
    "variants": [
      "Enqueue",
      "Enqueues"
    ],
    "definition": "An operation that adds an element to the end of a queue, typically in <em>O(1)</em> time. It complements dequeue, which removes an element from the front."
  },
  {
    "variants": [
      "Enumeration",
      "enumerate",
      "enumerations",
      "enumerates",
      "enumerating"
    ],
    "definition": "The act of listing all possible candidates or configurations, often used in exhaustive search algorithms."
  },
  {
    "variants": [
      "Euclidean Distance",
      "Euclidean Distances"
    ],
    "definition": "The straight-line distance between two points in Euclidean space, computed as the square root of the sum of squared differences of their coordinates. It is commonly used in nearest-neighbor and clustering algorithms."
  },
  {
    "variants": [
      "Eulerian"
    ],
    "definition": "A graph with an Eulerian Cycle."
  },
  {
    "variants": [
      "Eulerian Cycle",
      "Eulerian Cycles"
    ],
    "definition": "An Eulerian cycle (or Eulerian circuit) in a graph is a closed walk that uses every edge exactly once and returns to its starting vertex. A graph has an Eulerian cycle if and only if every vertex has even degree."
  },
  {
    "variants": [
      "Eulerian Path",
      "Eulerian Paths"
    ],
    "definition": "A path in a graph that visits every edge exactly once. A connected graph has an Eulerian path if and only if 0 or 2 vertices have odd degree."
  },
  {
    "variants": [
      "Exhaustive Search"
    ],
    "definition": "A technique that systematically enumerates and tests every possible candidate solution to a problem until all valid solutions are found or a target is reached. It guarantees correctness but typically incurs exponential running time in the size of the input."
  },
  {
    "variants": [
      "Exponential",
      "exponentially"
    ],
    "definition": "Describes a function (or growth rate of something) that scales as a constant raised to the size of the input (e.g. <em>O(2<sup>n</sup>)</em> for input <em>n</em>.)."
  },
  {
    "variants": [
      "Exponential Time"
    ],
    "definition": "A running time that grows exponentially with the input size, typically denoted as <em>O(c^n)</em> for some constant <em>c > 1</em>. Algorithms with exponential time complexity are generally intractable for large inputs."
  },
  {
    "variants": [
      "Exponentiation"
    ],
    "definition": "The process of raising a base to a power, often implemented recursively or via fast exponentiation to achieve <en>O(log n)</em> time instead of <em>O(n)</em>."
  },
  {
    "variants": [
      "Fibonacci Heap",
      "Fibonacci Heaps"
    ],
    "definition": "A heap data structure consisting of a collection of trees, supporting amortized <em>O(1)</em> time for insert, decrease-key, and merge operations, and <em>O(log n)</em> for extract-min."
  },
  {
    "variants": [
      "Fibonacci Number",
      "Fibonacci Numbers",
      "Fibonacci Sequence"
    ],
    "definition": "A sequence defined by <em>F(0)=0</em>, <em>F(1)=1</em>, and <em>F(n)=F(n-1)+F(n-2)</em> for <em>n=2</em>. Fibonacci numbers grow exponentially, and computing <em>F(n)</em> is a great example of a problem that many different techniques can be applied to."
  },
  {
    "variants": [
      "Flow",
      "Flows"
    ],
    "definition": "An assignment of values to edges in a flow network satisfying capacity and conservation constraints. The value of the flow is the total flow out of the source."
  },
  {
    "variants": [
      "Flow Network",
      "Flow Networks"
    ],
    "definition": "A directed graph where each edge has a non-negative capacity, along with a designated source and sink. We are often interested in computing the maximum flow through a flow network. Algorithms like Ford-Fulkerson and Edmonds-Karp compute the maximum flow in <em>O(ExF)</em> (where <em>F</em> is the value of the maximum flow) or <em>O(VxE<sup>2</sup>)</em> time."
  },
  {
    "variants": [
      "Floyd-Warshall Algorithm",
      "Floyd-Warshall"
    ],
    "definition": "A dynamic programming algorithm that computes shortest paths between all pairs of vertices in a weighted graph (allowing negative weights but no negative cycles) in <em>O(V^3)</em> time."
  },
  {
    "variants": [
      "Ford-Fulkerson Algorithm",
      "Ford-Fulkerson"
    ],
    "definition": "A method for computing the maximum flow in a flow network by repeatedly finding augmenting paths and increasing the flow until no augmenting path exists."
  },
  {
    "variants": [
      "Forest",
      "Forests"
    ],
    "definition": "A disjoint collection of trees (not the rooted kind)."
  },
  {
    "variants": [
      "Fractional Knapsack Problem"
    ],
    "definition": "A variant of the knapsack problem where items can be divided, allowing fractional amounts, and solved optimally by a greedy algorithm in <em>O(n log n)</em> time."
  },
  {
    "variants": [
      "Garbage Collection",
      "Garbage Collections"
    ],
    "definition": "Automatic memory management technique where the system reclaims memory occupied by objects that are no longer reachable. Common methods include reference counting and tracing collectors."
  },
  {
    "variants": [
      "Graph",
      "Graphs"
    ],
    "definition": "A collection of vertices (or nodes) and edges connecting pairs of vertices, which may be directed or undirected, and may or may not be weighted. Graphs model relationships in networks, dependencies, and more."
  },
  {
    "variants": [
      "Graph Traversal",
      "Graph Traversals"
    ],
    "definition": "The process of visiting all vertices and edges in a graph systematically, using algorithms like depth-first search or breadth-first search, to explore structure or search for data."
  },
  {
    "variants": [
      "Greedy Algorithm",
      "Greedy Algorithms"
    ],
    "definition": "A paradigm where a solution is built piece by piece by always choosing the locally optimal choice at each step, hoping to find a global optimum. Examples include Prim's and Kruskal's algorithms for minimum spanning trees."
  },
  {
    "variants": [
      "Greedy-Choice Property"
    ],
    "definition": "A property that ensures a globally optimal solution can be arrived at by making a sequence of locally optimal (greedy) choices."
  },
  {
    "variants": [
      "Hamiltonian Cycle",
      "Hamiltonian Circuit"
    ],
    "definition": "A cycle in a graph that visits each vertex exactly once and returns to the starting vertex."
  },
  {
    "variants": [
      "Hamiltonian Path"
    ],
    "definition": "A path in a graph that visits each vertex exactly once."
  },
  {
    "variants": [
      "Hash Function",
      "Hash Functions"
    ],
    "definition": "A function that maps input keys of arbitrary size to fixed-size hash values, used in hash tables to index data. A good hash function distributes keys uniformly to minimize collisions."
  },
  {
    "variants": [
      "Hash Map",
      "HashMap",
      "HashMaps",
      "hash-maps",
      "hash maps"
    ],
    "definition": "A data structure that stores key-value pairs using a hash function to enable (essentially) average-case constant time lookup, insertion, and deletion."
  },
  {
    "variants": [
      "Hash Table",
      "Hash Tables"
    ],
    "definition": "A data structure that stores key-value pairs using a hash function to compute an index into an array of buckets. Common operations include insert, search, and delete in <em>O(1 + a)</em> average time, where <em>a</em> is the load factor."
  },
  {
    "variants": [
      "Heap",
      "Heaps",
      "Binary Heap",
      "Binary Heaps",
      "Min Heap",
      "Max Heap"
    ],
    "definition": "A complete binary tree satisfying the heap property (min-heap or max-heap), where each node's key is less than or equal (min-heap) or greater than or equal (max-heap) to its children's keys. Common operations, including insert, extract-min/max, and decrease-key, can be accomplished in O(log n) time."
  },
  {
    "variants": [
      "Heapify",
      "sift-down"
    ],
    "definition": "A procedure that, given a node <em>i</em> in a nearly-complete binary tree whose left and right subtrees already satisfy the heap property but where <em>i</em> may violate it, repeatedly swaps the element at <em>i</em> with its larger child (in a max-heap) or smaller child (in a min-heap) until the subtree rooted at <em>i</em> again satisfies the heap property."
  },
  {
    "variants": [
      "Heapsort"
    ],
    "definition": "A comparison-based sorting algorithm that builds a heap from the input and repeatedly extracts the maximum (or minimum) element to produce a sorted array. It runs in <em>O(n log n)</em> time with <em>O(1)</em> extra space, but is generally slower than Quicksort."
  },
  {
    "variants": [
      "Heuristic",
      "Heuristics"
    ],
    "definition": "A rule-of-thumb or strategy used to guide search algorithms toward a solution more efficiently, without guaranteeing optimality."
  },
  {
    "variants": [
      "Huffman Encoding"
    ],
    "definition": "A prefix-free encoding algorithm that assigns shorter codes to more frequent symbols based on a binary tree constructed from symbol frequencies. It achieves optimal variable-length codes for a given list of letter frequencies and runs in <em>O(n log n)</em> time."
  },
  {
    "variants": [
      "Inclusion-Exclusion Principle",
      "Inclusion-Exclusion"
    ],
    "definition": "A combinatorial method for calculating the cardinality of the union of multiple sets by summing individual set sizes, subtracting pairwise intersections, adding triple intersections, and so on."
  },
  {
    "variants": [
      "Insertion Sort"
    ],
    "definition": "A simple sorting algorithm that builds the final sorted array one element at a time by inserting each element into its correct position among the previously sorted elements. It runs in <em>O(n<sup>2</sup>)</em> time in the worst case, but <em>O(n)</em> time for nearly sorted input."
  },{
  "variants": [
    "Integer",
    "Integers",
    "Whole number"
  ],
  "definition": "An integer is a whole number (positive, negative, or zero) with no fractional or decimal part. The set of all integers is denoted &integers;."
},
  {
    "variants": [
      "Interpolation Search"
    ],
    "definition": "A search algorithm for sorted arrays that estimates the probable position of the target using a linear interpolation formula. It has an average time complexity of <em>O(log log n)</em> when data is uniformly distributed."
  },
  {
    "variants": [
      "Isomorphism",
      "Isomorphisms"
    ],
    "definition": "A bijection between the vertex sets of two graphs that preserves adjacency. Two graphs are isomorphic if one can be transformed into the other by renaming vertices."
  },
  {
    "variants": [
      "Iteration",
      "iterate",
      "iterates",
      "iterative",
      "iterating"
    ],
    "definition": "The repetition of a process or set of instructions in a loop until a condition is met."
  },
  {
    "variants": [
    "Iterative Algorithm",
    "Iterative Algorithms"
    ],
    "definition": "An iterative algorithm solves a problem by explicitly repeating a set of steps using loops (e.g., for or while loops) until a termination condition is met."
  },
  {
    "variants": [
      "Johnson's Algorithm"
    ],
    "definition": "An algorithm for finding all-pairs shortest paths in weighted, directed graphs without negative cycles by reweighting edges using a potential function and then running Dijkstra's algorithm from each vertex. It runs in <em>O(V<sup>2</sup> log V + VxE)</em> time. It works particularly well on sparse graphs."
  },
  {
    "variants": [
      "k-ary Tree",
      "k-ary Trees"
    ],
    "definition": "A rooted tree in which every node has at most <em>k</em> children, and the children are ordered. Binary Trees are 2-ary trees."
  },
  {
    "variants": [
      "Kruskal's Algorithm"
    ],
    "definition": "A greedy algorithm for finding the minimum spanning tree of a connected, undirected graph by repeatedly adding the smallest weight edge that does not form a cycle, using a disjoint set to detect cycles. It runs in <em>O(E log E)</em> time."
  },
  {
    "variants": [
      "Lazy Evaluation"
    ],
    "definition": "A strategy where computation of expressions is delayed until their values are needed, and the results are cached for subsequent use. It can improve performance by avoiding unnecessary computations."
  },
  {
    "variants": [
      "Lexicographic Order",
      "Lexicographical Order",
      "Lexicographic",
      "Lexicographical"
    ],
    "definition": "The dictionary order of sequences based on comparing elements from left to right. It is used to sort strings, tuples, or other comparable sequences."
  },
  {
    "variants": [
      "Linear Time"
    ],
    "definition": "Running time that grows linearly with the input size, denoted as <em>O(n)</em>. Examples include scanning an array or computing a sum of elements."
  },
  {
    "variants": [
      "Linked List",
      "Linked Lists"
    ],
    "definition": "A data structure consisting of nodes where each node contains data and a pointer to the next node; in a doubly linked list, nodes also have pointers to the previous node. Common operations include insertion and deletion in <em>O(1)</em> time (given a node reference) and traversal in <em>O(n)</em> time."
  },
  {
    "variants": [
      "Load Factor",
      "Load Factors"
    ],
    "definition": "For hash tables, the ratio of the number of stored elements (<em>n</em>) to the number of buckets (<em>m</em>), often denoted <em>a = n/m</em>. It affects time performance by influencing collision frequency; resizing is typically triggered when <em>a</em> exceeds a threshold (commonly <em>0.75</em>)."
  },
  {
    "variants": [
      "Logarithm",
      "Logarithms"
    ],
    "definition": "The inverse operation to exponentiation, where <em>log_b(a)</em> returns the exponent <em>x</em> such that <em>b<sup>x</sup> = a</em>. In algorithm analysis, logarithms often appear in divide-and-conquer and decrease-and-conquer algorithms."
  },
  {
    "variants": [
      "Logarithmic Time"
    ],
    "definition": "A running time of <em>O(log n)</em>. Note that the base of the logarithm does not matter since all logarithms grow at the same rate. Binary search is a classic example."
  },
  {
    "variants": [
      "Longest Common Subsequence",
      "LCS"
    ],
    "definition": "Given two sequences, the longest (not necessarily contiguous) sequence that appears in both. Can be found using dynamic programming in <em>O(n*m)</em> time."
  },
  {
    "variants": [
      "Longest Increasing Subsequence",
      "LIS"
    ],
    "definition": "Given a sequence of numbers, the longest subsequence in which each element is strictly greater than the previous. Solvable in <em>O(n log n)</em> time using dynamic programming and binary search."
  },
  {
    "variants": [
      "Lower Bound",
      "Lower Bounds"
    ],
    "definition": "A theoretical minimum limit (that is, the best possible worst-case) on the complexity of any algorithm solving a particular problem; for example, comparison-based sorting has a lower bound of <em>O(n log n)</em>."
  },
  {
    "variants": [
      "Manhatten Distance",
      "L1 distance"
    ],
    "definition": "The distance between two points measured along axes at right angles, computed as the sum of absolute differences of their coordinates. For example, in 2 dimensions, it is the shortest distance between two points when the only movements allowed are horizontal and vertical. It is used in grid-based pathfinding."
  },
  {
    "variants": [
      "Marge Sort"
    ],
    "definition": "A hilarious misspelling of Merge Sort that occurs all too often. Somebody needs to invent an actual algorithm with this name that makes sense."
  },
  {
    "variants": [
      "Master Theorem"
    ],
    "definition": "A formula that provides asymptotic bounds for divide-and-conquer recurrences of the form <em>T(n) = a T(n/b) + f(n)</em> by comparing <em>f(n)</em> with </em>n^<sup>log<sub>b</sub>(a)</sup></em>."
  },
  {
    "variants": [
      "Matching"
    ],
    "definition": "A set of edges in a graph with no shared endpoints. Matching problems often involve finding a matching with maximum size or total weight."
  },
  {
    "variants": [
      "Matrix Chain Multiplication",
      "Chain Matrix Multiplication"
    ],
    "definition": "A dynamic programming problem of determining the most efficient way to multiply a sequence of matrices by finding the optimal parenthesization to minimize the total number of scalar multiplications."
  },
  {
    "variants": [
      "Median of Medians"
    ],
    "definition": "A selection algorithm that chooses a pivot by recursively computing the median of medians of subgroups, guaranteeing linear time selection. It is used to find the <em>k</em>-th smallest element in <em>O(n)</em> worst-case time."
  },
  {
    "variants": [
      "Memoization"
    ],
    "definition": "An optimization technique where the results of expensive function calls are cached and reused when the same inputs occur again. It is commonly used in dynamic programming to avoid redundant computations."
  },
  {
    "variants": [
      "Merge Sort"
    ],
    "definition": "A divide-and-conquer sorting algorithm that recursively splits an array in half, sorts each half, and then merges the two sorted halves. It runs in <em>O(n log n)</em> time and uses <em>O(n)</em> auxiliary space."
  },
  {
    "variants": [
      "Minimum Spanning Tree",
      "Minimum Spanning Trees",
      "MST",
      "MSTs"
    ],
    "definition": "A spanning tree of a connected, undirected, weighted graph that has the minimum possible total edge weight. Algorithms to compute MSTs include Kruskal's and Prim's algorithms."
  },
  {
    "variants": [
      "Monte Carlo Algorithm",
      "Monte Carlo Algorithms"
    ],
    "definition": "A randomized algorithm that uses random sampling to compute results with a guaranteed bound on error probability and typically fast expected running time."
  },
  {
    "variants": [
      "Non-Comparison-Based",
      "Non-Comparison-Based Algorithm",
      "Non-Comparison-Based Sorting"
    ],
    "definition": "A technque that determines the proper order or elements on a list without comparing them with each other. Examples include Counting Sort, Bucket Sort, and Radix Sort."
  },
  {
    "variants": [
      "NP (Complexity Class)",
      "NP",
      "Nondeterministic Polynomial time",
      "Nondeterministic Polynomial"
    ],
    "definition": "The class of decision problems for which a proposed solution can be verified by a deterministic algorithm in polynomial time."
  },
  {
    "variants": [
      "NP-Complete",
      "NPC"
    ],
    "definition": "A class of decision problems in NP to which every problem in NP can be reduced in polynomial time. That is, problems that are in NP and NP-Hard. If any NP-complete problem has a polynomial-time algorithm, then P = NP."
  },
  {
    "variants": [
      "NP-Hard"
    ],
    "definition": "A class of problem to which every problem in NP can be reduced in polynomial time. These problems are at least as hard as the hardest problems in NP. If they are also in NP, they are NP-Complete. NP-hard problems cannot be solved in polynomial time unless P = NP."
  },
  {
    "variants": [
      "Network",
      "Networks"
    ],
    "definition": "A graph in which vertices represent entities and edges represent connections, possibly with weights or directions. Networks model systems like computer networks, transportation systems, and social networks."
  },
  {
    "variants": [
      "Optimal Substructure"
    ],
    "definition": "A property indicating that an optimal solution to a problem can be constructed from optimal solutions to its subproblems."
  },
  {
    "variants": [
      "Optimization",
      "Optimizations"
    ],
    "definition": "The process of finding the best solution from all feasible solutions, often subject to constraints. In algorithm design, it involves minimizing or maximizing an objective function."
  },
  {
    "variants": [
      "Optimization Problem",
      "Optimization Problems",
      "optimisation problem",
      "optimisation problems"
    ],
    "definition": "A problem in which the goal is to find the best solution from all feasible solutions according to an objective function, typically the minimum or maximum according to some measure."
  },
  {
    "variants": [
      "Order Statistic",
      "Order Statistics",
      "kth Order Statistic"
    ],
    "definition": "The <em>k</em>-th smallest (or largest) element in an ordered list. sSelection algorithms like Quickselect find order statistics in expected <em>O(n)</em> time."
  },
  {
    "variants": [
      "Order of Growth"
    ],
    "definition": "A characterization of how a function's value changes as its input grows, often expressed using Big-O notation. It captures the dominant term that determines resource usage for large inputs."
  },
  {
    "variants": [
      "Overlapping Subproblem",
      "overlapping subproblems"
    ],
    "definition": "A characteristic of certain recursive problems where the same subproblems are solved multiple times."
  },
  {
    "variants": [
      "P (Complexity Class)"
    ],
    "definition": "The class of decision problems that can be solved by a deterministic algorithm in polynomial time."
  },{
  "variants": [
    "Parallel Algorithm",
    "Parallel Algorithms",
    "Concurrent Algorithm",
    "Concurrent Algorithms",
    "Parallel"
  ],
  "definition": "A parallel algorithm divides a problem into subtasks that run simultaneously across multiple processors or cores. By overlapping work, it can achieve speedup over its sequential counterpart&mdash;though it must manage communication and synchronization overhead between tasks."
},
 
  {
    "variants": [
      "Path Compression"
    ],
    "definition": "A technique used in the union-find data structure to flatten the structure of the tree whenever find is called by making nodes on the find path point directly to the root. It improves amortized time per operation to near-constant."
  },
  {
    "variants": [
      "Permutation",
      "Permutations"
    ],
    "definition": "An arrangement of all elements of a set in a sequence or order. There are <em>n!</em> permutations of <em>n</em> distinct elements, and computing permutations is important in many combinatorial algorithms."
  },
  {
    "variants": [
      "Pigeonhole Principle"
    ],
    "definition": "A principle stating that if <em>n+1</em> or more items are placed into n containers, at least one container must contain more than one item. It is used in proofs and to demonstrate lower bounds."
  },
  {
    "variants": [
      "Polygon",
      "Polygons"
    ],
    "definition": "A plane figure formed by a finite sequence of straight line segments closing in a loop to form a closed chain or circuit. Polygons are used in computational geometry problems like convex hull and triangulation."
  },
  {
    "variants": [
      "Polynomial",
      "Polynomials"
    ],
    "definition": "A mathematical expression consisting of variables and coefficients combined using addition, subtraction, and multiplication, potentially raised to non-negative integer exponents. In algorithmic contexts, polynomials often represent complexity functions."
  },
  {
    "variants": [
      "Polynomial Time"
    ],
    "definition": "A running time that is upper bounded by a polynomial expression in the size of the input, denoted as <em>O(n<sup>k</sup>)</em> for some constant <em>k</em>. Problems solvable in polynomial time belong to the class P."
  },
  {
    "variants": [
      "Power Set"
    ],
    "definition": "The set of all subsets of a set, including the empty set and the set itself. The power set a set of size <em>n</em> has <em>2<sup>n</sup></em> elements."
  },
  {
    "variants": [
      "Priority Queue",
      "Priority Queues"
    ],
    "definition": "An abstract data type similar to a queue, but where each element has a priority, and elements are removed based on highest (or lowest) priority. Common implementations use binary heaps, supporting insert and extract-min/max in <em>O(log n)</em> time."
  },
  {
    "variants": [
      "Problem Reduction",
      "Problem Reductions",
      "reduction",
      "reductions"
    ],
    "definition": "The process of transforming one problem into another, often to show hardness or to leverage existing algorithms."
  },
  {
    "variants": [
      "Prune",
      "Prunes",
      "pruned",
      "pruning"
    ],
    "definition": "The act of eliminating branches in a search tree or recursive algorithm that cannot lead to a valid or better solution with the goal of improving algorithm performance."
  }, 
  {
    "variants": [
      "PSPACE (Complexity Class)",
      "PSPACE"
    ],
    "definition": "The class of decision problems that can be solved by a deterministic algorithm using a polynomial amount of memory space."
  },
  {
    "variants": [
      "Pseudocode"
    ],
    "definition": "A high-level description of an algorithm using the structural conventions of programming languages but in plain language. It abstracts away language-specific syntax to focus on algorithmic logic."
  },
  {
    "variants": [
      "Pseudopolynomial Time",
      "Pseudopolynomial"
    ],
    "definition": "A running time that is polynomial in the numeric value of the input (e.g. the target sum) rather than its encoding length, common in dynamic-programming solutions to problems like subset-sum or knapsack."
  },
  {
    "variants": [
      "Queue",
      "Queues"
    ],
    "definition": "A first-in-first-out (FIFO) data structure supporting enqueue (insert at back) and dequeue (remove from front) in <em>O(1)</em> time. They are used in breadth-first search, buffering, scheduling, and many other places."
  },
  {
    "variants": [
      "Quickselect",
      "Hoare's selection algorithm"
    ],
    "definition": "A Decrease-and-Conquer algorithm to find the <em>k</em>-th smallest element in an unordered list of <em>n</em> items by partitioning like Quicksort, with an average-case time of <em>O(n)</em>."
  },
  {
    "variants": [
      "Quicksort"
    ],
    "definition": "A divide-and-conquer sorting algorithm that partitions an array around a pivot and recursively sorts the partitions, achieving average-case <em>O(n log n)</em> time."
  },
  {
    "variants": [
      "Radix Sort"
    ],
    "definition": "A non-comparison integer sorting algorithm that processes digits of numbers from least significant to most significant (LSD) or vice versa, typically using counting sort as a subroutine. It runs in <em>O(n*k)</em> time, where <em>k</em> is the number of digits."
  },
  {
    "variants": [
      "Randomized Algorithm",
      "Randomized Algorithms"
    ],
    "definition": "An algorithm that uses randomness as part of its logic, potentially giving different outcomes on different runs. Examples include randomized Quicksort and Monte Carlo algorithms. Often used to improve performance."
  },
{
  "variants": [
    "Rational Number",
    "Rational Numbers",
    "Rational"
  ],
  "definition": "A rational number is any number expressible as a ratio <em>p/q</em>, where <em>p</em> and <em>q</em> are integers and <em>q &ne; 0</em>. The set of rational number is denoted &rationals;."
},
  {
  "variants": [
    "Real Number",
    "Real Numbers",
    "Real"
  ],
  "definition": "A real number is any value on the continuous number line, including both rational and irrational values; it can be represented by a (potentially infinite) decimal expansions. The set of real number is denoted &reals;."
},
  {
    "variants": [
      "Recurrence Relation",
      "Recurrence Relations",
      "Recurrence",
      "Recurrences"
    ],
    "definition": "An equation that defines a sequence recursively in terms of earlier terms. In algorithm analysis, recurrence relations express the running time of divide-and-conquer algorithms."
  },
  {
    "variants": [
      "Recursion",
      "recursive"
    ],
    "definition": "A programming technique where a function calls itself with smaller inputs until reaching a base case. It is used to solve divide-and-conquer and combinatorial problems."
  },
  {
  "variants": [
    "Recursion Stack",
    "Call Stack",
    "Function Call Stack",
    "Activation Record Stack"
  ],
  "definition": "The portion of the call stack used to store activation records for each active recursive invocation, including parameters, local variables, and return addresses. It grows with each recursive call and unwinds as calls return, enabling proper nesting and backtracking of recursive operations."
},
  {
    "variants": [
      "Recursion Tree"
    ],
    "definition": "A tree diagram representing the recursive calls of an algorithm, often used to solve and visualize recurrence relations."
  },
   {
    "variants": [
    "Recursive Algorithm",
    "Recursive Algorithms"
    
    ],
    "definition": "A recursive algorithm solves a problem by calling itself on one or more smaller instances of the same problem. It must include at least one base case that can be solved directly, ensuring that the recursion terminates."
  },
  {
    "variants": [
      "Red-Black Tree",
      "Red-Black Trees"
    ],
    "definition": "A self-balancing binary search tree where each node has a color (red or black) and the tree maintains specific properties to ensure balance. Operations like search, insert, and delete run in O(log n) time."
  },
  {
    "variants": [
      "Residual Graph",
      "Residual Graphs"
    ],
    "definition": "In network flow algorithms, a graph that represents remaining capacities after flow is sent along edges, used to find augmenting paths. It is central to Ford-Fulkerson and Edmonds-Karp algorithms."
  },
  {
    "variants": [
      "Run-Time Analysis"
    ],
    "definition": "The study of how the running time of an algorithm grows with input size, often expressed using asymptotic notation. It can include worst-case, average-case, and best-case analyses."
  },
  {
    "variants": [
      "SAT",
      "boolean satisfiability",
      "satisfiability"
    ],
    "definition": "The problem of determining if there exists an assignment of truth values to the variables that makes a Boolean formula true."
  },
  {
    "variants": [
      "Selection Sort"
    ],
    "definition": "A simple sorting algorithm that repeatedly selects the maximum element from the unsorted portion and swaps it with the last unsorted element. Alternatively, it can do so with the minimum/first unsorted element. It has <em>O(n<sup>2</sup>)</em> time complexity and <em>O(1)</em> space usage."
  },
  {
  "variants": [
    "Sequential Algorithm",
    "Sequential Algorithms",
    "Serial Algorithm",
    "Serial Algorithms"
  ],
  "definition": "A sequential algorithm executes its steps one after another on a single processor, with each operation completing before the next begins. Because it performs only one action at a time, its overall running time is simply the sum of its individual step times."
},
  {
  "variants": [
    "Sequential Search",
    "Linear Search"
  ],
  "definition": "Sequential search, also called linear search, examines each element of a list in order until it finds the target value or reaches the end of the list. Its worst-case time complexity is <em>O(n)</em>, its best-case is <em>O(1)</em>."
},
  {
    "variants": [
      "Shell Sort"
    ],
    "definition": "A generalization of insertion sort that initially sorts elements far apart using a gap sequence, reducing the gap until final insertion sort, improving average performance."
  },
  {
    "variants": [
      "Shortest Path",
      "Shortest Paths"
    ],
    "definition": "The problem of finding a path between two vertices in a graph such that the sum of edge weights (for weighted graph) or number of intermediate nodes (for unweighted graphs) is minimized . Algorithms include Breadth-First Search (for unweighted graphs), Dijkstra's (for non-negative weights) and Bellman-Ford (for graphs with negative weights)."
  },
  {
    "variants": [
      "Sink Vertex"
    ],
    "definition": "In a directed graph, a vertex with no outgoing edges (outdegree zero). In flow networks, the sink is the designated target node where flow is collected."
  },
  {
    "variants": [
      "Skip List"
    ],
    "definition": "A probabilistic data structure composed of multiple levels of linked lists that provides average-case <em>O(log n)</em> time for search, insertion, and deletion."
  },
  {
    "variants": [
      "Sort",
      "Sorting"
    ],
    "definition": "The process of arranging elements in a list into a specified order, usually ascending or descending. Common sorting algorithms include Quicksort, Merge Sort, Heapsort, and Insertion Sort."
  },
  {
    "variants": [
      "Sorting Algorithm",
      "Sorting Algorithms"
    ],
    "definition": "An algorithm that reordered elements in a list so that they are in order (ascending or descending), usually based on the natural order of the data type."
  },
  {
    "variants": [
      "Source Vertex"
    ],
    "definition": "In a directed graph, a vertex with no incoming edges (indegree zero). In flow networks, the source is the designated origin node where flow is generated."
  },
  {
    "variants": [
      "Space Complexity"
    ],
    "definition": "The amount of memory an algorithm uses relative to the size of its input, often expressed using asymptotic notation. It includes both auxiliary and input storage."
  },
  {
    "variants": [
      "Spanning Tree",
      "Spanning Trees"
    ],
    "definition": "A subgraph of a connected, undirected graph that includes all vertices and is a tree (acyclic and connected). The minimum spanning tree is the spanning tree with the smallest total edge weight."
  },
  {
    "variants": [
      "Splay Tree"
    ],
    "definition": "A self-adjusting binary search tree that moves accessed elements to the root using rotations (splaying), ensuring amortized <em>O(log n)</em> time for operations."
  },
  {
    "variants": [
      "Stable Sort",
      "Stable Sorts"
    ],
    "definition": "A sorting algorithm that maintains the relative order of records with equal keys. Examples include Merge Sort and Insertion Sort, while Selection Sort and Heapsort are not stable by default. Particularly important when multiple passes of sorting are necessary (e.g. Radix Sort, or when sorting according to multiple fields)"
  },
  {
    "variants": [
      "Stack",
      "Stacks"
    ],
    "definition": "A last-in-first-out (LIFO) data structure supporting push (add to top) and pop (remove from top) in <em>O(1)</em> time. It is used in recursion, depth-first search, expression evaluation, and many other places."
  },
  {
    "variants": [
      "Strongly Connected Component",
      "Strongly Connected Components",
      "SCC"
    ],
    "definition": "A maximal set of vertices in a directed graph such that every vertex is reachable from every other vertex in the set."
  },
  {
    "variants": [
      "Subset",
      "Subsets"
    ],
    "definition": "A set containing zero or more elements from another set. Generating subsets is a common combinatorial task."
  },
  {
    "variants": [
      "Subset Sum Problem"
    ],
    "definition": "A decision problem of determining whether a subset of given integers sums exactly to a specified target value. Solvable in pseudopolynomial time by dynamic programming."
  },
  {
    "variants": [
      "Tail Recursion"
    ],
    "definition": "A special case of recursion where the recursive call is the last operation in the function, allowing optimizations that convert recursion into iteration to save stack space. Languages or compilers that support tail-call optimization can execute tail-recursive functions in constant space."
  },
  {
    "variants": [
      "TimSort"
    ],
    "definition": "A hybrid stable sorting algorithm derived from Merge Sort and Insertion Sort, optimized for real-world data by exploiting runs and achieving <em>O(n log n)</em> worst-case time."
  },
  {
    "variants": [
      "Time Complexity"
    ],
    "definition": "A measure of the amount of time an algorithm takes as a function of input size, often expressed using asymptotic notation. It helps compare the efficiency of algorithms."
  },
  {
    "variants": [
      "Topological Sort"
    ],
    "definition": "A linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge <em>(u,v)</em>, vertex <em>u</em> comes before <em>v</em> in the ordering. It can be computed in <em>O(V + E)</em> time using DFS or Kahn's algorithm."
  },
  {
    "variants": [
      "Traveling Salesman Problem",
      "Traveling Salesman",
      "TSP"
    ],
    "definition": "Given a finite set of 'cities' and a distance (or cost) between every ordered pair of cities, the goal is to find a Hamiltonian cycle of minimum total length. TSP is NP-hard, so currently there are no known efficient algorithms that can solve it in general."
  },
  {
    "variants": [
      "Tree",
      "Trees"
    ],
    "definition": "Ambiguous. Could mean:<ul><li><strong>unrooted tree:</strong> A connected, acyclic, undirected graph.</li><li><strong>rooted tree:</strong> A tree in which one node is distinguished as the root, and every other node has exactly one parent, establishing a hierarchical parent-child structure. All nodes are reachable from the root by a unique path. The most common subtypes are Binary Trees and k-ary Trees.</li></ul>"
  },
  {
    "variants": [
      "Undirected Graph",
      "Undirected Graphs"
    ],
    "definition": "A graph in which the edges are unordered pairs of vertices, each representing a bidirectional connection between its two endpoints."
  },
  {
    "variants": [
      "Union by Rank"
    ],
    "definition": "A heuristic in the union-find data structure that always attaches the shorter tree under the taller one to keep trees shallow, improving the amortized performance of union and find operations."
  },
  {
    "variants": [
      "Union-Find"
    ],
    "definition": "A data structure that keeps track of disjoint sets and supports union (merge two sets) and find (determine set representative) operations, often implemented with union by rank and path compression for nearly constant-time performance."
  },
  {
    "variants": [
      "Upper Bound",
      "Upper Bounds"
    ],
    "definition": "A function that serves as an asymptotic upper limit on the growth of another function, often expressed using Big-O notation. If function <em>g(n)</em> is an upper bound on <em>f(n)</em>, then <em>f</em> grows no faster the <em>g</em> as <em>n</em> gets larger."
  },
  {
    "variants": [
      "Vertex Cover"
    ],
    "definition": "A set of vertices in a graph such that every edge has at least one endpoint in the set. Finding the minimum vertex cover is NP-hard."
  },
  {
    "variants": [
      "Weighted Edge",
      "Weighted Edges"
    ],
    "definition": "An edge in a graph that has an associated numerical value (weight), representing cost, distance, or capacity. Algorithms like Dijkstra's and Kruskal's take edge weights into account."
  },
  {
    "variants": [
      "Weighted Graph",
      "Weighted Graph"
    ],
    "definition": "A graph where each edge has a number (the weight) associated with it, often used to represent cost, distance, or capacity."
  },
  {
    "variants": [
      "Worst-Case Analysis"
    ],
    "definition": "An evaluation of an algorithm's performance under the worst possible input of a given size, often giving an upper bound on running time or space usage. It ensures algorithm reliability by considering the most expensive scenario."
  }
]