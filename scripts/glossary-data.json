[
  {
    "variants": [
      "Adjacency List",
      "Adjacency Lists"
    ],
    "definition": "A graph representation where each vertex maintains a list of its adjacent vertices. Basic operations include adding and removing edges, and traversing neighbors in time proportional to the degree of the vertex."
  },
  {
    "variants": [
      "Adjacency Matrix",
      "Adjacency Matrixs"
    ],
    "definition": "A 2D matrix representation of a graph where entry (i,j) indicates the presence or weight of an edge between vertices i and j. Operations like checking for an edge are constant time, while iterating over neighbors takes O(n) time per vertex."
  },
  {
    "variants": [
      "Algorithm",
      "Algorithms"
    ],
    "definition": "A step-by-step procedure for solving a computational problem or performing a task. It specifies a finite sequence of well-defined instructions that transform input into output."
  },
  {
    "variants": [
      "Amortized Analysis"
    ],
    "definition": "A method of analyzing the average running time of an operation over a worst-case sequence of operations. It ensures that the average cost per operation is small even if some operations are expensive."
  },
  {
    "variants": [
      "Array",
      "Arrays"
    ],
    "definition": "A collection of elements stored in contiguous memory, allowing constant-time access by index. Common operations include indexing, traversal, insertion, and deletion (insertion/deletion may require shifting elements)."
  },
  {
    "variants": [
      "Array Partition",
      "Array Partitions"
    ],
    "definition": "The process of rearranging elements in an array so that elements less than a pivot come before it and elements greater come after. It is a key step in Quick Sort and Quickselect."
  },
  {
    "variants": [
      "Asymptotic Notation",
      "Asymptotic Notations"
    ],
    "definition": "Mathematical notation (e.g., Big O, Theta, Omega) used to describe the limiting behavior of a function as its input grows. It abstracts constant factors and lower-order terms to focus on growth rates."
  },
  {
    "variants": [
      "Backtracking",
      "Backtrackings"
    ],
    "definition": "A paradigm for solving combinatorial problems by building candidates incrementally and abandoning a candidate (backtracking) as soon as it is determined to be invalid. Commonly used for problems like N-Queens and Sudoku."
  },
  {
    "variants": [
      "Base Case",
      "Base Cases"
    ],
    "definition": "The simplest instance of a recursive problem that can be solved directly without further recursion. It prevents infinite recursion by providing a stopping condition."
  },
  {
    "variants": [
      "Binary Heap",
      "Binary Heaps"
    ],
    "definition": "A complete binary tree satisfying the heap property (min-heap or max-heap), where each node's key is less than or equal (min-heap) or greater than or equal (max-heap) to its children's keys. Common operations include insert, extract-min/max, and decrease-key in O(log n) time."
  },
  {
    "variants": [
      "Binary Search",
      "Binary Searchs"
    ],
    "definition": "An algorithm for finding a target value in a sorted array by repeatedly dividing the search interval in half. It runs in O(log n) time by comparing the target to the middle element and discarding half of the search space."
  },
  {
    "variants": [
      "Binary Search Tree",
      "Binary Search Trees"
    ],
    "definition": "A binary tree in which each node has a key, and all keys in the left subtree are less than the node's key, while those in the right subtree are greater. Operations like search, insert, and delete take O(h) time, where h is the tree height (O(log n) on average for balanced trees)."
  },
  {
    "variants": [
      "Branch-and-Bound",
      "Branch-and-Bounds"
    ],
    "definition": "A search algorithm that systematically explores branches of a solution space, using bounds to prune subproblems that cannot yield better solutions than the current best. Often used for optimization problems like integer programming."
  },
  {
    "variants": [
      "Breadth-First Search",
      "Breadth-First Searchs"
    ],
    "definition": "A graph traversal algorithm that explores vertices in order of increasing distance from the source, using a queue. It visits all neighbors of a vertex before moving to the next level, running in O(V + E) time for adjacency list representation."
  },
  {
    "variants": [
      "Brute Force",
      "Brute Forces"
    ],
    "definition": "A straightforward method that tries every possible option or configuration until it finds a solution or exhausts the search space. While simple to implement, it often has very high time complexity and is used mainly when no better algorithm is known."
  },
  {
    "variants": [
      "Bucket Sort",
      "Bucket Sorts"
    ],
    "definition": "A sorting algorithm that distributes elements into a number of buckets, sorts each bucket (often with another sort), and then concatenates the buckets. It achieves O(n + k) time when input is uniformly distributed over a range and k is the number of buckets."
  },
  {
    "variants": [
      "Cartesian Coordinates",
      "Cartesian Coordinate System"
    ],
    "definition": "A coordinate system that specifies each point uniquely by a pair (or triplet) of numerical coordinates based on orthogonal axes."
  },
  {
    "variants": [
      "Chain Hashing",
      "Chain Hashings"
    ],
    "definition": "A collision-resolution technique for hash tables where each bucket contains a linked list of elements that hash to the same index. Common operations include insert, search, and delete in O(1 + a) average time, where a is the load factor."
  },
  {
    "variants": [
      "Coefficient",
      "Coefficients"
    ],
    "definition": "A constant multiplier of a variable or term, often appearing in polynomial expressions. In algorithm analysis, coefficients are the constant factors hidden in asymptotic notation."
  },
  {
    "variants": [
      "Complexity Analysis"
    ],
    "definition": "The process of determining the time and space requirements of an algorithm as functions of input size. It involves evaluating best-case, average-case, and worst-case performance."
  },
  {
    "variants": [
      "Computational Complexity",
      "Computational Complexitys"
    ],
    "definition": "A field of study concerned with classifying computational problems based on their inherent difficulty and the resources required to solve them. It defines complexity classes such as P, NP, NP-hard, and NP-complete."
  },
  {
    "variants": [
      "Constant Time",
      "Constant Times"
    ],
    "definition": "An operation that takes the same amount of time to complete regardless of the input size, denoted as O(1). Examples include accessing an array element by index and basic arithmetic operations."
  },
  {
    "variants": [
      "Convex Hull",
      "Convex Hulls"
    ],
    "definition": "The smallest convex polygon that contains all points in a given set. Common algorithms for computing the convex hull include Graham's scan and the Quickhull algorithm, running in O(n log n) time."
  },
  {
    "variants": [
      "Counting Sort",
      "Counting Sorts"
    ],
    "definition": "A non-comparative sorting algorithm that counts the occurrences of each value in the input and computes positions based on prefix sums. It runs in O(n + k) time, where k is the range of input values."
  },
  {
    "variants": [
      "DAG",
      "Directed Acyclic Graph"
    ],
    "definition": "A directed graph with no directed cycles, meaning it is impossible to start at a node and follow a consistently-directed sequence of edges that eventually loops back to the starting node."
  },
  {
    "variants": [
      "Data Structure",
      "Data Structures"
    ],
    "definition": "A way to store and organize data to enable efficient access and modification. Examples include arrays, linked lists, trees, graphs, stacks, queues, and hash tables."
  },
  {
    "variants": [
      "Degree Sequence",
      "Degree Sequences"
    ],
    "definition": "A sequence of vertex degrees in a graph, often used to characterize or test properties of the graph. For a simple graph, it is a non-increasing sequence of integers."
  },
  {
    "variants": [
      "Depth-First Search",
      "Depth-First Searchs"
    ],
    "definition": "A graph traversal algorithm that explores as far as possible along each branch before backtracking, using a stack (often via recursion). It runs in O(V + E) time and is used for tasks like topological sorting and cycle detection."
  },
  {
    "variants": [
      "Dequeue",
      "Dequeues"
    ],
    "definition": "A double-ended queue allowing insertion and deletion at both the front and back in O(1) time. Common operations include addFirst, addLast, removeFirst, and removeLast."
  },
  {
    "variants": [
      "Digraph",
      "Digraphs"
    ],
    "definition": "Short for directed graph, a set of vertices connected by directed edges where each edge has a direction. It can be represented by adjacency lists or adjacency matrices."
  },
  {
    "variants": [
      "Disjoint Set",
      "Disjoint Sets"
    ],
    "definition": "Also known as Union-Find, a data structure that keeps track of a partition of elements into disjoint subsets, supporting find and union operations in near-constant (amortized a(n)) time with path compression and union by rank."
  },
  {
    "variants": [
      "Divide-and-Conquer",
      "Divide-and-Conquers"
    ],
    "definition": "A paradigm in which a problem is recursively divided into two or more subproblems of the same (or related) type, each subproblem is solved independently, and finally the solutions are combined."
  },
  {
    "variants": [
      "Dynamic Programming",
      "Dynamic Programmings"
    ],
    "definition": "A technique for solving problems by breaking them into overlapping subproblems, solving each subproblem once, and storing the results (memoization or tabulation). It is often used for optimization problems like the Knapsack or shortest paths."
  },
  {
    "variants": [
      "Edge Relaxation",
      "Edge Relaxations"
    ],
    "definition": "In shortest path algorithms, the process of checking and updating the shortest known distance to a vertex by comparing it with a path that goes through an adjacent edge. It is central to algorithms like Dijkstra's and Bellman-Ford."
  },
  {
    "variants": [
      "Empty Set",
      "null set",
      "\u2205"
    ],
    "definition": "A set containing no elements."
  },
  {
    "variants": [
      "Enqueue",
      "Enqueues"
    ],
    "definition": "An operation that adds an element to the end of a queue in O(1) time. It complements dequeue, which removes an element from the front."
  },
  {
    "variants": [
      "Enumeration",
      "enumerate",
      "enumerations",
      "enumerates",
      "enumerating"
    ],
    "definition": "The act of listing all possible candidates or configurations, often used in exhaustive search algorithms."
  },
  {
    "variants": [
      "Euclidean Distance",
      "Euclidean Distances"
    ],
    "definition": "The straight-line distance between two points in Euclidean space, computed as the square root of the sum of squared differences of their coordinates. It is commonly used in nearest-neighbor and clustering algorithms."
  },
  {
    "variants": [
      "Eulerian Path",
      "Eulerian Paths"
    ],
    "definition": "A path in a graph that visits every edge exactly once. A connected graph has an Eulerian path if and only if 0 or 2 vertices have odd degree."
  },
  {
    "variants": [
      "Exhaustive Search",
      "Exhaustive Searchs"
    ],
    "definition": "A technique that systematically enumerates and tests every possible candidate solution to a problem until all valid solutions are found or a target is reached. It guarantees correctness but typically incurs exponential running time in the size of the input."
  },
  {
    "variants": [
      "Exponential",
      "exponentially"
    ],
    "definition": "Describes growth or time complexity that scales as a constant raised to the size of the input."
  },
  {
    "variants": [
      "Exponential Time",
      "Exponential Times"
    ],
    "definition": "An algorithm whose running time grows exponentially with the input size, typically denoted as O(c^n) for some c > 1. These algorithms are generally intractable for large inputs."
  },
  {
    "variants": [
      "Exponentiation",
      "Exponentiations"
    ],
    "definition": "The process of raising a base to a power, often implemented recursively or via fast exponentiation (divide-and-conquer) to achieve O(log n) time instead of O(n)."
  },
  {
    "variants": [
      "Fibonacci Number",
      "Fibonacci Numbers"
    ],
    "definition": "A sequence defined by F(0)=0, F(1)=1, and F(n)=F(n-1)+F(n-2) for n=2. Fibonacci numbers grow exponentially and have applications in algorithm analysis."
  },
  {
    "variants": [
      "Fibonacci Sequence",
      "Fibonacci numbers",
      "fib sequence"
    ],
    "definition": "A sequence in which each number is the sum of the two preceding ones, usually starting with 0 and 1."
  },
  {
    "variants": [
      "Flow",
      "Flows"
    ],
    "definition": "An assignment of values to edges in a flow network satisfying capacity and conservation constraints. The value of the flow is the total flow out of the source."
  },
  {
    "variants": [
      "Flow Network",
      "Flow Networks"
    ],
    "definition": "A directed graph where each edge has a non-negative capacity, along with a designated source and sink. Algorithms like Ford-Fulkerson and Edmonds-Karp compute the maximum flow in O(Exf) or O(VxE<sup>2</sup>) time."
  },
  {
    "variants": [
      "Forest",
      "Forests"
    ],
    "definition": "A disjoint collection of trees. In graph theory, a forest can be obtained by removing edges from a tree or as a subgraph of an acyclic graph."
  },
  {
    "variants": [
      "Garbage Collection",
      "Garbage Collections"
    ],
    "definition": "Automatic memory management technique where the system reclaims memory occupied by objects that are no longer reachable. Common methods include reference counting and tracing collectors."
  },
  {
    "variants": [
      "Graph",
      "Graphs"
    ],
    "definition": "A collection of vertices (or nodes) and edges connecting pairs of vertices, which may be directed or undirected. Graphs model relationships in networks, dependencies, and more."
  },
  {
    "variants": [
      "Graph Traversal",
      "Graph Traversals"
    ],
    "definition": "The process of visiting all vertices and edges in a graph systematically, using algorithms like depth-first search or breadth-first search, to explore structure or search for data."
  },
  {
    "variants": [
      "Greedy Algorithm",
      "Greedy Algorithms"
    ],
    "definition": "A paradigm where a solution is built piece by piece by always choosing the locally optimal choice at each step, hoping to find a global optimum. Examples include Prim's and Kruskal's algorithms for minimum spanning trees."
  },
  {
    "variants": [
      "Greedy-Choice Property"
    ],
    "definition": "A property that ensures a globally optimal solution can be arrived at by making a sequence of locally optimal (greedy) choices."
  },
  {
    "variants": [
      "Hash Function",
      "Hash Functions"
    ],
    "definition": "A function that maps input keys of arbitrary size to fixed-size hash values, used in hash tables to index data. A good hash function distributes keys uniformly to minimize collisions."
  },
  {
    "variants": [
      "Hash Map",
      "hash-maps",
      "hash maps"
    ],
    "definition": "A data structure that stores key-value pairs using a hash function to enable average-case constant time lookup, insertion, and deletion."
  },
  {
    "variants": [
      "Hash Table",
      "Hash Tables"
    ],
    "definition": "A data structure that stores key-value pairs using a hash function to compute an index into an array of buckets. Common operations include insert, search, and delete in O(1 + a) average time, where a is the load factor."
  },
  {
    "variants": [
      "Heapify",
      "Heapifys"
    ],
    "definition": "The process of converting an array into a heap, typically by calling sift-down on each non-leaf node starting from the last non-leaf. It runs in O(n) time."
  },
  {
    "variants": [
      "Heapsort",
      "Heapsorts"
    ],
    "definition": "A comparison-based sorting algorithm that builds a heap from the input and repeatedly extracts the maximum (or minimum) element to produce a sorted array. It runs in O(n log n) time with O(1) extra space."
  },
  {
    "variants": [
      "Huffman Encoding",
      "Huffman Encodings"
    ],
    "definition": "A prefix-free encoding algorithm that assigns shorter codes to more frequent symbols based on a binary tree constructed from symbol frequencies. It achieves optimal variable-length codes and runs in O(n log n) time."
  },
  {
    "variants": [
      "Insertion Sort",
      "Insertion Sorts"
    ],
    "definition": "A simple sorting algorithm that builds the final sorted array one element at a time by inserting each element into its correct position among the previously sorted elements. It runs in O(n<sup>2</sup>) time in the worst case, but O(n) time for nearly sorted input."
  },
  {
    "variants": [
      "Interpolation Search",
      "Interpolation Searchs"
    ],
    "definition": "A search algorithm for sorted arrays that estimates the probable position of the target using a linear interpolation formula. It has an average time complexity of O(log log n) when data is uniformly distributed."
  },
  {
    "variants": [
      "Isomorphism",
      "Isomorphisms"
    ],
    "definition": "A bijection between the vertex sets of two graphs that preserves adjacency. Two graphs are isomorphic if one can be transformed into the other by renaming vertices."
  },
  {
    "variants": [
      "Iteration",
      "iterative",
      "iterates",
      "iterating"
    ],
    "definition": "The repetition of a process or set of instructions in a loop until a condition is met."
  },
  {
    "variants": [
      "Johnson's Algorithm",
      "Johnson's Algorithms"
    ],
    "definition": "An algorithm for finding all-pairs shortest paths in sparse, weighted, directed graphs without negative cycles by reweighting edges using a potential function and then running Dijkstra's algorithm from each vertex. It runs in O(V<sup>2</sup> log V + VxE) time."
  },
  {
    "variants": [
      "Kruskal's Algorithm",
      "Kruskal's Algorithms"
    ],
    "definition": "A greedy algorithm for finding the minimum spanning tree of a connected, undirected graph by repeatedly adding the smallest weight edge that does not form a cycle, using a disjoint set to detect cycles. It runs in O(E log E) time."
  },
  {
    "variants": [
      "Lazy Evaluation",
      "Lazy Evaluations"
    ],
    "definition": "A strategy where computation of expressions is delayed until their values are needed, and the results are cached for subsequent use. It can improve performance by avoiding unnecessary computations."
  },
  {
    "variants": [
      "Lexicographic Order",
      "Lexicographic Orders"
    ],
    "definition": "The dictionary order of sequences based on comparing elements from left to right. It is used to sort strings, tuples, or other comparable sequences."
  },
  {
    "variants": [
      "Linear Time",
      "Linear Times"
    ],
    "definition": "An algorithm whose running time grows linearly with the input size, denoted as O(n). Examples include scanning an array or computing a sum of elements."
  },
  {
    "variants": [
      "Linked List",
      "Linked Lists"
    ],
    "definition": "A data structure consisting of nodes where each node contains data and a pointer to the next node; in a doubly linked list, nodes also have pointers to the previous node. Common operations include insertion and deletion in O(1) time (given a node reference) and traversal in O(n) time."
  },
  {
    "variants": [
      "Load Factor",
      "Load Factors"
    ],
    "definition": "For hash tables, the ratio of the number of stored elements to the number of buckets, often denoted a = n/m. It affects time complexity by influencing collision frequency; resizing is typically triggered when a exceeds a threshold."
  },
  {
    "variants": [
      "Logarithm",
      "Logarithms"
    ],
    "definition": "The inverse operation to exponentiation, where log_b(a) returns the exponent x such that b^x = a. In algorithm analysis, logarithms measure growth rates, especially in divide-and-conquer algorithms."
  },
  {
    "variants": [
      "Logarithmic Time",
      "Logarithmic Times"
    ],
    "definition": "An algorithm whose running time scales as O(log n), where each step reduces the problem size multiplicatively. Binary search is a classic example."
  },
  {
    "variants": [
      "Lower Bound",
      "Lower Bounds"
    ],
    "definition": "A theoretical minimum limit on the complexity of any algorithm solving a particular problem; for example, comparison-based sorting has a lower bound of O(n log n)."
  },
  {
    "variants": [
      "Manhatten Distance",
      "Manhatten Distances"
    ],
    "definition": "The distance between two points measured along axes at right angles, computed as the sum of absolute differences of their coordinates. It is also called L1 distance and is used in grid-based pathfinding."
  },
  {
    "variants": [
      "Median of Medians"
    ],
    "definition": "A selection algorithm that chooses a pivot by recursively computing the median of medians of subgroups, guaranteeing linear time selection. It is used to find the k-th smallest element in O(n) worst-case time."
  },
  {
    "variants": [
      "Memoization",
      "Memoizations"
    ],
    "definition": "An optimization technique where the results of expensive function calls are cached and reused when the same inputs occur again. It is commonly used in dynamic programming to avoid redundant computations."
  },
  {
    "variants": [
      "Merge Sort",
      "Merge Sorts"
    ],
    "definition": "A divide-and-conquer sorting algorithm that recursively splits an array in half, sorts each half, and then merges the two sorted halves. It runs in O(n log n) time and uses O(n) auxiliary space."
  },
  {
    "variants": [
      "Minimum Spanning Tree",
      "Minimum Spanning Trees"
    ],
    "definition": "A spanning tree of a connected, undirected graph that has the minimum possible total edge weight. Algorithms to compute MSTs include Kruskal's and Prim's algorithms."
  },
  {
    "variants": [
      "Monte Carlo Algorithm",
      "Monte Carlo Algorithms"
    ],
    "definition": "A randomized algorithm that has a bounded running time and may produce incorrect results with a small probability. Examples include probabilistic primality tests like Miller-Rabin."
  },
  {
    "variants": [
      "Network",
      "Networks"
    ],
    "definition": "A graph in which vertices represent entities and edges represent connections, possibly with weights or directions. Networks model systems like computer networks, transportation systems, and social networks."
  },
  {
    "variants": [
      "NP-Complete",
      "NP-Completes"
    ],
    "definition": "A class of decision problems in NP to which every problem in NP can be reduced in polynomial time and that themselves are in NP. If any NP-complete problem has a polynomial-time algorithm, then P = NP."
  },
  {
    "variants": [
      "NP-Hard",
      "NP-Hards"
    ],
    "definition": "A class of problems at least as hard as the hardest problems in NP; an NP-hard problem may not be in NP (e.g., optimization versions). NP-hard problems cannot be solved in polynomial time unless P = NP."
  },
  {
    "variants": [
      "Optimal Substructure"
    ],
    "definition": "A property indicating that an optimal solution to a problem can be constructed from optimal solutions to its subproblems."
  },
  {
    "variants": [
      "Optimization",
      "Optimizations"
    ],
    "definition": "The process of finding the best solution from all feasible solutions, often subject to constraints. In algorithm design, it involves minimizing or maximizing an objective function."
  },
  {
    "variants": [
      "Optimization Problem",
      "optimisation problem"
    ],
    "definition": "A problem of finding the best solution from all feasible solutions according to some objective function."
  },
  {
    "variants": [
      "Order of Growth",
      "Order of Growths"
    ],
    "definition": "A characterization of how a function's value changes as its input grows, often expressed using Big O notation. It captures the dominant term that determines resource usage for large inputs."
  },
  {
    "variants": [
      "Order Statistic",
      "Order Statistics"
    ],
    "definition": "The k-th smallest (or largest) element in an ordered list; selection algorithms like Quickselect find order statistics in expected O(n) time."
  },
  {
    "variants": [
      "Overlapping Subproblem",
      "overlapping subproblems"
    ],
    "definition": "A characteristic of certain recursive problems where the same subproblems are solved multiple times."
  },
  {
    "variants": [
      "Path Compression",
      "Path Compressions"
    ],
    "definition": "A technique used in the union-find data structure to flatten the structure of the tree whenever find is called by making nodes on the find path point directly to the root. It improves amortized time per operation to near-constant."
  },
  {
    "variants": [
      "Permutation",
      "Permutations"
    ],
    "definition": "An arrangement of all elements of a set in a sequence or order. There are n! permutations of n distinct elements, and computing permutations is used in combinatorial algorithms."
  },
  {
    "variants": [
      "Pigeonhole Principle",
      "Pigeonhole Principles"
    ],
    "definition": "A principle stating that if n+1 or more items are placed into n containers, at least one container must contain more than one item. It is used in proofs and to demonstrate lower bounds."
  },
  {
    "variants": [
      "Polygon",
      "Polygons"
    ],
    "definition": "A plane figure formed by a finite sequence of straight line segments closing in a loop to form a closed chain or circuit. Polygons are used in computational geometry problems like convex hull and triangulation."
  },
  {
    "variants": [
      "Polynomial",
      "Polynomials"
    ],
    "definition": "A mathematical expression consisting of variables and coefficients combined using addition, subtraction, and multiplication, potentially raised to non-negative integer exponents. In algorithmic contexts, polynomials often represent complexity functions."
  },
  {
    "variants": [
      "Polynomial Time",
      "Polynomial Times"
    ],
    "definition": "An algorithm whose running time is upper bounded by a polynomial expression in the size of the input, denoted as O(n^k) for some constant k. Problems solvable in polynomial time belong to the class P."
  },
  {
    "variants": [
      "Priority Queue",
      "Priority Queues"
    ],
    "definition": "An abstract data type similar to a queue where each element has a priority, and elements are removed based on highest (or lowest) priority. Common implementations use binary heaps, supporting insert and extract-min/max in O(log n) time."
  },
  {
    "variants": [
      "Problem Reduction",
      "reduction"
    ],
    "definition": "The process of transforming one problem into another, often to show hardness or to leverage existing algorithms."
  },
  {
    "variants": [
      "Prune",
      "pruned",
      "pruning"
    ],
    "definition": "The act of eliminating branches in a search tree or recursive algorithm that cannot lead to a valid or better solution."
  },
  {
    "variants": [
      "Pseudocode",
      "Pseudocodes"
    ],
    "definition": "A high-level description of an algorithm using the structural conventions of programming languages but in plain language. It abstracts away language-specific syntax to focus on algorithmic logic."
  },
  {
    "variants": [
      "Queue",
      "Queues"
    ],
    "definition": "A first-in-first-out (FIFO) data structure supporting enqueue (insert at back) and dequeue (remove from front) in O(1) time. It is used in breadth-first search, buffering, and scheduling."
  },
  {
    "variants": [
      "Radix Sort",
      "Radix Sorts"
    ],
    "definition": "A non-comparative integer sorting algorithm that processes digits of numbers from least significant to most significant (LSD) or vice versa, using counting sort as a subroutine. It runs in O(nxk) time, where k is the number of digits."
  },
  {
    "variants": [
      "Randomized Algorithm",
      "Randomized Algorithms"
    ],
    "definition": "An algorithm that uses randomness as part of its logic, potentially giving different outcomes on different runs. Examples include randomized quicksort and Monte Carlo algorithms."
  },
  {
    "variants": [
      "Recurrence Relation",
      "Recurrence Relations"
    ],
    "definition": "An equation that defines a sequence recursively in terms of earlier terms. In algorithm analysis, recurrence relations express the running time of divide-and-conquer algorithms."
  },
  {
    "variants": [
      "Recursion",
      "Recursions"
    ],
    "definition": "A programming technique where a function calls itself with smaller inputs until reaching a base case. It is used to solve divide-and-conquer and combinatorial problems."
  },
  {
    "variants": [
      "Recursion",
      "recursive"
    ],
    "definition": "A process or function that calls itself directly or indirectly, typically with smaller inputs each time."
  },
  {
    "variants": [
      "Recursion Tree"
    ],
    "definition": "A tree diagram representing the recursive calls of an algorithm, often used to solve and visualize recurrence relations."
  },
  {
    "variants": [
      "Red-Black Tree",
      "Red-Black Trees"
    ],
    "definition": "A self-balancing binary search tree where each node has a color (red or black) and the tree maintains specific properties to ensure balance. Operations like search, insert, and delete run in O(log n) time."
  },
  {
    "variants": [
      "Reduction",
      "Reductions"
    ],
    "definition": "The process of transforming one problem into another in a way that a solution to the second problem can be converted back to a solution to the first. Reductions are used to prove hardness and complexity class membership."
  },
  {
    "variants": [
      "Residual Graph",
      "Residual Graphs"
    ],
    "definition": "In network flow algorithms, a graph that represents remaining capacities after flow is sent along edges, used to find augmenting paths. It is central to Ford-Fulkerson and Edmonds-Karp algorithms."
  },
  {
    "variants": [
      "Run-Time Analysis"
    ],
    "definition": "The study of how the running time of an algorithm grows with input size, often expressed using asymptotic notation. It can include worst-case, average-case, and best-case analyses."
  },
  {
    "variants": [
      "SAT",
      "boolean satisfiability",
      "satisfiability"
    ],
    "definition": "The problem of determining if there exists an assignment of truth values to variables that makes a Boolean formula true."
  },
  {
    "variants": [
      "Segment Tree",
      "Segment Trees"
    ],
    "definition": "A binary tree data structure that stores intervals or segments, allowing efficient range queries and updates in O(log n) time. It supports operations like range sum or minimum."
  },
  {
    "variants": [
      "Selection Sort",
      "Selection Sorts"
    ],
    "definition": "A simple sorting algorithm that repeatedly selects the minimum element from the unsorted portion and swaps it with the first unsorted element. It has O(n<sup>2</sup>) time complexity and O(1) space usage."
  },
  {
    "variants": [
      "Shortest Path",
      "Shortest Paths"
    ],
    "definition": "The problem of finding a path between two vertices in a graph such that the sum of edge weights is minimized. Algorithms include Dijkstra's (for non-negative weights) and Bellman-Ford (for graphs with negative weights)."
  },
  {
    "variants": [
      "Sink Vertex",
      "Sink Vertexs"
    ],
    "definition": "In a directed graph, a vertex with no outgoing edges (outdegree zero). In flow networks, the sink is the designated target node where flow is collected."
  },
  {
    "variants": [
      "Sort",
      "Sorts"
    ],
    "definition": "The process of arranging elements in a list into a specified order, usually ascending or descending. Common sorting algorithms include quicksort, mergesort, heapsort, and insertion sort."
  },
  {
    "variants": [
      "Source Vertex",
      "Source Vertexs"
    ],
    "definition": "In a directed graph, a vertex with no incoming edges (indegree zero). In flow networks, the source is the designated origin node where flow is generated."
  },
  {
    "variants": [
      "Space Complexity",
      "Space Complexitys"
    ],
    "definition": "The amount of memory an algorithm uses relative to the size of its input, often expressed using asymptotic notation. It includes both auxiliary and input storage."
  },
  {
    "variants": [
      "Spanning Tree",
      "Spanning Trees"
    ],
    "definition": "A subgraph of a connected, undirected graph that includes all vertices and is a tree (acyclic and connected). The minimum spanning tree is the spanning tree with the smallest total edge weight."
  },
  {
    "variants": [
      "Stable Sort",
      "Stable Sorts"
    ],
    "definition": "A sorting algorithm that maintains the relative order of records with equal keys. Examples include merge sort and insertion sort, while selection sort and heapsort are not stable by default."
  },
  {
    "variants": [
      "Stack",
      "Stacks"
    ],
    "definition": "A last-in-first-out (LIFO) data structure supporting push (add to top) and pop (remove from top) in O(1) time. It is used in recursion, depth-first search, and expression evaluation."
  },
  {
    "variants": [
      "Subset",
      "Subsets"
    ],
    "definition": "A set containing zero or more elements all taken from another set. The power set of a set of size n has 2^n subsets, and generating subsets is a common combinatorial task."
  },
  {
    "variants": [
      "Tail Recursion",
      "Tail Recursions"
    ],
    "definition": "A special case of recursion where the recursive call is the last operation in the function, allowing optimizations that convert recursion into iteration to save stack space. Languages or compilers that support tail-call optimization can execute tail-recursive functions in constant space."
  },
  {
    "variants": [
      "Time Complexity",
      "Time Complexitys"
    ],
    "definition": "A measure of the amount of time an algorithm takes as a function of input size, often expressed using asymptotic notation. It helps compare the efficiency of algorithms."
  },
  {
    "variants": [
      "Topological Sort",
      "Topological Sorts"
    ],
    "definition": "A linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u,v), vertex u comes before v in the ordering. It can be computed in O(V + E) time using DFS or Kahn's algorithm."
  },
  {
    "variants": [
      "Tree",
      "Trees"
    ],
    "definition": "A connected, acyclic undirected graph. As a data structure, each node can have children, and operations include traversal (preorder, inorder, postorder), insertion, and deletion."
  },
  {
    "variants": [
      "Undirected Graph",
      "Undirected Graphs"
    ],
    "definition": "A graph in which each edge connects two vertices symmetrically, with no direction. Represented by adjacency lists or matrices, common in modeling symmetric relations."
  },
  {
    "variants": [
      "Union-Find",
      "Union-Finds"
    ],
    "definition": "A data structure that keeps track of disjoint sets and supports union (merge two sets) and find (determine set representative) operations, often implemented with union by rank and path compression for nearly constant-time performance."
  },
  {
    "variants": [
      "Upper Bound",
      "Upper Bounds"
    ],
    "definition": "A function that serves as an asymptotic upper limit on the growth of another function, often expressed using Big O notation. It guarantees that an algorithm's running time will not exceed this bound for sufficiently large inputs."
  },
  {
    "variants": [
      "Vertex Cover",
      "Vertex Covers"
    ],
    "definition": "A set of vertices in a graph such that every edge has at least one endpoint in the set. Finding the minimum vertex cover is NP-hard."
  },
  {
    "variants": [
      "Weighted Edge",
      "Weighted Edges"
    ],
    "definition": "An edge in a graph that has an associated numerical value (weight), representing cost, distance, or capacity. Algorithms like Dijkstra's and Kruskal's take edge weights into account."
  },
  {
    "variants": [
      "Worst-Case Analysis"
    ],
    "definition": "An evaluation of an algorithm's performance under the worst possible input of a given size, often giving an upper bound on running time or space usage. It ensures algorithm reliability by considering the most expensive scenario."
  }
]