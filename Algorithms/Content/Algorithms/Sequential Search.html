<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sequential Search Tutorial &amp; Demo</title>
  <!-- GitHub-style for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="../../scripts/chapterScripts.js"></script>
  <link rel="stylesheet" href="../../style.css">

  <!-- MathJax for LaTeX rendering -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    #toggleAnswers { margin-top: 10px; padding: 5px 10px; }
  </style>
</head>
<body>

  <h1>Sequential Search</h1>

  
    <h2>Problem Statement</h2>
    <p>Given an array of integers (or other comparable objects) and a target value to search for,
	returns the index of the target in the array, or <code>-1</code> if it is not present.</p>
    <strong>Example:</strong>
    <pre><code>Input:  [5, 3, 8, 1, 2], target = 8
Output: 2</code></pre>
 

  
    <h2>Design and Strategy</h2>
    <p>
  Sequential Search (also called Linear Search) is a classic <strong>brute-force</strong> algorithm: it makes no assumptions about the order of the data and
  exhaustively tests every element. Starting at index <code>0</code>, it compares the value of each element to the target value; if a match is found,
  it immediately returns the index of that element. Otherwise, it moves to the next element, continuing until either the target is located or the end of the array is reached  at which point it returns -1.
  Because it “tries every possibility,” you are guaranteed to find 
  the target if it is present with no more than <code>n</code> comparisons.  </p>
  <p> 
  More formally, the algorithm works as follows:
</p>

    <ol>
      <li>Start with index <code>i = 0</code>.</li>
      <li>Compare <code>A[i]</code> with <code>target</code>.</li>
      <li>If they are equal, return <code>i</code>.</li>
      <li>Otherwise, increment <code>i</code>.</li>
      <li>If <code>i==n</code> (end of the array), return <code>-1</code>. Otherwise, repeat from step 2.</li>
    </ol>
	 <div class="embeddedDemoContainer">
  <object class="embeddedDemo" 
          type="text/html" 
          style="height: 325px"
          data="../Demos/Sequential Search Demo.html"></object>
</div>	
	<h2>Time/Space Analysis</h2>

    
 <p><strong>Time Complexity:</strong> We count the number of element‐to‐target comparisons \(C\) as our cost metric. If the target is found at position \(k\), then:</p>
<ul>
  <li>\(\,C(k) = k\,\) comparisons (you check each element once).</li>
  <li>If the target is not present, you perform \(\,C(n+1) = n\,\) comparisons (you stop after checking all \(n\) elements).</li>
</ul>
<p>From this we can see:</p>
<ul>
  <li><strong>Best‐case:</strong> \(\,C(1) = 1\,\), so the complexity is \(\,O(1)\,\) (target at first position).</li>
  <li><strong>Worst‐case:</strong> \(\,C(n) = n\,\), so the complexity is \(\,O(n)\,\) (target at last position or absent).</li>
 
  <li><strong>Average‐case:</strong> assuming the target is equally likely to be in any of the \(n\) slots (or missing), the average value of the index would be \(\frac{n}{2}\), thus the complexity would be \(\displaystyle O\!\bigl(\tfrac{n}{2}\bigr) = O(n)\).</li>


</ul>

 

 
  <p> <b>Space Complexity:</b> The iterative sequential search uses only a fixed number of additional variables:</p>
  <ul>
    <li>The loop index <code>i</code>.</li>
    <li>Space for the <code>target</code> and a few constant‐size temporaries (if any).</li>
  </ul>
  <p>Thus, the space complexity is O(1)</p>
</div>
  </div>

 


    <h2>Implementation in Java, C++, Python</h2>
    <div class="tabs">
      <button class="tablink active" onclick="openTab(event, 'java')">Java</button>
      <button class="tablink" onclick="openTab(event, 'cpp')">C++</button>
      <button class="tablink" onclick="openTab(event, 'python')">Python</button>
   </div>
    <div id="java" class="code-container">
<pre><code class="language-java">public int sequentialSearch(int[] A, int target) {
  for (int i = 0; i < A.length; i++) {
    if (A[i] == target) {
      return i;
    }
  }
  return -1;
}</code></pre>
    </div>

    <div id="cpp" class="code-container">
<pre><code class="language-cpp">int sequentialSearch(int A[], int n, int target) {
  for (int i = 0; i < n; i++) {
    if (A[i] == target) {
      return i;
    }
  }
  return -1;
}</code></pre>
    </div>

    <div id="python" class="code-container">
<pre><code class="language-python">def sequential_search(A, target):
  for i, value in enumerate(A):
    if value == target:
      return i
  return -1</code></pre>
    </div>

  
    <h2>Reading Comprehension Questions</h2>
    <ol>
      <li><strong>Q1:</strong> What is the best-case time complexity for Sequential Search, and when does it occur?</li>
      <li><strong>Q2:</strong> What is the worst-case time complexity for Sequential Search, and when does it occur?</li>
      <li><strong>Q3:</strong> What algorithm technique does Sequential Search use, how do you know?</li>
      <li><strong>Q4:</strong> If the array contains multiple copies of the target, which index will this implementation return?</li>
      <li><strong>Q5:</strong> What is the space complexity of this algorithm?</li>
      <li><strong>Q6:</strong> How would you modify the algorithm to return all indices where the target occurs?</li>
    </ol>
    <button id="toggleAnswers" class="show-answer" aria-expanded="false">Show Answers</button>
    <div id="answers" class="answer" hidden>
      <ol>
        <li><strong>Answer:</strong> <code>O(1)</code>, when the target is at index 0.</li>
        <li><strong>Answer:</strong> <code>O(n)</code>, when the target is at the last position or not present.</li>
        <li><strong>Answer:</strong> Brute Force because it checks every element until it either finds the target or reaches the end.</li>
        <li><strong>Answer:</strong> It returns the index of the first matching element found.</li>
        <li><strong>Answer:</strong> <code>O(1)</code>, since it uses constant extra space.</li>
        <li><strong>Answer:</strong> Collect matches in a list as you scan and return that list instead of stopping early.</li>
      </ol>
    </div>
  

 <h2>In-Class Activities</h2>
<ul>
  <li>Walk through the algorithm on different arrays to count comparisons.</li>
  <li>Discuss how the target’s position affects performance.</li>
  <li>Compare and contrast with binary search on sorted data.</li>
  <li>Explore handling of duplicate targets in various implementations.</li>
  <li>Simulate a <strong>sentinel-based</strong> sequential search: place a copy of the target at the end to eliminate the boundary check, then compare the number of comparisons and loop logic to the standard version.</li>
  </ul>

<h2>Problems</h2>
<ol>
  <li>Implement a recursive version of sequential search (with pseudocode).</li>
  <li>Adapt sequential search to operate on a singly linked list (with pseudocode).</li>
  <li>Modify the algorithm to <strong>return all indices</strong> where the target occurs (not just the first), then analyze how this changes your time and space complexity.</li>
  <li>Implement a <strong>sentinel-based</strong> sequential search: before scanning, append the target as a sentinel at the end of the array to remove the explicit bounds check; then compare its performance (number of comparisons and code branches) against the standard implementation.</li>
</ol>
  
<script>
       // Toggle answers
	   
      document.getElementById('toggleAnswers').addEventListener('click', () => {
        const ans = document.getElementById('answers');
        const btn = document.getElementById('toggleAnswers');
        const shown = ans.style.display === 'block';
        ans.style.display = shown ? 'none' : 'block';
        btn.textContent = shown ? 'Show Answers' : 'Hide Answers';
      });
</script>
</body>
</html>
